var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// ../../node_modules/array-equal/index.js
var require_array_equal = __commonJS({
  "../../node_modules/array-equal/index.js"(exports, module) {
    module.exports = function equal(arr1, arr2) {
      var length4 = arr1.length;
      if (arr1 === arr2) return true;
      if (length4 !== arr2.length) return false;
      for (var i = 0; i < length4; i++)
        if (arr1[i] !== arr2[i])
          return false;
      return true;
    };
  }
});

// ../../node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};

// ../../node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  out[4] = a[4] + b[4] * scale6;
  out[5] = a[5] + b[5] * scale6;
  out[6] = a[6] + b[6] * scale6;
  out[7] = a[7] + b[7] * scale6;
  out[8] = a[8] + b[8] * scale6;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// ../../node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x, y, z);
  var s, c, t;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len4;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len4 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len4;
  z1 *= len4;
  z2 *= len4;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len4 = Math.hypot(x0, x1, x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len4 = Math.hypot(y0, y1, y2);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y2 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len4 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  out[4] = a[4] + b[4] * scale6;
  out[5] = a[5] + b[5] * scale6;
  out[6] = a[6] + b[6] * scale6;
  out[7] = a[7] + b[7] * scale6;
  out[8] = a[8] + b[8] * scale6;
  out[9] = a[9] + b[9] * scale6;
  out[10] = a[10] + b[10] * scale6;
  out[11] = a[11] + b[11] * scale6;
  out[12] = a[12] + b[12] * scale6;
  out[13] = a[13] + b[13] * scale6;
  out[14] = a[14] + b[14] * scale6;
  out[15] = a[15] + b[15] * scale6;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// ../../node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len4 = x * x + y * y + z * z;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  out[2] = a[2] * len4;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale6) {
  scale6 = scale6 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale6;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale6;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../../node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len4 = x * x + y * y + z * z + w * w;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x * len4;
  out[1] = y * len4;
  out[2] = z * len4;
  out[3] = w * len4;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale6) {
  scale6 = scale6 || 1;
  var v1, v2, v3, v42;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v42 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v42 * v42;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale6 * v1;
  out[1] = scale6 * v2;
  out[2] = scale6 * v3 * d;
  out[3] = scale6 * v42 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// ../../node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add5,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  max: () => max3,
  min: () => min3,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate3,
  normalize: () => normalize3,
  random: () => random3,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set5,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength3,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create5() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues5(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set5(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply5(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length3(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength3(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize3(out, a) {
  var x = a[0], y = a[1];
  var len4 = x * x + y * y;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  return out;
}
function dot3(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp3(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random3(out, scale6) {
  scale6 = scale6 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale6;
  out[1] = Math.sin(r) * scale6;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str5(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals5(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len3 = length3;
var sub5 = subtract5;
var mul5 = multiply5;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen3 = squaredLength3;
var forEach3 = function() {
  var vec = create5();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// package.json
var version = "0.51.0";

// src/logger.ts
var _Log = class _Log {
  constructor({ name = "niivue", level = "info" } = {}) {
    __publicField(this, "level");
    __publicField(this, "name");
    this.name = `${name}`;
    this.level = level;
  }
  debug(...args) {
    if (_Log.levels[this.level] > _Log.levels.debug) {
      return;
    }
    console.debug(`${this.name}-debug`, ...args);
  }
  info(...args) {
    if (_Log.levels[this.level] > _Log.levels.info) {
      return;
    }
    console.info(`${this.name}-info`, ...args);
  }
  warn(...args) {
    if (_Log.levels[this.level] > _Log.levels.warn) {
      return;
    }
    console.warn(`${this.name}-warn`, ...args);
  }
  error(...args) {
    if (_Log.levels[this.level] > _Log.levels.error) {
      return;
    }
    console.error(`${this.name}-error`, ...args);
  }
  fatal(...args) {
    if (_Log.levels[this.level] > _Log.levels.fatal) {
      return;
    }
    console.error(`${this.name}-fatal`, ...args);
  }
  setLogLevel(level) {
    this.level = level;
  }
  setName(name) {
    this.name = name;
  }
};
// map 'debug' 'info' 'warn' 'error' 'fatal' 'silent' to numbers
// for comparison
__publicField(_Log, "levels", {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  fatal: 4,
  silent: Infinity
});
var Log = _Log;
var log = new Log({ name: "niivue", level: "info" });

// src/shader.ts
var compileShader = function(gl, vert, frag) {
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vert);
  gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, frag);
  gl.compileShader(fs);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log(gl.getProgramInfoLog(program));
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.log("Vertex shader compilation error:", gl.getShaderInfoLog(vs));
    }
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.log("Fragment shader compilation error:", gl.getShaderInfoLog(fs));
    }
    log.error(gl.getProgramInfoLog(program));
    throw new Error("Shader failed to link, see console for log");
  }
  return program;
};
var Shader = class {
  constructor(gl, vertexSrc, fragmentSrc) {
    __publicField(this, "program");
    __publicField(this, "uniforms", {});
    __publicField(this, "isMatcap");
    this.program = compileShader(gl, vertexSrc, fragmentSrc);
    const regexUniform = /uniform[^;]+[ ](\w+);/g;
    const matchUniformName = /uniform[^;]+[ ](\w+);/;
    const vertexUnifs = vertexSrc.match(regexUniform);
    const fragUnifs = fragmentSrc.match(regexUniform);
    if (vertexUnifs) {
      vertexUnifs.forEach((unif) => {
        const m = unif.match(matchUniformName);
        this.uniforms[m[1]] = -1;
      });
    }
    if (fragUnifs) {
      fragUnifs.forEach((unif) => {
        const m = unif.match(matchUniformName);
        this.uniforms[m[1]] = -1;
      });
    }
    for (const unif in this.uniforms) {
      this.uniforms[unif] = gl.getUniformLocation(this.program, unif);
    }
  }
  use(gl) {
    gl.useProgram(this.program);
  }
};

// src/shader-srcs.ts
var vertRenderShader = `#version 300 es
#line 4
layout(location=0) in vec3 pos;
layout(location=1) in vec3 texCoords;
uniform mat4 mvpMtx;
out vec3 vColor;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vColor = texCoords;
}`;
var kDrawFunc = `
	vec4 drawColor(float scalar, float drawOpacity) {
		float nlayer = float(textureSize(colormap, 0).y);
		float layer = (nlayer - 0.5) / nlayer;
		vec4 dcolor = texture(colormap, vec2((scalar * 255.0)/256.0 + 0.5/256.0, layer)).rgba;
		dcolor.a *= drawOpacity;
		return dcolor;
}`;
var kRenderFunc = `vec3 GetBackPosition(vec3 startPositionTex) {
	vec3 startPosition = startPositionTex * volScale;
	vec3 invR = 1.0 / rayDir;
	vec3 tbot = invR * (vec3(0.0)-startPosition);
	vec3 ttop = invR * (volScale-startPosition);
	vec3 tmax = max(ttop, tbot);
	vec2 t = min(tmax.xx, tmax.yz);
	vec3 endPosition = startPosition + (rayDir * min(t.x, t.y));
	//convert world position back to texture position:
	endPosition = endPosition / volScale;
	return endPosition;
}

vec4 applyClip (vec3 dir, inout vec4 samplePos, inout float len, inout bool isClip) {
	float cdot = dot(dir,clipPlane.xyz);
	isClip = false;
	if  ((clipPlane.a > 1.0) || (cdot == 0.0)) return samplePos;
	bool frontface = (cdot > 0.0);
	float dis = (-clipPlane.a - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	float thick = clipThick;
	if (thick <= 0.0) thick = 2.0;
	float  disBackFace = (-(clipPlane.a-thick) - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	if (((frontface) && (dis >= len)) || ((!frontface) && (dis <= 0.0))) {
		samplePos.a = len + 1.0;
		return samplePos;
	}
	if (frontface) {
		dis = max(0.0, dis);
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		if (dis > 0.0) isClip = true;
		len = min(disBackFace, len);
	}
	if (!frontface) {
		len = min(dis, len);
		disBackFace = max(0.0, disBackFace);
		if (len == dis) isClip = true;
		samplePos = vec4(samplePos.xyz+dir * disBackFace, disBackFace);
	}
	return samplePos;
}

void clipVolume(inout vec3 startPos, inout vec3 backPos, int dim, float frac, bool isLo) {
	vec3 dir = backPos - startPos;
	float len = length(dir);
	dir = normalize(dir);
	// Discard if both startPos and backPos are outside the clipping plane
	if (isLo && startPos[dim] < frac && backPos[dim] < frac) {
		discard;
	}
	if (!isLo && startPos[dim] > frac && backPos[dim] > frac) {
		discard;
	}
	vec4 plane = vec4(0.0, 0.0, 0.0, 0.5 - frac);
	plane[dim] = 1.0;
	float cdot = dot(dir, plane.xyz);
	float dis = (-plane.w - dot(plane.xyz, startPos - vec3(0.5))) / cdot;
	// Adjust startPos or backPos based on the intersection with the plane
	bool isFrontFace = (cdot > 0.0);
	if (!isLo)
		isFrontFace = !isFrontFace;
	if (dis > 0.0) {
		if (isFrontFace) {
				if (dis <= len) {
					startPos = startPos + dir * dis;
				}
		} else {
			if (dis < len) {
				backPos = startPos + dir * dis;
			}
		}
	}
}

void clipVolumeStart (inout vec3 startPos, inout vec3 backPos) {
	// vec3 clipLo = vec3(0.1, 0.2, 0.4);
	// vec3 clipHi = vec3(0.8, 0.7, 0.7);
	for (int i = 0; i < 3; i++) {
		if (clipLo[i] > 0.0)
			clipVolume(startPos, backPos, i, clipLo[i], true);
	}
	for (int i = 0; i < 3; i++) {
		if (clipHi[i] < 1.0)
			clipVolume(startPos, backPos, i, clipHi[i], false);
	}
}

float frac2ndc(vec3 frac) {
//https://stackoverflow.com/questions/7777913/how-to-render-depth-linearly-in-modern-opengl-with-gl-fragcoord-z-in-fragment-sh
	vec4 pos = vec4(frac.xyz, 1.0); //fraction
	vec4 dim = vec4(vec3(textureSize(volume, 0)), 1.0);
	pos = pos * dim;
	vec4 shim = vec4(-0.5, -0.5, -0.5, 0.0);
	pos += shim;
	vec4 mm = transpose(matRAS) * pos;
	float z_ndc = (mvpMtx * vec4(mm.xyz, 1.0)).z;
	return (z_ndc + 1.0) / 2.0;
}` + kDrawFunc;
var kRenderInit = `void main() {
	if (fColor.x > 2.0) {
		fColor = vec4(1.0, 0.0, 0.0, 0.5);
		return;
	}
	fColor = vec4(0.0,0.0,0.0,0.0);
	vec4 clipPlaneColorX = clipPlaneColor;
	//if (clipPlaneColor.a < 0.0)
	//	clipPlaneColorX.a = - 1.0;
	bool isColorPlaneInVolume = false;
	if (clipPlaneColorX.a < 0.0) {
		isColorPlaneInVolume = true;
		clipPlaneColorX.a = 0.0;
	}
	//fColor = vec4(vColor.rgb, 1.0); return;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	// fColor = vec4(backPosition, 1.0); return;
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	dir = normalize(dir);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	//if ((clipPos.a != samplePos.a) && (len < 3.0)) {
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	float drawOpacityA = renderDrawAmbientOcclusionXY.y;
	if ((samplePos.a >= len) && (((overlays < 1.0) && (drawOpacityA <= 0.0) ) || (backgroundMasksOverlays > 0)))  {
		if (isClip)
			fColor += clipPlaneColorX;
		return;
	}
	fColor = vec4(1.0, 1.0, 1.0, 1.0);
	//gl_FragDepth = frac2ndc(samplePos.xyz); //crude due to fast pass resolution
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * lenNoClip);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
`;
var kRenderTail = `
	if (firstHit.a < len)
		gl_FragDepth = frac2ndc(firstHit.xyz);
	colAcc.a = (colAcc.a / earlyTermination) * backOpacity;
	fColor = colAcc;
	//if (isClip) //CR
	if ((isColorPlaneInVolume) && (clipPos.a != samplePos.a) && (abs(firstHit.a - clipPos.a) < deltaDir.a))
		fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));
		//fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, clipPlaneColorX.a * 0.65);
	float renderDrawAmbientOcclusionX = renderDrawAmbientOcclusionXY.x;
	float drawOpacity = renderDrawAmbientOcclusionXY.y;
	if ((overlays < 1.0) && (drawOpacity <= 0.0))
		return;
	//overlay pass
	len = lenNoClip;
	samplePos = vec4(start.xyz, 0.0); //ray position
	//start: OPTIONAL fast pass: rapid traversal until first hit
	stepSizeFast = sliceSize * 1.0;
	deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (drawOpacity > 0.0)
			val = max(val, texture(drawing, samplePos.xyz).r);
		if (val > 0.001)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	if (samplePos.a >= len) {
		if (isClip && (fColor.a == 0.0))
				fColor += clipPlaneColorX;
			return;
	}
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	float overFarthest = len;
	colAcc = vec4(0.0, 0.0, 0.0, 0.0);

	samplePos += deltaDir * ran; //jitter ray
	vec4 overFirstHit = vec4(0.0,0.0,0.0,2.0 * len);
	if (backgroundMasksOverlays > 0)
		samplePos = firstHit;
	bool firstDraw = true;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(overlay, samplePos.xyz);
		if ((colorSample.a < 0.01) && (drawOpacity > 0.0)) {
			float val = texture(drawing, samplePos.xyz).r;
			vec4 draw = drawColor(val, drawOpacity);
			if ((draw.a > 0.0) && (firstDraw)) {
				firstDraw = false;
				float sum = 0.0;
				const float mn = 1.0 / 256.0;
				const float sampleRadius = 1.1;
				float dx = sliceSize * sampleRadius;
				vec3 center = samplePos.xyz;
				//six neighbors that share a face
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,0.0), dir)).r, mn);
				//float proportion = (sum / mn) / 6.0;
				
				//12 neighbors that share an edge
				dx = sliceSize * sampleRadius * sqrt(2.0) * 0.5;
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,-dx,0.0), dir)).r, mn);

				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,-dx,0.0), dir)).r, mn);
				
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,+dx,0.0), dir)).r, mn);
				float proportion = (sum / mn) / 18.0; //proportion of six neighbors is non-zero
				
				//a high proportion of hits means crevice
				//since the AO term adds shadows that darken most voxels, it will result in dark surfaces
				//the term brighten adds a little illumination to balance this
				// without brighten, only the most extreme ridges will not be darker
				const float brighten = 1.2;
				vec3 ao = draw.rgb * (1.0 - proportion) * brighten;
				draw.rgb = mix (draw.rgb, ao , renderDrawAmbientOcclusionX);
			}
			colorSample = draw;
		}
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (overFirstHit.a > len)
				overFirstHit = samplePos;
			colorSample.a *= renderOverlayBlend;
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			overFarthest = samplePos.a;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
	//if (samplePos.a >= len) {
	if (colAcc.a <= 0.0) {
		if (isClip && (fColor.a == 0.0))
			fColor += clipPlaneColorX;
		return;
	}
	if (overFirstHit.a < firstHit.a)
		gl_FragDepth = frac2ndc(overFirstHit.xyz);
	float overMix = colAcc.a;
	float overlayDepth = 0.3;
	if (fColor.a <= 0.0)
		overMix = 1.0;
	else if (((overFarthest) > backNearest)) {
		float dx = (overFarthest - backNearest)/1.73;
		dx = fColor.a * pow(dx, overlayDepth);
		overMix *= 1.0 - dx;
	}
	fColor.rgb = mix(fColor.rgb, colAcc.rgb, overMix);
	fColor.a = max(fColor.a, colAcc.a);
}`;
var fragRenderSliceShader = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + kRenderFunc + `
	void main() {
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		fColor = vec4(0.0,0.0,0.0,0.0);
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float dis = len;
	//check if axial plane is closest
	vec4 aClip = vec4(0.0, 0.0, 1.0, (1.0- clipPlane.z) - 0.5);
	float adis = (-aClip.a - dot(aClip.xyz, samplePos.xyz-0.5)) / dot(dir,aClip.xyz);
	if (adis > 0.0)
		dis = min(adis, dis);
	//check of coronal plane is closest
	vec4 cClip = vec4(0.0, 1.0, 0.0, (1.0- clipPlane.y) - 0.5);
	float cdis = (-cClip.a - dot(cClip.xyz, samplePos.xyz-0.5)) / dot(dir,cClip.xyz);
	if (cdis > 0.0)
		dis = min(cdis, dis);
	//check if coronal slice is closest
	vec4 sClip = vec4(1.0, 0.0, 0.0, (1.0- clipPlane.x) - 0.5);
	float sdis = (-sClip.a - dot(sClip.xyz, samplePos.xyz-0.5)) / dot(dir,sClip.xyz);
	if (sdis > 0.0)
		dis = min(sdis, dis);
	if ((dis > 0.0) && (dis < len)) {
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		colAcc = texture(volume, samplePos.xyz);
		colAcc.a = earlyTermination;
		firstHit = samplePos;
		backNearest = min(backNearest, samplePos.a);
	}
	//the following are only used by overlays
	vec4 clipPlaneColorX = clipPlaneColor;
	bool isColorPlaneInVolume = false;
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
` + kRenderTail;
var fragRenderShader = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + kRenderFunc + kRenderInit + `while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
` + kRenderTail;
var kFragRenderGradientDecl = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 normMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing, gradient;
uniform highp sampler2D colormap;
uniform highp sampler2D matCap;
uniform vec2 renderDrawAmbientOcclusionXY;
uniform float gradientAmount;
uniform float gradientOpacity[256];
in vec3 vColor;
out vec4 fColor;
`;
var fragRenderGradientShader = kFragRenderGradientDecl + kRenderFunc + kRenderInit + `
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			grad.rgb = normalize(grad.rgb*2.0 - 1.0);
			//if (grad.a < prevGrad.a)
			//	grad.rgb = prevGrad.rgb;
			//prevGrad = grad;
			vec3 n = mat3(normMtx) * grad.rgb;
			n.y = - n.y;
			vec4 mc = vec4(texture(matCap, n.xy * 0.5 + 0.5).rgb, 1.0) * brighten;
			mc = mix(vec4(1.0), mc, gradientAmount);
			if (samplePos.a > clipClose)
				colorSample.rgb *= mc.rgb;
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			int gradIdx = int(grad.a * 255.0);
			colorSample.a *= gradientOpacity[gradIdx];
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + kRenderTail;
var fragRenderGradientValuesShader = kFragRenderGradientDecl + kRenderFunc + kRenderInit + `
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			colorSample.rgb = abs(normalize(grad.rgb*2.0 - 1.0));
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + kRenderTail;
var vertSliceMMShader = `#version 300 es
#line 392
layout(location=0) in vec3 pos;
uniform int axCorSag;
uniform mat4 mvpMtx;
uniform mat4 frac2mm;
uniform float slice;
out vec3 texPos;
void main(void) {
	texPos = vec3(pos.x, pos.y, slice);
	if (axCorSag > 1)
		texPos = vec3(slice, pos.x, pos.y);
	else if (axCorSag > 0)
		texPos = vec3(pos.x, slice, pos.y);
	vec4 mm = frac2mm * vec4(texPos, 1.0);
	gl_Position = mvpMtx * mm;
}`;
var kFragSliceHead = `#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler3D volume, overlay;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;` + kDrawFunc + `void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 ocolor = vec4(0.0);
	float overlayAlpha = overlayAlphaShader;
	if (overlays > 0.0) {
		ocolor = texture(overlay, texPos);
		//dFdx for "boxing" issue 435 has aliasing on some implementations (coarse vs fine)
		//however, this only identifies 50% of the edges due to aliasing effects
		// http://www.aclockworkberry.com/shader-derivative-functions/
		// https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b
		//if ((ocolor.a >= 1.0) && ((dFdx(ocolor.a) != 0.0) || (dFdy(ocolor.a) != 0.0)  ))
		//	ocolor.rbg = vec3(0.0, 0.0, 0.0);
		bool isOutlineBelowNotAboveThreshold = true;
		if (isOutlineBelowNotAboveThreshold) {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a < 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				//6 voxel neighbors that share a face
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 0.0;
				if (axCorSag != 2) {
					a = max(a, texture(overlay, vxR).a);
					a = max(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = max(a, texture(overlay, vxA).a);
					a = max(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = max(a, texture(overlay, vxS).a);
					a = max(a, texture(overlay, vxI).a);
				}
				bool isCheckCorners = true;
				if (isCheckCorners) {
					//12 voxel neighbors that share an edge
					vec3 vxRA = vec3(texPos.x+vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxLA = vec3(texPos.x-vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxRP = vec3(texPos.x+vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxLP = vec3(texPos.x-vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxRS = vec3(texPos.x+vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxLS = vec3(texPos.x-vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxRI = vec3(texPos.x+vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxLI = vec3(texPos.x-vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxAS = vec3(texPos.x, texPos.y+vx.y, texPos.z+vx.z);
					vec3 vxPS = vec3(texPos.x, texPos.y-vx.y, texPos.z+vx.z);
					vec3 vxAI = vec3(texPos.x, texPos.y+vx.y, texPos.z-vx.z);
					vec3 vxPI = vec3(texPos.x, texPos.y-vx.y, texPos.z-vx.z);

					if (axCorSag == 0) { //axial corners
						a = max(a, texture(overlay, vxRA).a);
						a = max(a, texture(overlay, vxLA).a);
						a = max(a, texture(overlay, vxRP).a);
						a = max(a, texture(overlay, vxLP).a);
					}
					if (axCorSag == 1) { //coronal corners
						a = max(a, texture(overlay, vxRS).a);
						a = max(a, texture(overlay, vxLS).a);
						a = max(a, texture(overlay, vxRI).a);
						a = max(a, texture(overlay, vxLI).a);
					}
					if (axCorSag == 2) { //sagittal corners
						a = max(a, texture(overlay, vxAS).a);
						a = max(a, texture(overlay, vxPS).a);
						a = max(a, texture(overlay, vxAI).a);
						a = max(a, texture(overlay, vxPI).a);
					}
				}
				if (a >= 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}

		} else {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a >= 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 1.0;
				if (axCorSag != 2) {
					a = min(a, texture(overlay, vxR).a);
					a = min(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = min(a, texture(overlay, vxA).a);
					a = min(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = min(a, texture(overlay, vxS).a);
					a = min(a, texture(overlay, vxI).a);
				}
				if (a < 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}
		} //outline above threshold
	}

`;
var kFragSliceTail = `	ocolor.a *= overlayAlpha;
	vec4 dcolor = drawColor(texture(drawing, texPos).r, drawOpacity);
	if (dcolor.a > 0.0) {
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
	if ((backgroundMasksOverlays > 0) && (background.a == 0.0))
		return;
	float a = color.a + ocolor.a * (1.0 - color.a); // premultiplied alpha
	if (a == 0.0) return;
	color.rgb = mix(color.rgb, ocolor.rgb, ocolor.a / a);
	color.a = a;
}`;
var fragSliceMMShader = kFragSliceHead + kFragSliceTail;
var fragSliceV1Shader = kFragSliceHead + `	if (ocolor.a > 0.0) {
		//https://gamedev.stackexchange.com/questions/102889/is-it-possible-to-convert-vec4-to-int-in-glsl-using-opengl-es
		uint alpha = uint(ocolor.a * 255.0);
		vec3 xyzFlip = vec3(float((uint(1) & alpha) > uint(0)), float((uint(2) & alpha) > uint(0)), float((uint(4) & alpha) > uint(0)));
		//convert from 0 and 1 to -1 and 1
		xyzFlip = (xyzFlip * 2.0) - 1.0;
		//https://math.stackexchange.com/questions/1905533/find-perpendicular-distance-from-point-to-line-in-3d
		//v1 principle direction of tensor for this voxel
		vec3 v1 = ocolor.rgb;
		//flips encode polarity to convert from 0..1 to -1..1 (27 bits vs 24 bit precision)
		v1 = normalize( v1 * xyzFlip);
		vec3 vxl = fract(texPos * vec3(textureSize(volume, 0))) - 0.5;
		//vxl coordinates now -0.5..+0.5 so 0,0,0 is origin
		vxl.x = -vxl.x;
		float t = dot(vxl,v1);
		vec3 P = t * v1;
		float dx = length(P-vxl);
		ocolor.a = 1.0 - smoothstep(0.2,0.25, dx);
		//if modulation was applied, use that to scale alpha not color:
		ocolor.a *= length(ocolor.rgb);
		ocolor.rgb = normalize(ocolor.rgb);
		//compute distance one half voxel closer to viewer:
		float pan = 0.5;
		if (axCorSag == 0)
			vxl.z -= pan;
		if (axCorSag == 1)
			vxl.y -= pan;
		if (axCorSag == 2)
			vxl.x += pan;
		t = dot(vxl,v1);
		P = t * v1;
		float dx2 = length(P-vxl);
		ocolor.rgb += (dx2-dx-(0.5 * pan)) * 1.0;
	}
` + kFragSliceTail;
var fragRectShader = `#version 300 es
#line 480
precision highp int;
precision highp float;
uniform vec4 lineColor;
out vec4 color;
void main() {
	color = lineColor;
}`;
var fragRectOutlineShader = `#version 300 es
#line 723
precision highp int;
precision highp float;

uniform vec4 lineColor;
uniform vec4 leftTopWidthHeight;
uniform float thickness; // line thickness in pixels
uniform vec2 canvasWidthHeight;

out vec4 color;

void main() {
    // fragment position in screen coordinates
    vec2 fragCoord = gl_FragCoord.xy;

    // canvas height
    float canvasHeight = canvasWidthHeight.y;

    // 'top' and 'bottom' to match gl_FragCoord.y coordinate system
    float top = canvasHeight - leftTopWidthHeight.y;
    float bottom = top - leftTopWidthHeight.w;

    // left and right edges
    float left = leftTopWidthHeight.x;
    float right = left + leftTopWidthHeight.z;

    bool withinLeft = fragCoord.x >= left && fragCoord.x <= left + thickness;
    bool withinRight = fragCoord.x <= right && fragCoord.x >= right - thickness;
    bool withinTop = fragCoord.y <= top && fragCoord.y >= top - thickness;
    bool withinBottom = fragCoord.y >= bottom && fragCoord.y <= bottom + thickness;

    bool isOutline = withinLeft || withinRight || withinTop || withinBottom;

    if (isOutline) {
        color = lineColor;
    } else {
        discard; 
    }
}`;
var vertColorbarShader = `#version 300 es
#line 490
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vColor;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vColor = pos.xy;
}`;
var fragColorbarShader = `#version 300 es
#line 506
precision highp int;
precision highp float;
uniform highp sampler2D colormap;
uniform float layer;
in vec2 vColor;
out vec4 color;
void main() {
	float nlayer = float(textureSize(colormap, 0).y);
	float fmap = (0.5 + layer) / nlayer;
	color = vec4(texture(colormap, vec2(vColor.x, fmap)).rgb, 1.0);
}`;
var vertRectShader = `#version 300 es
#line 520
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
}`;
var vertLineShader = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec4 startXYendXY;
void main(void) {
	vec2 posXY = mix(startXYendXY.xy, startXYendXY.zw, pos.x);
	vec2 dir = normalize(startXYendXY.xy - startXYendXY.zw);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0
	gl_Position = vec4((posXY * 2.0) - 1.0, 0.0, 1.0);
}`;
var vertLine3DShader = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec2 startXY;
uniform vec3 endXYZ; // transformed XYZ point
void main(void) {	
	vec2 posXY = mix(startXY.xy, endXYZ.xy, pos.x);
	vec2 startDiff = endXYZ.xy - startXY.xy;
	float startDistance = length(startDiff);
	vec2 diff = endXYZ.xy - posXY;
	float currentDistance = length(diff);
	vec2 dir = normalize(startXY.xy - endXYZ.xy);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0	
	float z = endXYZ.z * ( 1.0 - abs(currentDistance/startDistance)); 
	gl_Position = vec4((posXY * 2.0) - 1.0, z, 1.0);
}`;
var vertBmpShader = `#version 300 es
#line 549
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(pos.x, 1.0 - pos.y);
}`;
var fragBmpShader = `#version 300 es
#line 565
precision highp int;
precision highp float;
uniform highp sampler2D bmpTexture;
in vec2 vUV;
out vec4 color;
void main() {
	color = texture(bmpTexture, vUV);
}`;
var vertFontShader = `#version 300 es
#line 576
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(uvLeftTopWidthHeight.x + (pos.x * uvLeftTopWidthHeight.z), uvLeftTopWidthHeight.y  + ((1.0 - pos.y) * uvLeftTopWidthHeight.w) );
}`;
var fragFontShader = `#version 300 es
#line 593
precision highp int;
precision highp float;
uniform highp sampler2D fontTexture;
uniform vec4 fontColor;
uniform float screenPxRange;
in vec2 vUV;
out vec4 color;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
void main() {
	vec3 msd = texture(fontTexture, vUV).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange*(sd - 0.5);
	float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	color = vec4(fontColor.rgb , fontColor.a * opacity);
}`;
var vertCircleShader = `#version 300 es
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = pos.xy;
}`;
var fragCircleShader = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 circleColor;
uniform float fillPercent;
in vec2 vUV;
out vec4 color;
void main() {
	/* Check if the pixel is inside the circle
		 and color it with a gradient. Otherwise, color it 
		 transparent   */
	float distance = length(vUV-vec2(0.5,0.5));
	if ( distance < 0.5 && distance >= (1.0 - fillPercent) / 2.0){
			color = vec4(circleColor.r,circleColor.g,circleColor.b,circleColor.a) ;			
	}else{
			color = vec4(0.0,0.0,0.0,0.0);
	}
}
`;
var vertOrientShader = `#version 300 es
#line 613
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4( (vPos.xy-vec2(0.5,0.5)) * 2.0, 0.0, 1.0);
}`;
var fragOrientShaderU = `#version 300 es
uniform highp usampler3D intensityVol;
`;
var fragOrientShaderI = `#version 300 es
uniform highp isampler3D intensityVol;
`;
var fragOrientShaderF = `#version 300 es
uniform highp sampler3D intensityVol;
`;
var fragOrientShaderAtlas = `#line 636
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform vec4 xyzaFrac;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint idx = uint(texture(intensityVol, vx.xyz).r);
	FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	if (idx == uint(0))
		return;
	//idx = ((idx - uint(1)) % uint(100))+uint(1);
	float textureWidth = float(textureSize(colormap, 0).x);
	float fx = (float(idx)+0.5) / textureWidth;
	float nlayer = float(textureSize(colormap, 0).y);
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(fx, y)).rgba;
	float alpha = FragColor.a;
	FragColor.a *= opacity;
	if (xyzaFrac.a > 0.0) { //outline
		vx = vec4(TexCoord.x+xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
		uint R = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x-xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
		uint L = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y+xyzaFrac.y, coordZ, 1.0) * mtx;
		uint A = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y-xyzaFrac.y, coordZ, 1.0) * mtx;
		uint P = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y, coordZ+xyzaFrac.z, 1.0) * mtx;
		uint S = uint(texture(intensityVol, vx.xyz).r);
		vx = vec4(TexCoord.x, TexCoord.y, coordZ-xyzaFrac.z, 1.0) * mtx;
		uint I = uint(texture(intensityVol, vx.xyz).r);
		if ((idx != R) || (idx != L) || (idx != A) || (idx != P) || (idx != S) || (idx != I))
			FragColor.a = alpha * xyzaFrac.a;
	}
}`;
var fragOrientShader = `#line 691
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform float cal_maxNeg;
uniform float cal_minNeg;
uniform bool isAlphaThreshold;
uniform bool isColorbarFromZero;
uniform bool isAdditiveBlend;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform int modulation;
uniform highp sampler3D modulationVol;
uniform float opacity;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	if ((vx.x < 0.0) || (vx.x > 1.0) || (vx.y < 0.0) || (vx.y > 1.0) || (vx.z < 0.0) || (vx.z > 1.0)) {
		//set transparent if out of range
		//https://webglfundamentals.org/webgl/webgl-3d-textures-repeat-clamp.html
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	float f = (scl_slope * float(texture(intensityVol, vx.xyz).r)) + scl_inter;
	float mn = cal_min;
	float mx = cal_max;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mn = 0.0;
	float r = max(0.00001, abs(mx - mn));
	mn = min(mn, mx);
	float txl = mix(0.0, 1.0, (f - mn) / r);
	if (f > mn) { //issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
	}
	//https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space
	float nlayer = float(textureSize(colormap, 0).y);
	//each volume has two color maps:
	// (layer*2) = negative and (layer * 2) + 1 = postive
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(txl, y)).rgba;
	//negative colors
	mn = cal_minNeg;
	mx = cal_maxNeg;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mx = 0.0;
	//if ((!isnan(cal_minNeg)) && ( f < mx)) {
	if ((cal_minNeg < cal_maxNeg) && ( f < mx)) {
		r = max(0.00001, abs(mx - mn));
		mn = min(mn, mx);
		txl = 1.0 - mix(0.0, 1.0, (f - mn) / r);
		//issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
		y = ((2.0 * layer) + 0.5)/nlayer;
		FragColor = texture(colormap, vec2(txl, y));
	}
	if (layer > 0.7)
		FragColor.a = step(0.00001, FragColor.a);
	//if (modulation > 10)
	//	FragColor.a *= texture(modulationVol, vx.xyz).r;
	//	FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (isAlphaThreshold) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = pow(-f / -cal_maxNeg, 2.0);
		else if ((f > 0.0) && (cal_min > 0.0))
			FragColor.a *= pow(f / cal_min, 2.0); //issue435:  A = (V/X)**2
		//FragColor.g = 0.0;
	} else if (isColorbarFromZero) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = 0.0;
		else if ((f > 0.0) && (cal_min > 0.0) && (f < cal_min))
			FragColor.a *= 0.0;

	}
	if (modulation == 1) {
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	} else if (modulation == 2) {
		FragColor.a = texture(modulationVol, vx.xyz).r;
	}
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	if (isAdditiveBlend)
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
	else
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`;
var fragRGBOrientShader = `#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	uvec4 aColor = texture(intensityVol, vx.xyz);
	FragColor = vec4(float(aColor.r) / 255.0, float(aColor.g) / 255.0, float(aColor.b) / 255.0, float(aColor.a) / 255.0);
	if (modulation == 1)
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (!hasAlpha) {
		FragColor.a = (FragColor.r * 0.21 + FragColor.g * 0.72 + FragColor.b * 0.07);
		//next line: we could binarize alpha, but see rendering of visible human
		//FragColor.a = step(0.01, FragColor.a);
	}
	if (modulation == 2)
		FragColor.a = texture(modulationVol, vx.xyz).r;
	FragColor.a *= opacity;
}`;
var vertGrowCutShader = `#version 300 es
#line 808
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4((vPos.x - 0.5) * 2.0, (vPos.y - 0.5) * 2.0, 0.0, 1.0);
}`;
var fragGrowCutShader = `#version 300 es
#line 829
	precision highp float;
	precision highp int;
	precision highp isampler3D;
	layout(location = 0) out int label;
	layout(location = 1) out int strength;
	in vec2 TexCoord;
	uniform int finalPass;
	uniform float coordZ;
	uniform lowp sampler3D in3D;
	uniform highp isampler3D backTex; // background
	uniform highp isampler3D labelTex; // label
	uniform highp isampler3D strengthTex; // strength
void main(void) {
	vec3 interpolatedTextureCoordinate = vec3(TexCoord.xy, coordZ);
	ivec3 size = textureSize(backTex, 0);
	ivec3 texelIndex = ivec3(floor(interpolatedTextureCoordinate * vec3(size)));
	int background = texelFetch(backTex, texelIndex, 0).r;
	label = texelFetch(labelTex, texelIndex, 0).r;
	strength = texelFetch(strengthTex, texelIndex, 0).r;
	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				if (i != 0 && j != 0 && k != 0) {
					ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
					int neighborBackground = texelFetch(backTex, neighborIndex, 0).r;
					int neighborStrength = texelFetch(strengthTex, neighborIndex, 0).r;
					int strengthCost = abs(neighborBackground - background);
					int takeoverStrength = neighborStrength - strengthCost;
					if (takeoverStrength > strength) {
						strength = takeoverStrength;
						label = texelFetch(labelTex, neighborIndex, 0).r;
					}
				}
			}
		}
	}
	if (finalPass < 1)
		return;
	int ok = 1;
	ivec4 labelCount = ivec4(0,0,0,0);
	for (int k = -1; k <= 1; k++)
		for (int j = -1; j <= 1; j++)
			for (int i = -1; i <= 1; i++) {
				ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
				int ilabel = texelFetch(labelTex, neighborIndex, 0).r;
				if ((ilabel < 0) || (ilabel > 3))
					ok = 0;
				else
					labelCount[ilabel]++;
			}
	if (ok != 1) {
		return;
	}
	int maxIdx = 0;
	for (int i = 1; i < 4; i++) {
		if (labelCount[i] > labelCount[maxIdx])
			maxIdx = i;
	}
	label = maxIdx;
}`;
var vertSurfaceShader = `#version 300 es
layout(location=0) in vec3 pos;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
}`;
var fragSurfaceShader = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 surfaceColor;
out vec4 color;
void main() {
	color = surfaceColor;
}`;
var vertFiberShader = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 clr;
out vec4 vClr;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vClr = clr;
}`;
var fragFiberShader = `#version 300 es
precision highp int;
precision highp float;
in vec4 vClr;
out vec4 color;
uniform float opacity;
void main() {
	color = vec4(vClr.rgb, opacity);
}`;
var vertMeshShader = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
out vec3 vN;
out vec4 vP;
out vec4 vPc;
void main(void) {
	vec3 lightPosition = vec3(0.0, 0.0, -10.0);
	vP = vec4(pos, 1.0);
	vPc = mvpMtx * vec4(pos, 1.0);
	gl_Position = vPc;
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`;
var fragMeshDepthShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
out vec4 color;
vec4 packFloatToVec4i(const float value) {
	const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
	const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
	vec4 res = fract(value * bitSh);
	res -= res.xxyz * bitMsk;
	return res;
}
void main() {
	color = packFloatToVec4i(gl_FragCoord.z);
}`;
var fragMeshToonShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
float stepmix(float edge0, float edge1, float E, float x){
	float T = clamp(0.5 * (x - edge0 + E) / E, 0.0, 1.0);
	return mix(edge0, edge1, T);
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0);
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.5;
	float shininess = 50.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float df = max(0.0, dot(n, l));
	float sf = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	const float A = 0.1;
	const float B = 0.3;
	const float C = 0.6;
	const float D = 1.0;
	float E = fwidth(df);
	if (df > A - E && df < A + E) df = stepmix(A, B, E, df);
	else if (df > B - E && df < B + E) df = stepmix(B, C, E, df);
	else if (df > C - E && df < C + E) df = stepmix(C, D, E, df);
	else if (df < A) df = 0.0;
	else if (df < B) df = B;
	else if (df < C) df = C;
	else df = D;
	E = fwidth(sf);
	if (sf > 0.5 - E && sf < 0.5 + E)
		sf = smoothstep(0.5 - E, 0.5 + E, sf);
	else
		sf = step(0.5, sf);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(df, 0.0) * vClr.rgb * diffuse;
	color.rgb = a + d + (specular * sf);
	color.a = opacity;
}`;
var fragMeshOutlineShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.25;
	float shininess = 10.0;
	float PenWidth = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	float view = abs(dot(n,r)); //with respect to viewer
	if (PenWidth < view) discard;
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color.rgb = a + d + s;
	color.a = opacity;
}`;
var fragMeshEdgeShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float diffuse = 1.0;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 0.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d = lightNormDot * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(d + s, opacity);
}`;
var fragMeshDiffuseEdgeShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float diffuse = 1.4;
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(normalize(vN), l), 0.0);
	color = vec4(lightNormDot * vClr.rgb * diffuse, opacity);
}`;
var fragMeshSpecularEdgeShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float specularRGB = 0.7;
	float specularWhite = 0.3;
	float shininess = 10.0;
	float diffuse = 1.0;
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	vec3 n = normalize(vN);
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d3 = lightNormDot * vClr.rgb * diffuse;
	float s = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 s3 = specularRGB * s * vClr.rgb;
	s *= specularWhite;
	color = vec4(d3 + s3 + s, opacity);
}`;
var fragMeshShaderCrevice = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
in vec4 vPc;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	// Compute curvature
	vec3 dx = dFdx(n);
	vec3 dy = dFdy(n);
	vec3 xneg = n - dx;
	vec3 xpos = n + dx;
	vec3 yneg = n - dy;
	vec3 ypos = n + dy;
	float depth = length(vPc.xyz);
	float curv = (cross(xneg, xpos).y - cross(yneg, ypos).x) / depth;
	//at this stage 0.5 for flat, with valleys dark and ridges bright
	curv = 1.0 - (curv + 0.5);
	//clamp
	curv =  min(max(curv, 0.0), 1.0);
	// easing function
	curv = pow(curv, 0.5);
	//modulate ambient and diffuse with curvature
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.6;
	float diffuse = 0.6;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 lightPosition = vec3(0.0, 10.0, -2.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient * curv;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`;
var fragMeshShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`;
var fragMeshMatcapShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
uniform sampler2D matCap;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	vec2 uv = n.xy * 0.5 + 0.5;
	uv.y = 1.0 - uv.y;
	vec3 clr = texture(matCap,uv.xy).rgb * vClr.rgb;
	color = vec4(clr, opacity);
}`;
var fragMeshMatteShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float ambient = 0.35;
	float diffuse = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	color = vec4(a + d, opacity);
}`;
var fragMeshHemiShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 up = vec3(0.0, 1.0, 0.0);
	float ax = dot(n, up) * 0.5 + 0.5;  //Shreiner et al. (2013) OpenGL Programming Guide, 8th Ed., p 388. ISBN-10: 0321773039
	vec3 upClr = vec3(1.0, 1.0, 0.95);
	vec3 downClr = vec3(0.4, 0.4, 0.6);
	vec3 a = vClr.rgb * ambient;
	a *= mix(downClr, upClr, ax);
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`;
var fragMeshShaderSHBlue = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
//Spherical harmonics constants
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;
//Spherical harmonics coefficients
// Ramamoorthi, R., and P. Hanrahan. 2001b. "An Efficient Representation for Irradiance Environment Maps." In Proceedings of SIGGRAPH 2001, pp. 497\u2013500.
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// Constants for Eucalyptus Grove lighting
const vec3 L00  = vec3( 0.3783264,  0.4260425,  0.4504587);
const vec3 L1m1 = vec3( 0.2887813,  0.3586803,  0.4147053);
const vec3 L10  = vec3( 0.0379030,  0.0295216,  0.0098567);
const vec3 L11  = vec3(-0.1033028, -0.1031690, -0.0884924);
const vec3 L2m2 = vec3(-0.0621750, -0.0554432, -0.0396779);
const vec3 L2m1 = vec3( 0.0077820, -0.0148312, -0.0471301);
const vec3 L20  = vec3(-0.0935561, -0.1254260, -0.1525629);
const vec3 L21  = vec3(-0.0572703, -0.0502192, -0.0363410);
const vec3 L22  = vec3( 0.0203348, -0.0044201, -0.0452180);
vec3 SH(vec3 vNormal) {
	vNormal = vec3(vNormal.x,vNormal.z,vNormal.y);
	vec3 diffuseColor = C1 * L22 * (vNormal.x * vNormal.x - vNormal.y * vNormal.y) +
	C3 * L20 * vNormal.z * vNormal.z +
	C4 * L00 -
	C5 * L20 +
	2.0 * C1 * L2m2 * vNormal.x * vNormal.y +
	2.0 * C1 * L21  * vNormal.x * vNormal.z +
	2.0 * C1 * L2m1 * vNormal.y * vNormal.z +
	2.0 * C2 * L11  * vNormal.x +
	2.0 * C2 * L1m1 * vNormal.y +
	2.0 * C2 * L10  * vNormal.z;
	return diffuseColor;
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.1;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 a = vClr.rgb * ambient;
	vec3 d = vClr.rgb * diffuse * SH(-reflect(n, vec3(l.x, l.y, -l.z)) );
	color = vec4(a + d + s, opacity);
}`;
var vertFlatMeshShader = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
flat out vec3 vN;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`;
var fragFlatMeshShader = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
flat in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`;
var fragVolumePickingShader = `#version 300 es
#line 1260
//precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 volScale;
uniform vec3 texVox;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform mat4 matRAS;
uniform mat4 mvpMtx;
uniform float drawOpacity, renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform int backgroundMasksOverlays;
in vec3 vColor;
out vec4 fColor;
` + kRenderFunc + `
void main() {
	int id = 254;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	fColor = vec4(0.0, 0.0, 0.0, 0.0); //assume no hit: ID = 0
	float fid = float(id & 255)/ 255.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) return;//discard; //length limit for parallel rays
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	dir = normalize(dir);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	if (isClip) fColor = vec4(samplePos.xyz, 253.0 / 255.0); //assume no hit: ID = 0
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			break;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//end: fast pass
	if ((overlays < 1.0) || (backgroundMasksOverlays > 0)) {
		return; //background hit, no overlays
	}
	//overlay pass
	len = min(lenNoClip, samplePos.a); //only find overlay closer than background
	samplePos = vec4(start.xyz, 0.0); //ray position
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			return;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//if (fColor.a == 0.0) discard; //no hit in either background or overlays
	//you only get here if there is a hit with the background that is closer than any overlay
}`;
var vertOrientCubeShader = `#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
layout(location=0)  in vec3 a_position;
layout(location=1)  in vec3 a_color;
// A matrix to transform the positions by
uniform mat4 u_matrix;
out vec3 vColor;
// all shaders have a main function
void main() {
	// Multiply the position by the matrix.
	vec4 pos = vec4(a_position, 1.0);
	gl_Position = u_matrix * vec4(pos);
	vColor = a_color;
}
`;
var fragOrientCubeShader = `#version 300 es
precision highp float;
uniform vec4 u_color;
in vec3 vColor;
out vec4 outColor;
void main() {
	outColor = vec4(vColor, 1.0);
}`;
var vertPassThroughShader = `#version 300 es
#line 1359
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	vec2 viewCoord = (vPos.xy - 0.5) * 2.0;
	gl_Position = vec4((vPos.xy - 0.5) * 2.0, 0.0, 1.0);
}`;
var fragPassThroughShader = `#version 300 es
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform lowp sampler3D in3D;
void main(void) {
 FragColor = texture(in3D, vec3(TexCoord.xy, coordZ));
}`;
var blurVertShader = `#version 300 es
#line 286
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
    TexCoord = vPos.xy;
    gl_Position = vec4( (vPos.xy-vec2(0.5,0.5))* 2.0, 0.0, 1.0);
}`;
var blurFragShader = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 samp = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
 FragColor = samp*0.125;
}`;
var sobelBlurFragShader = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 XYZ = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 vec4 OYZ = texture(intensityVol,vx+vec3(0.0,+dY,+dZ));
 vec4 xYZ = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 vec4 XOZ = texture(intensityVol,vx+vec3(+dX,0.0,+dZ));
 vec4 OOZ = texture(intensityVol,vx+vec3(0.0,0.0,+dZ));
 vec4 xOZ = texture(intensityVol,vx+vec3(-dX,0.0,+dZ));
 vec4 XyZ = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 vec4 OyZ = texture(intensityVol,vx+vec3(0.0,-dY,+dZ));
 vec4 xyZ = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));

 vec4 XYO = texture(intensityVol,vx+vec3(+dX,+dY,0.0));
 vec4 OYO = texture(intensityVol,vx+vec3(0.0,+dY,0.0));
 vec4 xYO = texture(intensityVol,vx+vec3(-dX,+dY,0.0));
 vec4 XOO = texture(intensityVol,vx+vec3(+dX,0.0,0.0));
 vec4 OOO = texture(intensityVol,vx+vec3(0.0,0.0,0.0));
 vec4 xOO = texture(intensityVol,vx+vec3(-dX,0.0,0.0));
 vec4 XyO = texture(intensityVol,vx+vec3(+dX,-dY,0.0));
 vec4 OyO = texture(intensityVol,vx+vec3(0.0,-dY,0.0));
 vec4 xyO = texture(intensityVol,vx+vec3(-dX,-dY,0.0));

 vec4 XYz = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 vec4 OYz = texture(intensityVol,vx+vec3(0.0,+dY,-dZ));
 vec4 xYz = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 vec4 XOz = texture(intensityVol,vx+vec3(+dX,0.0,-dZ));
 vec4 OOz = texture(intensityVol,vx+vec3(0.0,0.0,-dZ));
 vec4 xOz = texture(intensityVol,vx+vec3(-dX,0.0,-dZ));
 vec4 Xyz = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 vec4 Oyz = texture(intensityVol,vx+vec3(0.0,-dY,-dZ));
 vec4 xyz = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));

 vec4 blurred = vec4 (0.0, 0.0, 0.0, 0.0);
 blurred.r = 2.0*(xOz.r +xOZ.r +xyO.r +xYO.r +xOO.r +XOz.r +XOZ.r +XyO.r +XYO.r +XOO.r) +xyz.r +xyZ.r +xYz.r +xYZ.r +Xyz.r +XyZ.r +XYz.r +XYZ.r;
 blurred.g = 2.0*(Oyz.r +OyZ.r +xyO.r +XyO.r +OyO.r +OYz.r +OYZ.r +xYO.r +XYO.r +OYO.r) +xyz.r +Xyz.r +xyZ.r +XyZ.r +xYz.r +XYz.r +xYZ.r +XYZ.r;
 blurred.b = 2.0*(Oyz.r +OYz.r +xOz.r +XOz.r +OOz.r +OyZ.r +OYZ.r +xOZ.r +XOZ.r +OOZ.r) +xyz.r +Xyz.r +xYz.r +XYz.r +xyZ.r +XyZ.r +XyZ.r +XYZ.r;
 blurred.a = 0.32*(abs(blurred.r)+abs(blurred.g)+abs(blurred.b));
 // 0.0357 = 1/28 to account for weights, rescale to 2**16,
 FragColor = 0.0357*blurred;
}`;
var kGradientMagnitude = `
  gradientSample.a = log2(gradientSample.r*gradientSample.r + gradientSample.g*gradientSample.g + gradientSample.b*gradientSample.b + 1.922337562475971e-06) + 18.988706873717717;
`;
var sobelFirstOrderFragShader = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  float TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ)).r;
  float TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ)).r;
  float TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ)).r;
  float TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ)).r;
  float BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ)).r;
  float BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ)).r;
  float BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ)).r;
  float BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ)).r;
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = BAR+BAL+BPR+BPL -TAR-TAL-TPR-TPL;
  gradientSample.g = TPR+TPL+BPR+BPL -TAR-TAL-BAR-BAL;
  gradientSample.b = TAL+TPL+BAL+BPL -TAR-TPR-BAR-BPR;
${kGradientMagnitude}
	// 0.04242020977371934 = 1/(log2(3*8) - log2(1/(255**2*8))) // 3*8 -> max for 1st order gradient
	gradientSample.a *= 0.04242020977371934;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb = (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`;
var sobelSecondOrderFragShader = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform float dX2;
uniform float dY2;
uniform float dZ2;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  vec4 TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
  vec4 TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
  vec4 TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
  vec4 TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
  vec4 BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
  vec4 BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
  vec4 BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
  vec4 BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
  vec4 T = texture(intensityVol,vx+vec3(+dX2,0.0,0.0));
  vec4 A = texture(intensityVol,vx+vec3(0.0,+dY2,0.0));
  vec4 R = texture(intensityVol,vx+vec3(0.0,0.0,+dZ2));
  vec4 B = texture(intensityVol,vx+vec3(-dX2,0.0,0.0));
  vec4 P = texture(intensityVol,vx+vec3(0.0,-dY2,0.0));
  vec4 L = texture(intensityVol,vx+vec3(0.0,0.0,-dZ2));
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = -4.0*B.r +8.0*(BAR.r+BAL.r+BPR.r+BPL.r) -8.0*(TAR.r+TAL.r+TPR.r+TPL.r) +4.0*T.r;
  gradientSample.g = -4.0*P.g +8.0*(TPR.g+TPL.g+BPR.g+BPL.g) -8.0*(TAR.g+TAL.g+BAR.g+BAL.g) +4.0*A.g;
  gradientSample.b = -4.0*L.b +8.0*(TAL.b+TPL.b+BAL.b+BPL.b) -8.0*(TAR.b+TPR.b+BAR.b+BPR.b) +4.0*R.b;
${kGradientMagnitude}
	gradientSample.a *= 0.0325;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb =  (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`;

// src/orientCube.ts
var orientCube = new Float32Array([
  -1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  1,
  -1,
  0,
  0,
  0.74,
  -1,
  1,
  -1,
  0,
  0,
  0.74,
  -1,
  1,
  1,
  0,
  0,
  0.74,
  1,
  1,
  -1,
  0,
  0,
  0.74,
  1,
  1,
  1,
  0,
  0,
  0.74,
  1,
  1,
  1,
  0,
  0,
  0.74,
  -1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  1,
  0.42,
  0,
  0.42,
  1,
  -1,
  1,
  0.42,
  0,
  0.42,
  1,
  -1,
  1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  -1,
  0.64,
  0,
  0,
  -1,
  -1,
  -1,
  0.64,
  0,
  0,
  -1,
  -1,
  1,
  0.64,
  0,
  0,
  -1,
  1,
  -1,
  0.64,
  0,
  0,
  -1,
  1,
  1,
  0.64,
  0,
  0,
  -1,
  1,
  1,
  0.64,
  0,
  0,
  1,
  -1,
  -1,
  0,
  0.5,
  0,
  1,
  -1,
  -1,
  0,
  0.5,
  0,
  1,
  1,
  -1,
  0,
  0.5,
  0,
  1,
  -1,
  1,
  0,
  0.5,
  0,
  1,
  1,
  1,
  0,
  0.5,
  0,
  1,
  1,
  1,
  0,
  0.5,
  0,
  // P
  -0.45,
  1,
  -0.8,
  0,
  0,
  0,
  -0.45,
  1,
  -0.8,
  0,
  0,
  0,
  -0.45,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  -0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  0.6,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  -0.1,
  0,
  0,
  0,
  -0.25,
  1,
  -0.1,
  0,
  0,
  0,
  -0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  -0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  // A
  0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  0.05,
  -1,
  0.8,
  0,
  0,
  0,
  0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  0.05,
  -1,
  0.8,
  0,
  0,
  0,
  -0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  0.13,
  -1,
  -0.3,
  0,
  0,
  0,
  0.13,
  -1,
  -0.3,
  0,
  0,
  0,
  0.07,
  -1,
  -0.1,
  0,
  0,
  0,
  -0.33,
  -1,
  -0.3,
  0,
  0,
  0,
  -0.27,
  -1,
  -0.1,
  0,
  0,
  0,
  -0.27,
  -1,
  -0.1,
  0,
  0,
  0,
  // S
  -0.45,
  0.6,
  1,
  0,
  0,
  0,
  -0.45,
  0.6,
  1,
  0,
  0,
  0,
  -0.45,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.6,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.45,
  0.1,
  1,
  0,
  0,
  0,
  0.45,
  0.1,
  1,
  0,
  0,
  0,
  -0.25,
  0.1,
  1,
  0,
  0,
  0,
  -0.25,
  0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  0.25,
  0.1,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.1,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  -0.25,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.4,
  1,
  0,
  0,
  0,
  0.25,
  -0.4,
  1,
  0,
  0,
  0,
  0.25,
  -0.6,
  1,
  0,
  0,
  0,
  0.45,
  -0.4,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  // I
  -0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  -0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  -0.1,
  0.8,
  -1,
  0,
  0,
  0,
  0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  0.1,
  0.8,
  -1,
  0,
  0,
  0,
  0.1,
  0.8,
  -1,
  0,
  0,
  0,
  // L
  -1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.45,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.6,
  0,
  0,
  0,
  -1,
  0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  0.45,
  -0.6,
  0,
  0,
  0,
  -1,
  0.45,
  -0.6,
  0,
  0,
  0,
  // R
  1,
  0.45,
  -0.8,
  0,
  0,
  0,
  1,
  0.45,
  -0.8,
  0,
  0,
  0,
  1,
  0.45,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  -0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  -0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  0.6,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  -0.1,
  0,
  0,
  0,
  1,
  0.25,
  -0.1,
  0,
  0,
  0,
  1,
  0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  1,
  -0.05,
  -0.1,
  0,
  0,
  0,
  1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0
]);

// src/niivue-object3D.ts
var _NiivueObject3D = class _NiivueObject3D {
  constructor(id, vertexBuffer, mode, indexCount, indexBuffer = null, vao = null) {
    __publicField(this, "sphereIdx", []);
    __publicField(this, "sphereVtx", []);
    __publicField(this, "renderShaders", []);
    __publicField(this, "isVisible", true);
    __publicField(this, "isPickable", true);
    __publicField(this, "vertexBuffer");
    __publicField(this, "indexCount");
    __publicField(this, "indexBuffer");
    __publicField(this, "vao");
    __publicField(this, "mode");
    __publicField(this, "glFlags", 0);
    __publicField(this, "id");
    __publicField(this, "colorId");
    __publicField(this, "modelMatrix", mat4_exports.create());
    __publicField(this, "scale", [1, 1, 1]);
    __publicField(this, "position", [0, 0, 0]);
    __publicField(this, "rotation", [0, 0, 0]);
    __publicField(this, "rotationRadians", 0);
    __publicField(this, "extentsMin", []);
    __publicField(this, "extentsMax", []);
    // TODO needed through NVImage
    __publicField(this, "furthestVertexFromOrigin");
    __publicField(this, "originNegate");
    __publicField(this, "fieldOfViewDeObliqueMM");
    // TODO needed through crosshairs in NiiVue
    __publicField(this, "mm");
    this.vertexBuffer = vertexBuffer;
    this.indexCount = indexCount;
    this.indexBuffer = indexBuffer;
    this.vao = vao;
    this.mode = mode;
    this.id = id;
    this.colorId = [
      (id >> 0 & 255) / 255,
      (id >> 8 & 255) / 255,
      (id >> 16 & 255) / 255,
      (id >> 24 & 255) / 255
    ];
  }
};
__publicField(_NiivueObject3D, "BLEND", 1);
__publicField(_NiivueObject3D, "CULL_FACE", 2);
__publicField(_NiivueObject3D, "CULL_FRONT", 4);
__publicField(_NiivueObject3D, "CULL_BACK", 8);
__publicField(_NiivueObject3D, "ENABLE_DEPTH_TEST", 16);
__publicField(_NiivueObject3D, "generateCrosshairs", function(gl, id, xyzMM, xyzMin, xyzMax, radius, sides = 20, gap = 0) {
  const geometry = _NiivueObject3D.generateCrosshairsGeometry(gl, xyzMM, xyzMin, xyzMax, radius, sides, gap);
  return new _NiivueObject3D(
    id,
    geometry.vertexBuffer,
    gl.TRIANGLES,
    geometry.indexCount,
    geometry.indexBuffer,
    geometry.vao
  );
});
// not included in public docs
__publicField(_NiivueObject3D, "generateCrosshairsGeometry", function(gl, xyzMM, xyzMin, xyzMax, radius, sides = 20, gap = 0) {
  const vertices = [];
  const indices = [];
  const gapX = radius * gap;
  if (gapX <= 0) {
    let start = vec3_exports.fromValues(xyzMin[0], xyzMM[1], xyzMM[2]);
    let dest = vec3_exports.fromValues(xyzMax[0], xyzMM[1], xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides);
    start = vec3_exports.fromValues(xyzMM[0], xyzMin[1], xyzMM[2]);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMax[1], xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides);
    start = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMin[2]);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMax[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides);
  } else {
    let start = vec3_exports.fromValues(xyzMin[0], xyzMM[1], xyzMM[2]);
    let dest = vec3_exports.fromValues(xyzMM[0] - gapX, xyzMM[1], xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
    start = vec3_exports.fromValues(xyzMM[0] + gapX, xyzMM[1], xyzMM[2]);
    dest = vec3_exports.fromValues(xyzMax[0], xyzMM[1], xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
    start = vec3_exports.fromValues(xyzMM[0], xyzMin[1], xyzMM[2]);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMM[1] - gapX, xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
    start = vec3_exports.fromValues(xyzMM[0], xyzMM[1] + gapX, xyzMM[2]);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMax[1], xyzMM[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
    start = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMin[2]);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMM[2] - gapX);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
    start = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMM[2] + gapX);
    dest = vec3_exports.fromValues(xyzMM[0], xyzMM[1], xyzMax[2]);
    _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, false);
  }
  const vertexBuffer = gl.createBuffer();
  if (vertexBuffer === null) {
    throw new Error("could not instantiate vertex buffer");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  const indexBuffer = gl.createBuffer();
  if (indexBuffer === null) {
    throw new Error("could not instantiate index buffer");
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
  gl.bindVertexArray(null);
  return {
    vertexBuffer,
    indexBuffer,
    indexCount: indices.length,
    vao
  };
});
__publicField(_NiivueObject3D, "getFirstPerpVector", function(v1) {
  const v2 = vec3_exports.fromValues(0, 0, 0);
  if (v1[0] === 0) {
    v2[0] = 1;
  } else if (v1[1] === 0) {
    v2[1] = 1;
  } else if (v1[2] === 0) {
    v2[2] = 1;
  } else {
    v2[0] = v1[2];
    v2[1] = v1[2];
    v2[2] = -(v1[0] + v1[1]);
    vec3_exports.normalize(v2, v2);
  }
  return v2;
});
__publicField(_NiivueObject3D, "subdivide", function(verts, faces) {
  let nv = verts.length / 3;
  let nf = faces.length / 3;
  const n = nf;
  const vNew = vec3_exports.create();
  const nNew = vec3_exports.create();
  for (let faceIndex = 0; faceIndex < n; faceIndex++) {
    const fx = faces[faceIndex * 3 + 0];
    const fy = faces[faceIndex * 3 + 1];
    const fz = faces[faceIndex * 3 + 2];
    const vx = vec3_exports.fromValues(verts[fx * 3 + 0], verts[fx * 3 + 1], verts[fx * 3 + 2]);
    const vy = vec3_exports.fromValues(verts[fy * 3 + 0], verts[fy * 3 + 1], verts[fy * 3 + 2]);
    const vz = vec3_exports.fromValues(verts[fz * 3 + 0], verts[fz * 3 + 1], verts[fz * 3 + 2]);
    vec3_exports.add(vNew, vx, vy);
    vec3_exports.normalize(nNew, vNew);
    verts.push(...nNew);
    vec3_exports.add(vNew, vy, vz);
    vec3_exports.normalize(nNew, vNew);
    verts.push(...nNew);
    vec3_exports.add(vNew, vx, vz);
    vec3_exports.normalize(nNew, vNew);
    verts.push(...nNew);
    let face = [nv, nv + 1, nv + 2];
    faces.push(...face);
    face = [fx, nv, nv + 2];
    faces.push(...face);
    face = [nv, fy, nv + 1];
    faces.push(...face);
    faces[faceIndex * 3 + 0] = nv + 2;
    faces[faceIndex * 3 + 1] = nv + 1;
    faces[faceIndex * 3 + 2] = fz;
    nf = nf + 3;
    nv = nv + 3;
  }
});
__publicField(_NiivueObject3D, "weldVertices", function(verts, faces) {
  const nv = verts.length / 3;
  let nUnique = 0;
  const remap = new Int32Array(nv);
  for (let i = 0; i < nv - 1; i++) {
    if (remap[i] !== 0) {
      continue;
    }
    remap[i] = nUnique;
    let v = i * 3;
    const x = verts[v];
    const y = verts[v + 1];
    const z = verts[v + 2];
    for (let j = i + 1; j < nv; j++) {
      v += 3;
      if (x === verts[v] && y === verts[v + 1] && z === verts[v + 2]) {
        remap[j] = nUnique;
      }
    }
    nUnique++;
  }
  if (nUnique === nv) {
    return verts;
  }
  const nf = faces.length;
  for (let f = 0; f < nf; f++) {
    faces[f] = remap[faces[f]];
  }
  const vtx = verts.slice(0, nUnique * 3 - 1);
  for (let i = 0; i < nv - 1; i++) {
    const v = i * 3;
    const r = remap[i] * 3;
    vtx[r] = verts[v];
    vtx[r + 1] = verts[v + 1];
    vtx[r + 2] = verts[v + 2];
  }
  return vtx;
});
__publicField(_NiivueObject3D, "makeSphere", function(vertices, indices, radius, origin = [0, 0, 0]) {
  let vtx = [
    0,
    0,
    1,
    0.894,
    0,
    0.447,
    0.276,
    0.851,
    0.447,
    -0.724,
    0.526,
    0.447,
    -0.724,
    -0.526,
    0.447,
    0.276,
    -0.851,
    0.447,
    0.724,
    0.526,
    -0.447,
    -0.276,
    0.851,
    -0.447,
    -0.894,
    0,
    -0.447,
    -0.276,
    -0.851,
    -0.447,
    0.724,
    -0.526,
    -0.447,
    0,
    0,
    -1
  ];
  const idx = [
    0,
    1,
    2,
    0,
    2,
    3,
    0,
    3,
    4,
    0,
    4,
    5,
    0,
    5,
    1,
    7,
    6,
    11,
    8,
    7,
    11,
    9,
    8,
    11,
    10,
    9,
    11,
    6,
    10,
    11,
    6,
    2,
    1,
    7,
    3,
    2,
    8,
    4,
    3,
    9,
    5,
    4,
    10,
    1,
    5,
    6,
    7,
    2,
    7,
    8,
    3,
    8,
    9,
    4,
    9,
    10,
    5,
    10,
    6,
    1
  ];
  _NiivueObject3D.subdivide(vtx, idx);
  _NiivueObject3D.subdivide(vtx, idx);
  vtx = _NiivueObject3D.weldVertices(vtx, idx);
  for (let i = 0; i < vtx.length; i++) {
    vtx[i] = vtx[i] * radius;
  }
  const nvtx = vtx.length / 3;
  let j = 0;
  for (let i = 0; i < nvtx; i++) {
    vtx[j] = vtx[j] + origin[0];
    j++;
    vtx[j] = vtx[j] + origin[1];
    j++;
    vtx[j] = vtx[j] + origin[2];
    j++;
  }
  const idx0 = Math.floor(vertices.length / 3);
  for (let i = 0; i < idx.length; i++) {
    idx[i] = idx[i] + idx0;
  }
  indices.push(...idx);
  vertices.push(...vtx);
});
__publicField(_NiivueObject3D, "makeCylinder", function(vertices, indices, start, dest, radius, sides = 20, endcaps = true) {
  if (sides < 3) {
    sides = 3;
  }
  const v1 = vec3_exports.create();
  vec3_exports.subtract(v1, dest, start);
  vec3_exports.normalize(v1, v1);
  const v2 = _NiivueObject3D.getFirstPerpVector(v1);
  const v3 = vec3_exports.create();
  vec3_exports.cross(v3, v1, v2);
  vec3_exports.normalize(v3, v3);
  let num_v = 2 * sides;
  let num_f = 2 * sides;
  if (endcaps) {
    num_f += 2 * sides;
    num_v += 2;
  }
  const idx0 = Math.floor(vertices.length / 3);
  const idx = new Uint32Array(num_f * 3);
  const vtx = new Float32Array(num_v * 3);
  function setV(i, vec3) {
    vtx[i * 3 + 0] = vec3[0];
    vtx[i * 3 + 1] = vec3[1];
    vtx[i * 3 + 2] = vec3[2];
  }
  function setI(i, a, b, c) {
    idx[i * 3 + 0] = a + idx0;
    idx[i * 3 + 1] = b + idx0;
    idx[i * 3 + 2] = c + idx0;
  }
  const startPole = 2 * sides;
  const destPole = startPole + 1;
  if (endcaps) {
    setV(startPole, start);
    setV(destPole, dest);
  }
  const pt1 = vec3_exports.create();
  const pt2 = vec3_exports.create();
  for (let i = 0; i < sides; i++) {
    const c = Math.cos(i / sides * 2 * Math.PI);
    const s = Math.sin(i / sides * 2 * Math.PI);
    pt1[0] = radius * (c * v2[0] + s * v3[0]);
    pt1[1] = radius * (c * v2[1] + s * v3[1]);
    pt1[2] = radius * (c * v2[2] + s * v3[2]);
    vec3_exports.add(pt2, start, pt1);
    setV(i, pt2);
    vec3_exports.add(pt2, dest, pt1);
    setV(i + sides, pt2);
    let nxt = 0;
    if (i < sides - 1) {
      nxt = i + 1;
    }
    setI(i * 2, i, nxt, i + sides);
    setI(i * 2 + 1, nxt, nxt + sides, i + sides);
    if (endcaps) {
      setI(sides * 2 + i, i, startPole, nxt);
      setI(sides * 2 + i + sides, destPole, i + sides, nxt + sides);
    }
  }
  indices.push(...idx);
  vertices.push(...vtx);
});
__publicField(_NiivueObject3D, "makeColoredCylinder", function(vertices, indices, colors, start, dest, radius, rgba255 = [192, 0, 0, 255], sides = 20, endcaps = false) {
  let nv = vertices.length / 3;
  _NiivueObject3D.makeCylinder(vertices, indices, start, dest, radius, sides, endcaps);
  nv = vertices.length / 3 - nv;
  const clrs = [];
  for (let i = 0; i < nv * 4 - 1; i += 4) {
    clrs[i] = rgba255[0];
    clrs[i + 1] = rgba255[1];
    clrs[i + 2] = rgba255[2];
    clrs[i + 3] = rgba255[3];
  }
  colors.push(...clrs);
});
__publicField(_NiivueObject3D, "makeColoredSphere", function(vertices, indices, colors, radius, origin = [0, 0, 0], rgba255 = [0, 0, 192, 255]) {
  let nv = vertices.length / 3;
  _NiivueObject3D.makeSphere(vertices, indices, radius, origin);
  nv = vertices.length / 3 - nv;
  const clrs = [];
  for (let i = 0; i < nv * 4 - 1; i += 4) {
    clrs[i] = rgba255[0];
    clrs[i + 1] = rgba255[1];
    clrs[i + 2] = rgba255[2];
    clrs[i + 3] = rgba255[3];
  }
  colors.push(...clrs);
});
var NiivueObject3D = _NiivueObject3D;

// ../../node_modules/@lukeed/uuid/dist/index.mjs
var IDX = 256;
var HEX = [];
var BUFFER;
while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);
function v4() {
  var i = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i = 256);
    while (i--) BUFFER[i] = 256 * Math.random() | 0;
    i = IDX = 0;
  }
  for (; i < 16; i++) {
    num = BUFFER[IDX + i];
    if (i == 6) out += HEX[num & 15 | 64];
    else if (i == 8) out += HEX[num & 63 | 128];
    else out += HEX[num];
    if (i & 1 && i > 1 && i < 11) out += "-";
  }
  IDX++;
  return out;
}

// src/cmaps/index.js
var cmaps_exports = {};
__export(cmaps_exports, {
  $itksnap: () => itksnap_default,
  $slicer3d: () => slicer3d_default,
  actc: () => actc_default,
  afni_blues_inv: () => afni_blues_inv_default,
  afni_reds_inv: () => afni_reds_inv_default,
  batlow: () => batlow_default,
  bcgwhw: () => bcgwhw_default,
  bcgwhw_dark: () => bcgwhw_dark_default,
  blue: () => blue_default,
  blue2cyan: () => blue2cyan_default,
  blue2magenta: () => blue2magenta_default,
  blue2red: () => blue2red_default,
  bluegrn: () => bluegrn_default,
  bone: () => bone_default,
  bronze: () => bronze_default,
  cet_l17: () => cet_l17_default,
  cividis: () => cividis_default,
  cool: () => cool_default,
  copper: () => copper_default,
  copper2: () => copper2_default,
  ct_airways: () => ct_airways_default,
  ct_artery: () => ct_artery_default,
  ct_bones: () => ct_bones_default,
  ct_brain: () => ct_brain_default,
  ct_brain_gray: () => ct_brain_gray_default,
  ct_cardiac: () => ct_cardiac_default,
  ct_head: () => ct_head_default,
  ct_kidneys: () => ct_kidneys_default,
  ct_liver: () => ct_liver_default,
  ct_muscles: () => ct_muscles_default,
  ct_scalp: () => ct_scalp_default,
  ct_skull: () => ct_skull_default,
  ct_soft: () => ct_soft_default,
  ct_soft_tissue: () => ct_soft_tissue_default,
  ct_surface: () => ct_surface_default,
  ct_vessels: () => ct_vessels_default,
  ct_w_contrast: () => ct_w_contrast_default,
  cubehelix: () => cubehelix_default,
  electric_blue: () => electric_blue_default,
  freesurfer: () => freesurfer_default,
  ge_color: () => ge_color_default,
  gold: () => gold_default,
  gray: () => gray_default,
  green: () => green_default,
  green2cyan: () => green2cyan_default,
  green2orange: () => green2orange_default,
  hot: () => hot_default,
  hotiron: () => hotiron_default,
  hsv: () => hsv_default,
  inferno: () => inferno_default,
  jet: () => jet_default,
  kry: () => kry_default,
  linspecer: () => linspecer_default,
  lipari: () => lipari_default,
  magma: () => magma_default,
  mako: () => mako_default,
  navia: () => navia_default,
  nih: () => nih_default,
  plasma: () => plasma_default,
  random: () => random_default,
  red: () => red_default,
  redyell: () => redyell_default,
  rocket: () => rocket_default,
  roi_i256: () => roi_i256_default,
  surface: () => surface_default,
  thermal: () => thermal_default,
  turbo: () => turbo_default,
  violet: () => violet_default,
  viridis: () => viridis_default,
  warm: () => warm_default,
  winter: () => winter_default,
  x_rain: () => x_rain_default
});

// src/cmaps/_itksnap.json
var itksnap_default = {
  R: [
    0,
    255,
    0,
    0,
    255,
    0,
    255,
    255,
    0,
    205,
    210,
    102,
    0,
    0,
    46,
    255,
    106,
    221,
    233,
    165,
    255,
    147,
    218,
    75,
    255,
    60,
    255,
    255,
    218,
    0,
    188,
    255,
    255,
    222,
    127,
    139,
    124,
    255,
    70,
    0,
    238,
    238,
    240,
    245,
    184,
    32,
    255,
    25,
    112,
    34,
    248,
    245,
    255,
    144,
    173,
    65,
    255,
    250,
    128,
    50,
    244,
    255,
    123,
    255,
    173,
    255,
    127,
    255,
    143,
    220,
    253,
    255,
    0,
    0,
    128,
    255,
    250,
    148,
    178,
    255,
    135,
    100,
    240,
    250,
    255,
    107,
    135,
    0,
    139,
    245,
    186,
    255,
    255,
    0,
    210,
    255,
    47,
    72,
    175,
    128,
    176,
    255,
    139,
    240,
    255,
    216,
    119,
    219,
    72,
    255,
    199,
    154,
    189,
    240,
    230,
    0,
    85,
    64,
    153,
    205,
    250,
    95,
    0,
    255,
    224,
    176,
    138,
    30,
    240,
    152,
    160
  ],
  G: [
    0,
    0,
    255,
    0,
    255,
    255,
    0,
    239,
    0,
    133,
    180,
    205,
    0,
    139,
    139,
    228,
    90,
    160,
    150,
    42,
    250,
    112,
    112,
    0,
    182,
    179,
    235,
    228,
    165,
    128,
    143,
    105,
    218,
    184,
    255,
    69,
    252,
    255,
    130,
    100,
    130,
    232,
    255,
    222,
    134,
    178,
    20,
    25,
    128,
    139,
    248,
    255,
    160,
    238,
    255,
    105,
    99,
    240,
    0,
    205,
    164,
    255,
    104,
    165,
    216,
    192,
    255,
    140,
    188,
    20,
    245,
    250,
    206,
    255,
    0,
    250,
    128,
    0,
    34,
    127,
    206,
    149,
    230,
    235,
    245,
    142,
    206,
    0,
    0,
    245,
    85,
    228,
    222,
    191,
    105,
    248,
    79,
    61,
    238,
    128,
    224,
    240,
    0,
    255,
    215,
    191,
    136,
    112,
    209,
    0,
    21,
    205,
    183,
    248,
    230,
    250,
    107,
    224,
    50,
    92,
    250,
    158,
    128,
    69,
    255,
    196,
    43,
    144,
    128,
    251,
    82
  ],
  B: [
    0,
    0,
    0,
    255,
    0,
    255,
    255,
    213,
    205,
    63,
    140,
    170,
    128,
    139,
    87,
    225,
    205,
    221,
    122,
    42,
    250,
    219,
    214,
    130,
    193,
    113,
    205,
    196,
    32,
    128,
    143,
    180,
    185,
    135,
    0,
    19,
    0,
    224,
    180,
    0,
    238,
    170,
    240,
    179,
    11,
    170,
    147,
    112,
    144,
    34,
    255,
    250,
    122,
    144,
    47,
    225,
    71,
    230,
    0,
    50,
    96,
    240,
    238,
    0,
    230,
    203,
    212,
    0,
    143,
    60,
    230,
    240,
    209,
    127,
    128,
    205,
    114,
    211,
    34,
    80,
    235,
    237,
    140,
    215,
    238,
    35,
    250,
    139,
    139,
    220,
    211,
    181,
    173,
    255,
    30,
    220,
    79,
    139,
    238,
    0,
    230,
    245,
    0,
    255,
    0,
    216,
    153,
    147,
    204,
    255,
    133,
    50,
    107,
    255,
    250,
    154,
    47,
    208,
    204,
    92,
    210,
    160,
    0,
    0,
    255,
    222,
    226,
    255,
    128,
    152,
    45
  ],
  A: [
    0,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130
  ]
};

// src/cmaps/_slicer3d.json
var slicer3d_default = {
  labels: [
    "background",
    "tissue",
    "bone",
    "skin",
    "connective tissue",
    "blood",
    "organ",
    "mass",
    "muscle",
    "foreign object",
    "waste",
    "teeth",
    "fat",
    "gray matter",
    "white matter",
    "nerve",
    "vein",
    "artery",
    "capillary",
    "ligament",
    "tendon",
    "cartilage",
    "meniscus",
    "lymph node",
    "lymphatic vessel",
    "cerebro-spinal fluid",
    "bile",
    "urine",
    "feces",
    "gas",
    "fluid",
    "edema",
    "bleeding",
    "necrosis",
    "clot",
    "embolism",
    "head",
    "central nervous system",
    "brain",
    "gray matter of brain",
    "telencephalon",
    "cerebral cortex",
    "right frontal lobe",
    "left frontal lobe",
    "right temporal lobe",
    "left temporal lobe",
    "right parietal lobe",
    "left parietal lobe",
    "right occipital lobe",
    "left occipital lobe",
    "right insular lobe",
    "left insular lobe",
    "right limbic lobe",
    "left limbic lobe",
    "right striatum",
    "left striatum",
    "right caudate nucleus",
    "left caudate nucleus",
    "right putamen",
    "left putamen",
    "right pallidum",
    "left pallidum",
    "right amygdaloid complex",
    "left amygdaloid complex",
    "diencephalon",
    "thalamus",
    "right thalamus",
    "left thalamus",
    "pineal gland",
    "midbrain",
    "substantia nigra",
    "right substantia nigra",
    "left substantia nigra",
    "cerebral white matter",
    "right superior longitudinal fasciculus",
    "left superior longitudinal fasciculus",
    "right inferior longitudinal fasciculus",
    "left inferior longitudinal fasciculus",
    "right arcuate fasciculus",
    "left arcuate fasciculus",
    "right uncinate fasciculus",
    "left uncinate fasciculus",
    "right cingulum bundle",
    "left cingulum bundle",
    "projection fibers",
    "right corticospinal tract",
    "left corticospinal tract",
    "right optic radiation",
    "left optic radiation",
    "right medial lemniscus",
    "left medial lemniscus",
    "right superior cerebellar peduncle",
    "left superior cerebellar peduncle",
    "right middle cerebellar peduncle",
    "left middle cerebellar peduncle",
    "right inferior cerebellar peduncle",
    "left inferior cerebellar peduncle",
    "optic chiasm",
    "right optic tract",
    "left optic tract",
    "right fornix",
    "left fornix",
    "commissural fibers",
    "corpus callosum",
    "posterior commissure",
    "cerebellar white matter",
    "CSF space",
    "ventricles of brain",
    "right lateral ventricle",
    "left lateral ventricle",
    "right third ventricle",
    "left third ventricle",
    "cerebral aqueduct",
    "fourth ventricle",
    "subarachnoid space",
    "spinal cord",
    "gray matter of spinal cord",
    "white matter of spinal cord",
    "endocrine system of brain",
    "pituitary gland",
    "adenohypophysis",
    "neurohypophysis",
    "meninges",
    "dura mater",
    "arachnoid",
    "pia mater",
    "muscles of head",
    "salivary glands",
    "lips",
    "nose",
    "tongue",
    "soft palate",
    "right inner ear",
    "left inner ear",
    "right external ear",
    "left external ear",
    "right middle ear",
    "left middle ear",
    "right eyeball",
    "left eyeball",
    "skull",
    "right frontal bone",
    "left frontal bone",
    "right parietal bone",
    "left parietal bone",
    "right temporal bone",
    "left temporal bone",
    "right sphenoid bone",
    "left sphenoid bone",
    "right ethmoid bone",
    "left ethmoid bone",
    "occipital bone",
    "maxilla",
    "right zygomatic bone",
    "right lacrimal bone",
    "vomer bone",
    "right palatine bone",
    "left palatine bone",
    "mandible",
    "neck",
    "muscles of neck",
    "pharynx",
    "larynx",
    "thyroid gland",
    "right parathyroid glands",
    "left parathyroid glands",
    "skeleton of neck",
    "hyoid bone",
    "cervical vertebral column",
    "thorax",
    "trachea",
    "bronchi",
    "right lung",
    "left lung",
    "superior lobe of right lung",
    "superior lobe of left lung",
    "middle lobe of right lung",
    "inferior lobe of right lung",
    "inferior lobe of left lung",
    "pleura",
    "heart",
    "right atrium",
    "left atrium",
    "atrial septum",
    "ventricular septum",
    "right ventricle of heart",
    "left ventricle of heart",
    "mitral valve",
    "tricuspid valve",
    "aortic valve",
    "pulmonary valve",
    "aorta",
    "pericardium",
    "pericardial cavity",
    "esophagus",
    "thymus",
    "mediastinum",
    "skin of thoracic wall",
    "muscles of thoracic wall",
    "skeleton of thorax",
    "thoracic vertebral column",
    "ribs",
    "sternum",
    "right clavicle",
    "left clavicle",
    "abdominal cavity",
    "abdomen",
    "peritoneum",
    "omentum",
    "peritoneal cavity",
    "retroperitoneal space",
    "stomach",
    "duodenum",
    "small bowel",
    "colon",
    "anus",
    "liver",
    "biliary tree",
    "gallbladder",
    "pancreas",
    "spleen",
    "urinary system",
    "right kidney",
    "left kidney",
    "right ureter",
    "left ureter",
    "urinary bladder",
    "urethra",
    "right adrenal gland",
    "left adrenal gland",
    "female internal genitalia",
    "uterus",
    "right fallopian tube",
    "left fallopian tube",
    "right ovary",
    "left ovary",
    "vagina",
    "male internal genitalia",
    "prostate",
    "right seminal vesicle",
    "left seminal vesicle",
    "right deferent duct",
    "left deferent duct",
    "skin of abdominal wall",
    "muscles of abdominal wall",
    "skeleton of abdomen",
    "lumbar vertebral column",
    "female external genitalia",
    "male external genitalia",
    "skeleton of upper limb",
    "muscles of upper limb",
    "right upper limb",
    "left upper limb",
    "right shoulder",
    "left shoulder",
    "right arm"
  ],
  R: [
    0,
    128,
    241,
    177,
    111,
    216,
    221,
    144,
    192,
    220,
    78,
    255,
    230,
    200,
    250,
    244,
    0,
    216,
    183,
    183,
    152,
    111,
    178,
    68,
    111,
    85,
    0,
    214,
    78,
    218,
    170,
    140,
    188,
    216,
    145,
    150,
    177,
    244,
    250,
    200,
    68,
    128,
    83,
    83,
    162,
    162,
    141,
    141,
    182,
    182,
    188,
    188,
    154,
    154,
    177,
    177,
    30,
    30,
    210,
    210,
    48,
    48,
    98,
    98,
    69,
    166,
    122,
    122,
    253,
    145,
    46,
    0,
    0,
    250,
    127,
    127,
    159,
    159,
    125,
    125,
    106,
    106,
    154,
    154,
    126,
    201,
    201,
    78,
    78,
    174,
    174,
    139,
    139,
    148,
    148,
    186,
    186,
    99,
    156,
    156,
    64,
    64,
    138,
    97,
    126,
    194,
    85,
    88,
    88,
    88,
    88,
    88,
    88,
    88,
    88,
    244,
    200,
    250,
    82,
    57,
    60,
    92,
    255,
    255,
    255,
    255,
    201,
    70,
    188,
    177,
    166,
    182,
    229,
    229,
    174,
    174,
    201,
    201,
    194,
    194,
    241,
    203,
    203,
    229,
    229,
    255,
    255,
    209,
    209,
    248,
    248,
    255,
    196,
    255,
    255,
    255,
    242,
    242,
    222,
    177,
    213,
    184,
    150,
    62,
    62,
    62,
    242,
    250,
    255,
    177,
    182,
    175,
    197,
    197,
    172,
    172,
    202,
    224,
    224,
    255,
    206,
    210,
    203,
    233,
    195,
    181,
    152,
    159,
    166,
    218,
    225,
    224,
    255,
    184,
    211,
    47,
    255,
    173,
    188,
    255,
    226,
    253,
    244,
    205,
    205,
    186,
    177,
    255,
    234,
    204,
    180,
    216,
    255,
    205,
    204,
    255,
    221,
    0,
    139,
    249,
    157,
    203,
    185,
    185,
    247,
    247,
    222,
    124,
    249,
    249,
    244,
    255,
    255,
    227,
    213,
    213,
    193,
    216,
    230,
    245,
    245,
    241,
    241,
    177,
    171,
    217,
    212,
    185,
    185,
    198,
    194,
    177,
    177,
    177,
    177,
    177
  ],
  G: [
    0,
    174,
    214,
    122,
    184,
    101,
    130,
    238,
    104,
    245,
    63,
    250,
    220,
    200,
    250,
    214,
    151,
    101,
    156,
    214,
    189,
    184,
    212,
    172,
    197,
    188,
    145,
    230,
    63,
    255,
    250,
    224,
    65,
    191,
    60,
    98,
    122,
    214,
    250,
    200,
    131,
    174,
    146,
    146,
    115,
    115,
    93,
    93,
    166,
    166,
    135,
    135,
    150,
    150,
    140,
    140,
    111,
    111,
    157,
    157,
    129,
    129,
    153,
    153,
    110,
    113,
    101,
    101,
    135,
    92,
    101,
    108,
    108,
    250,
    150,
    150,
    116,
    116,
    102,
    102,
    174,
    174,
    146,
    146,
    126,
    160,
    160,
    152,
    152,
    140,
    140,
    126,
    126,
    120,
    120,
    135,
    135,
    106,
    171,
    171,
    123,
    123,
    95,
    113,
    161,
    195,
    188,
    106,
    106,
    106,
    106,
    106,
    106,
    106,
    106,
    214,
    200,
    250,
    174,
    157,
    143,
    162,
    244,
    244,
    244,
    244,
    121,
    163,
    91,
    122,
    84,
    105,
    147,
    147,
    122,
    122,
    112,
    112,
    142,
    142,
    213,
    179,
    179,
    204,
    204,
    243,
    243,
    185,
    185,
    223,
    223,
    230,
    172,
    255,
    250,
    237,
    217,
    217,
    198,
    122,
    124,
    105,
    208,
    162,
    162,
    162,
    206,
    210,
    255,
    122,
    228,
    216,
    165,
    165,
    138,
    138,
    164,
    186,
    186,
    245,
    110,
    115,
    108,
    138,
    100,
    85,
    55,
    63,
    70,
    123,
    130,
    97,
    244,
    122,
    171,
    150,
    244,
    121,
    95,
    239,
    202,
    232,
    217,
    179,
    179,
    124,
    122,
    255,
    234,
    142,
    119,
    132,
    253,
    167,
    168,
    224,
    130,
    145,
    150,
    180,
    108,
    136,
    102,
    102,
    182,
    182,
    154,
    186,
    186,
    186,
    170,
    181,
    190,
    153,
    141,
    141,
    123,
    146,
    158,
    172,
    172,
    172,
    172,
    124,
    85,
    198,
    188,
    135,
    135,
    175,
    98,
    122,
    122,
    122,
    122,
    122
  ],
  B: [
    0,
    128,
    145,
    101,
    210,
    79,
    101,
    144,
    88,
    20,
    0,
    220,
    70,
    235,
    210,
    49,
    206,
    79,
    220,
    211,
    207,
    210,
    242,
    100,
    131,
    255,
    30,
    130,
    0,
    255,
    250,
    228,
    28,
    216,
    66,
    83,
    101,
    49,
    225,
    215,
    98,
    128,
    164,
    164,
    105,
    105,
    137,
    137,
    110,
    110,
    166,
    166,
    201,
    201,
    190,
    190,
    85,
    85,
    166,
    166,
    126,
    126,
    112,
    112,
    53,
    137,
    38,
    38,
    192,
    109,
    131,
    112,
    112,
    225,
    88,
    88,
    163,
    163,
    154,
    154,
    155,
    155,
    83,
    83,
    55,
    133,
    133,
    141,
    141,
    103,
    103,
    177,
    177,
    72,
    72,
    135,
    135,
    24,
    108,
    108,
    147,
    147,
    74,
    158,
    197,
    164,
    255,
    215,
    215,
    215,
    215,
    215,
    215,
    215,
    215,
    49,
    215,
    225,
    128,
    110,
    83,
    109,
    209,
    209,
    209,
    209,
    77,
    117,
    95,
    101,
    94,
    107,
    118,
    118,
    90,
    90,
    73,
    73,
    0,
    0,
    144,
    77,
    77,
    109,
    109,
    152,
    152,
    85,
    85,
    131,
    131,
    138,
    68,
    167,
    160,
    145,
    123,
    123,
    101,
    101,
    109,
    108,
    243,
    114,
    114,
    114,
    142,
    139,
    207,
    101,
    255,
    244,
    145,
    145,
    115,
    115,
    140,
    162,
    162,
    217,
    84,
    89,
    81,
    112,
    73,
    57,
    13,
    27,
    38,
    97,
    104,
    76,
    209,
    154,
    143,
    103,
    209,
    88,
    76,
    172,
    134,
    158,
    154,
    108,
    108,
    161,
    101,
    220,
    194,
    178,
    153,
    105,
    229,
    142,
    143,
    199,
    101,
    30,
    98,
    111,
    162,
    116,
    83,
    83,
    164,
    164,
    132,
    223,
    150,
    150,
    147,
    158,
    165,
    130,
    113,
    113,
    103,
    127,
    140,
    147,
    147,
    151,
    151,
    92,
    68,
    131,
    102,
    134,
    134,
    125,
    79,
    101,
    101,
    101,
    101,
    101
  ],
  A: [
    0,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
};

// src/cmaps/actc.json
var actc_default = {
  R: [0, 0, 24, 248, 255],
  G: [0, 0, 177, 254, 0],
  B: [0, 136, 0, 0, 0],
  A: [0, 32, 64, 78, 128],
  I: [0, 64, 128, 156, 255]
};

// src/cmaps/batlow.json
var batlow_default = {
  R: [1, 10, 15, 17, 21, 27, 36, 49, 65, 82, 99, 118, 140, 161, 183, 203, 222, 238, 248, 253, 253, 253, 252, 250],
  G: [25, 42, 56, 68, 79, 88, 97, 105, 111, 116, 122, 127, 133, 138, 142, 146, 150, 155, 162, 170, 178, 186, 195, 204],
  B: [89, 92, 95, 96, 98, 98, 96, 91, 83, 74, 64, 55, 46, 43, 49, 62, 79, 100, 126, 151, 175, 199, 223, 250],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
};

// src/cmaps/bcgwhw_dark.json
var bcgwhw_dark_default = {
  R: [
    0,
    248,
    242,
    235,
    229,
    222,
    212,
    202,
    193,
    183,
    173,
    145,
    117,
    78,
    39,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    128,
    191,
    255,
    255,
    255,
    255,
    255,
    238,
    221,
    204,
    214,
    224,
    235,
    245,
    255,
    249,
    242,
    236,
    229,
    223,
    217,
    210,
    204,
    197,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  G: [
    0,
    251,
    247,
    243,
    239,
    235,
    235,
    235,
    235,
    235,
    235,
    216,
    197,
    174,
    150,
    127,
    153,
    178,
    204,
    229,
    255,
    255,
    255,
    255,
    255,
    220,
    185,
    150,
    115,
    77,
    38,
    0,
    31,
    61,
    92,
    122,
    153,
    138,
    122,
    107,
    92,
    77,
    61,
    46,
    31,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    0,
    254,
    253,
    252,
    251,
    250,
    251,
    252,
    253,
    254,
    255,
    226,
    198,
    132,
    66,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40,
    80,
    120,
    160,
    200,
    199,
    198,
    197,
    196,
    196,
    195,
    194,
    193,
    192,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  A: [
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256
  ],
  I: [
    0,
    4,
    8,
    12,
    16,
    20,
    24,
    28,
    32,
    36,
    40,
    44,
    48,
    52,
    56,
    60,
    64,
    68,
    72,
    76,
    80,
    84,
    88,
    92,
    96,
    100,
    104,
    108,
    112,
    116,
    120,
    124,
    128,
    132,
    136,
    140,
    144,
    148,
    152,
    156,
    160,
    164,
    168,
    172,
    176,
    180,
    184,
    188,
    192,
    196,
    200,
    204,
    208,
    212,
    216,
    220,
    224,
    228,
    232,
    236,
    240,
    244,
    248,
    255
  ]
};

// src/cmaps/bcgwhw.json
var bcgwhw_default = {
  R: [
    255,
    248,
    242,
    235,
    229,
    222,
    212,
    202,
    193,
    183,
    173,
    145,
    117,
    78,
    39,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    128,
    191,
    255,
    255,
    255,
    255,
    255,
    238,
    221,
    204,
    214,
    224,
    235,
    245,
    255,
    249,
    242,
    236,
    229,
    223,
    217,
    210,
    204,
    197,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  G: [
    255,
    251,
    247,
    243,
    239,
    235,
    235,
    235,
    235,
    235,
    235,
    216,
    197,
    174,
    150,
    127,
    153,
    178,
    204,
    229,
    255,
    255,
    255,
    255,
    255,
    220,
    185,
    150,
    115,
    77,
    38,
    0,
    31,
    61,
    92,
    122,
    153,
    138,
    122,
    107,
    92,
    77,
    61,
    46,
    31,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    255,
    254,
    253,
    252,
    251,
    250,
    251,
    252,
    253,
    254,
    255,
    226,
    198,
    132,
    66,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40,
    80,
    120,
    160,
    200,
    199,
    198,
    197,
    196,
    196,
    195,
    194,
    193,
    192,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  A: [
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256
  ],
  I: [
    0,
    4,
    8,
    12,
    16,
    20,
    24,
    28,
    32,
    36,
    40,
    44,
    48,
    52,
    56,
    60,
    64,
    68,
    72,
    76,
    80,
    84,
    88,
    92,
    96,
    100,
    104,
    108,
    112,
    116,
    120,
    124,
    128,
    132,
    136,
    140,
    144,
    148,
    152,
    156,
    160,
    164,
    168,
    172,
    176,
    180,
    184,
    188,
    192,
    196,
    200,
    204,
    208,
    212,
    216,
    220,
    224,
    228,
    232,
    236,
    240,
    244,
    248,
    255
  ]
};

// src/cmaps/blue2red.json
var blue2red_default = {
  R: [0, 0, 0, 0, 196, 255],
  G: [0, 32, 128, 128, 128, 32],
  B: [0, 255, 196, 0, 0, 0],
  A: [0, 128, 64, 64, 64, 128],
  I: [0, 1, 64, 128, 192, 255]
};

// src/cmaps/blue2magenta.json
var blue2magenta_default = {
  R: [0, 255],
  G: [0, 0],
  B: [255, 255],
  A: [0, 128],
  I: [0, 255]
};

// src/cmaps/blue2cyan.json
var blue2cyan_default = {
  R: [0, 0],
  G: [0, 255],
  B: [255, 255],
  A: [0, 128],
  I: [0, 255]
};

// src/cmaps/bluegrn.json
var bluegrn_default = {
  R: [0, 0, 0, 0],
  G: [0, 1, 128, 255],
  B: [0, 222, 127, 32],
  A: [0, 0, 64, 128],
  I: [0, 1, 128, 255]
};

// src/cmaps/blue.json
var blue_default = {
  R: [0, 0, 0],
  G: [0, 0, 0],
  B: [0, 128, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/bone.json
var bone_default = {
  R: [0, 103, 255],
  G: [0, 126, 255],
  B: [0, 165, 255],
  A: [0, 76, 128],
  I: [0, 153, 255]
};

// src/cmaps/bronze.json
var bronze_default = {
  R: [0, 43, 103, 199, 216, 255],
  G: [0, 0, 37, 155, 213, 255],
  B: [0, 0, 20, 97, 201, 255],
  A: [0, 44, 48, 54, 56, 56],
  I: [0, 64, 128, 196, 240, 255]
};

// src/cmaps/cet_l17.json
var cet_l17_default = {
  R: [
    0,
    9,
    24,
    33,
    40,
    46,
    52,
    57,
    62,
    66,
    70,
    74,
    78,
    81,
    85,
    88,
    91,
    94,
    98,
    101,
    103,
    106,
    109,
    112,
    114,
    117,
    119,
    121,
    124,
    126,
    128,
    130,
    133,
    135,
    137,
    139,
    141,
    143,
    145,
    147,
    149,
    151,
    153,
    155,
    157,
    159,
    161,
    163,
    164,
    166,
    168,
    169,
    171,
    172,
    174,
    175,
    177,
    178,
    180,
    181,
    183,
    184,
    186,
    187,
    189,
    190,
    191,
    193,
    194,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    222,
    223,
    224,
    224,
    225,
    226,
    226,
    227,
    228,
    228,
    229,
    229,
    230,
    231,
    231,
    232,
    233,
    233,
    234,
    234,
    235,
    235,
    236,
    236,
    236,
    237,
    237,
    237,
    238,
    238,
    238,
    239,
    239,
    239,
    240,
    240,
    240,
    241,
    241,
    241,
    242,
    242,
    242,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    241,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    243,
    243,
    244,
    244,
    245,
    246,
    246,
    247,
    247,
    248,
    249,
    249,
    250,
    250,
    251,
    251,
    252,
    252,
    253,
    253,
    254,
    254,
    254
  ],
  G: [
    42,
    41,
    41,
    41,
    40,
    40,
    40,
    39,
    39,
    39,
    38,
    38,
    37,
    37,
    36,
    36,
    35,
    35,
    34,
    34,
    33,
    32,
    32,
    31,
    30,
    30,
    30,
    30,
    29,
    29,
    29,
    29,
    28,
    28,
    28,
    27,
    27,
    27,
    26,
    26,
    26,
    25,
    25,
    25,
    24,
    24,
    24,
    24,
    24,
    25,
    25,
    26,
    27,
    27,
    28,
    28,
    29,
    30,
    30,
    31,
    31,
    32,
    33,
    33,
    34,
    34,
    35,
    36,
    36,
    37,
    38,
    39,
    40,
    42,
    43,
    44,
    45,
    47,
    48,
    49,
    50,
    51,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    62,
    63,
    64,
    65,
    66,
    68,
    69,
    71,
    72,
    73,
    75,
    76,
    77,
    79,
    80,
    81,
    83,
    84,
    85,
    87,
    88,
    89,
    90,
    92,
    93,
    94,
    95,
    97,
    98,
    100,
    101,
    102,
    104,
    105,
    107,
    108,
    109,
    111,
    112,
    113,
    115,
    116,
    117,
    119,
    120,
    121,
    122,
    124,
    125,
    126,
    128,
    129,
    130,
    132,
    133,
    134,
    136,
    137,
    138,
    140,
    141,
    142,
    144,
    145,
    146,
    147,
    149,
    150,
    151,
    153,
    154,
    155,
    156,
    158,
    159,
    160,
    161,
    163,
    164,
    165,
    167,
    168,
    169,
    170,
    172,
    173,
    174,
    175,
    176,
    178,
    179,
    180,
    181,
    183,
    184,
    185,
    186,
    187,
    189,
    190,
    191,
    192,
    193,
    194,
    196,
    197,
    198,
    199,
    200,
    201,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    238,
    239,
    240,
    241,
    241,
    242,
    243,
    244,
    244,
    245,
    246,
    247,
    248,
    248,
    249,
    250,
    251,
    251,
    252,
    253,
    254,
    255
  ],
  B: [
    167,
    167,
    166,
    166,
    166,
    165,
    165,
    165,
    164,
    164,
    164,
    163,
    163,
    162,
    162,
    162,
    161,
    161,
    161,
    160,
    160,
    160,
    159,
    159,
    158,
    158,
    157,
    157,
    156,
    155,
    155,
    154,
    154,
    153,
    153,
    152,
    151,
    151,
    150,
    150,
    149,
    149,
    148,
    147,
    147,
    146,
    146,
    145,
    144,
    144,
    143,
    143,
    142,
    141,
    141,
    140,
    139,
    139,
    138,
    137,
    137,
    136,
    135,
    135,
    134,
    133,
    133,
    132,
    131,
    131,
    130,
    130,
    129,
    128,
    128,
    127,
    127,
    126,
    125,
    125,
    124,
    124,
    123,
    123,
    122,
    121,
    121,
    120,
    119,
    119,
    118,
    118,
    117,
    116,
    116,
    116,
    115,
    115,
    114,
    114,
    113,
    113,
    113,
    112,
    112,
    111,
    111,
    110,
    110,
    109,
    109,
    109,
    108,
    108,
    107,
    107,
    106,
    106,
    106,
    106,
    106,
    105,
    105,
    105,
    105,
    105,
    105,
    105,
    104,
    104,
    104,
    104,
    104,
    103,
    103,
    103,
    103,
    103,
    102,
    102,
    102,
    103,
    103,
    103,
    103,
    104,
    104,
    104,
    104,
    104,
    105,
    105,
    105,
    105,
    106,
    106,
    106,
    106,
    106,
    107,
    107,
    107,
    107,
    108,
    108,
    109,
    110,
    111,
    111,
    112,
    113,
    113,
    114,
    115,
    115,
    116,
    117,
    117,
    118,
    119,
    120,
    120,
    121,
    122,
    122,
    123,
    124,
    125,
    126,
    128,
    129,
    130,
    131,
    132,
    134,
    135,
    136,
    137,
    138,
    140,
    141,
    142,
    143,
    144,
    146,
    147,
    148,
    149,
    150,
    152,
    153,
    155,
    157,
    158,
    160,
    162,
    163,
    165,
    167,
    168,
    170,
    172,
    173,
    175,
    177,
    178,
    180,
    182,
    183,
    185,
    187,
    188,
    190,
    193,
    196,
    199,
    201,
    204,
    207,
    210,
    212,
    215,
    218,
    221,
    224,
    226,
    229,
    232,
    235,
    238,
    240,
    243,
    246,
    249,
    252,
    255
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
};

// src/cmaps/cividis.json
var cividis_default = {
  R: [0, 86, 166, 255],
  G: [32, 92, 156, 233],
  B: [76, 108, 117, 69],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
};

// src/cmaps/cool.json
var cool_default = {
  R: [0, 0, 0],
  G: [127, 196, 254],
  B: [255, 255, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/copper2.json
var copper2_default = {
  R: [0, 61, 122, 183, 244, 255],
  G: [0, 41, 81, 122, 163, 255],
  B: [0, 25, 51, 76, 102, 255],
  A: [0, 25, 51, 71, 102, 128],
  I: [0, 51, 102, 153, 204, 255]
};

// src/cmaps/copper.json
var copper_default = {
  R: [0, 61, 122, 183, 244, 255],
  G: [0, 41, 81, 122, 163, 203],
  B: [0, 25, 51, 76, 102, 127],
  A: [0, 25, 51, 71, 102, 128],
  I: [0, 51, 102, 153, 204, 255]
};

// src/cmaps/ct_airways.json
var ct_airways_default = {
  min: -643,
  max: -235,
  R: [0, 0, 0],
  G: [154, 154, 154],
  B: [179, 179, 101],
  A: [0, 32, 0],
  I: [0, 163, 255]
};

// src/cmaps/ct_artery.json
var ct_artery_default = {
  min: 114,
  max: 800,
  R: [0, 255, 255, 255],
  G: [0, 0, 129, 255],
  B: [0, 0, 0, 255],
  A: [0, 64, 88, 228],
  I: [0, 80, 160, 255]
};

// src/cmaps/ct_bones.json
var ct_bones_default = {
  min: 180,
  max: 600,
  R: [0, 0, 113, 255],
  G: [0, 0, 109, 250],
  B: [0, 0, 101, 245],
  A: [0, 0, 100, 160],
  I: [0, 1, 128, 255]
};

// src/cmaps/ct_brain_gray.json
var ct_brain_gray_default = {
  min: -10,
  max: 110,
  R: [0, 127, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
};

// src/cmaps/ct_brain.json
var ct_brain_default = {
  min: -10,
  max: 110,
  R: [0, 199, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
};

// src/cmaps/ct_cardiac.json
var ct_cardiac_default = {
  min: -80,
  max: 1e3,
  R: [0, 189, 150, 150, 150, 150, 255],
  G: [0, 169, 54, 54, 54, 54, 240],
  B: [0, 153, 52, 52, 52, 52, 242],
  A: [0, 32, 64, 0, 0, 64, 64],
  I: [0, 1, 82, 92, 234, 242, 255]
};

// src/cmaps/ct_head.json
var ct_head_default = {
  min: -590,
  max: 600,
  R: [0, 241, 241, 248, 248, 178, 178, 232, 255, 255, 255],
  G: [0, 156, 156, 222, 222, 36, 36, 51, 255, 255, 255],
  B: [0, 130, 130, 169, 169, 24, 24, 37, 255, 255, 255],
  A: [0, 8, 0, 0, 0, 64, 64, 0, 0, 222, 222],
  I: [0, 2, 3, 64, 122, 142, 172, 182, 252, 253, 255]
};

// src/cmaps/ct_kidneys.json
var ct_kidneys_default = {
  min: 114,
  max: 302,
  R: [0, 255, 255],
  G: [0, 129, 255],
  B: [0, 0, 255],
  A: [0, 88, 228],
  I: [0, 103, 255]
};

// src/cmaps/ct_liver.json
var ct_liver_default = {
  min: -23,
  max: 246,
  R: [0, 44, 255, 255, 255],
  G: [0, 128, 90, 255, 255],
  B: [0, 0, 70, 0, 255],
  A: [0, 0, 82, 184, 228],
  I: [0, 64, 131, 196, 255]
};

// src/cmaps/ct_muscles.json
var ct_muscles_default = {
  min: -100,
  max: 246,
  R: [0, 128, 159, 255, 255, 255, 255],
  G: [0, 0, 56, 90, 0, 255, 255],
  B: [0, 0, 41, 70, 0, 0, 255],
  A: [0, 63, 105, 135, 167, 184, 228],
  I: [0, 100, 128, 155, 180, 209, 255]
};

// src/cmaps/ct_scalp.json
var ct_scalp_default = {
  min: -590,
  max: 600,
  R: [0, 241, 241, 248, 248, 178, 232, 255, 255],
  G: [0, 156, 156, 222, 222, 36, 51, 255, 255],
  B: [0, 130, 130, 169, 169, 24, 37, 255, 255],
  A: [0, 63, 105, 135, 167, 184, 228, 228, 228],
  I: [0, 1, 52, 127, 137, 162, 172, 252, 255]
};

// src/cmaps/ct_skull.json
var ct_skull_default = {
  min: 140,
  max: 1024,
  R: [0, 2, 113, 255],
  G: [0, 1, 109, 250],
  B: [0, 1, 101, 245],
  A: [0, 1, 96, 168],
  I: [0, 1, 128, 255]
};

// src/cmaps/ct_soft.json
var ct_soft_default = {
  min: -923,
  max: 679,
  R: [0, 0, 0, 0, 0, 255, 255, 255],
  G: [154, 154, 154, 154, 0, 0, 254, 255],
  B: [179, 179, 179, 179, 0, 0, 0, 255],
  A: [0, 3, 8, 0, 0, 10, 15, 20],
  I: [0, 30, 62, 88, 170, 200, 232, 255]
};

// src/cmaps/ct_soft_tissue.json
var ct_soft_tissue_default = {
  min: -10,
  max: 110,
  R: [0, 199, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
};

// src/cmaps/ct_surface.json
var ct_surface_default = {
  min: -600,
  max: 100,
  R: [0, 134, 255],
  G: [0, 109, 250],
  B: [0, 101, 245],
  A: [0, 60, 148],
  I: [0, 128, 255]
};

// src/cmaps/ct_vessels.json
var ct_vessels_default = {
  min: 114,
  max: 246,
  R: [0, 255, 255],
  G: [0, 128, 255],
  B: [0, 128, 255],
  A: [0, 64, 96],
  I: [0, 87, 255]
};

// src/cmaps/ct_w_contrast.json
var ct_w_contrast_default = {
  min: 50,
  max: 1e3,
  R: [98, 210, 169, 128, 255],
  G: [94, 26, 77, 128, 255],
  B: [45, 21, 74, 128, 255],
  A: [0, 25, 0, 4, 168],
  I: [0, 41, 87, 154, 255]
};

// src/cmaps/cubehelix.json
var cubehelix_default = {
  R: [
    0,
    13,
    21,
    26,
    27,
    25,
    22,
    21,
    22,
    28,
    39,
    54,
    75,
    98,
    124,
    148,
    171,
    189,
    202,
    210,
    213,
    211,
    206,
    200,
    195,
    193,
    195,
    201,
    211,
    225,
    240,
    255
  ],
  G: [
    0,
    5,
    11,
    20,
    31,
    44,
    58,
    72,
    86,
    99,
    109,
    116,
    120,
    122,
    122,
    122,
    121,
    121,
    124,
    129,
    137,
    147,
    161,
    175,
    190,
    205,
    218,
    229,
    238,
    245,
    251,
    255
  ],
  B: [
    0,
    14,
    30,
    46,
    61,
    71,
    77,
    78,
    75,
    68,
    60,
    52,
    48,
    47,
    53,
    65,
    83,
    105,
    131,
    157,
    183,
    205,
    222,
    235,
    241,
    243,
    242,
    240,
    239,
    240,
    245,
    255
  ],
  A: [
    0,
    4,
    8,
    12,
    17,
    21,
    25,
    29,
    33,
    37,
    41,
    45,
    50,
    54,
    58,
    62,
    66,
    70,
    74,
    78,
    83,
    87,
    91,
    95,
    99,
    103,
    107,
    111,
    116,
    120,
    124,
    128
  ],
  I: [
    0,
    8,
    16,
    25,
    33,
    41,
    49,
    58,
    66,
    74,
    82,
    90,
    99,
    107,
    115,
    123,
    132,
    140,
    148,
    156,
    165,
    173,
    181,
    189,
    197,
    206,
    214,
    222,
    230,
    239,
    247,
    255
  ]
};

// src/cmaps/electric_blue.json
var electric_blue_default = {
  R: [0, 10, 136, 255],
  G: [0, 39, 220, 255],
  B: [0, 223, 253, 255],
  A: [0, 48, 64, 70],
  I: [0, 92, 192, 255]
};

// src/cmaps/freesurfer.json
var freesurfer_default = {
  R: [
    0,
    245,
    205,
    120,
    196,
    220,
    230,
    0,
    122,
    236,
    12,
    204,
    42,
    119,
    220,
    103,
    60,
    255,
    165,
    160,
    0,
    245,
    205,
    120,
    196,
    220,
    230,
    0,
    122,
    236,
    13,
    220,
    103,
    255,
    165,
    160,
    0,
    120,
    200,
    255,
    255,
    164,
    164,
    164,
    234,
    0,
    0,
    0,
    0,
    0
  ],
  G: [
    0,
    245,
    62,
    18,
    58,
    248,
    148,
    118,
    186,
    13,
    48,
    182,
    204,
    159,
    216,
    255,
    60,
    165,
    42,
    32,
    200,
    245,
    62,
    18,
    58,
    248,
    148,
    118,
    186,
    13,
    48,
    216,
    255,
    165,
    42,
    32,
    200,
    190,
    70,
    148,
    148,
    108,
    108,
    108,
    169,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    0,
    245,
    78,
    134,
    250,
    164,
    34,
    14,
    220,
    176,
    255,
    142,
    164,
    176,
    20,
    255,
    60,
    0,
    42,
    240,
    200,
    245,
    78,
    134,
    250,
    164,
    34,
    14,
    220,
    176,
    255,
    20,
    255,
    0,
    42,
    240,
    221,
    150,
    255,
    10,
    10,
    226,
    226,
    226,
    30,
    64,
    112,
    160,
    208,
    255
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    2,
    3,
    4,
    5,
    7,
    8,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    24,
    26,
    28,
    30,
    31,
    41,
    42,
    43,
    44,
    46,
    47,
    49,
    50,
    51,
    52,
    53,
    54,
    58,
    60,
    62,
    63,
    72,
    77,
    78,
    79,
    80,
    81,
    82,
    85,
    251,
    252,
    253,
    254,
    255
  ]
};

// src/cmaps/ge_color.json
var ge_color_default = {
  R: [0, 0, 128, 255, 255],
  G: [0, 128, 0, 128, 255],
  B: [0, 125, 255, 0, 255],
  A: [0, 32, 64, 96, 128],
  I: [0, 63, 128, 192, 255]
};

// src/cmaps/gold.json
var gold_default = {
  R: [0, 142, 227, 255],
  G: [0, 85, 170, 255],
  B: [0, 14, 76, 255],
  A: [0, 42, 84, 128],
  I: [0, 85, 170, 255]
};

// src/cmaps/gray.json
var gray_default = {
  R: [0, 255],
  G: [0, 255],
  B: [0, 255],
  A: [0, 128],
  I: [0, 255]
};

// src/cmaps/green.json
var green_default = {
  R: [0, 0, 0],
  G: [0, 128, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/green2cyan.json
var green2cyan_default = {
  R: [0, 0, 0],
  G: [72, 72, 255],
  B: [0, 255, 255],
  A: [0, 64, 128],
  I: [0, 88, 255]
};

// src/cmaps/green2orange.json
var green2orange_default = {
  R: [0, 255, 255],
  G: [72, 88, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 88, 255]
};

// src/cmaps/hotiron.json
var hotiron_default = {
  R: [0, 255, 255, 255],
  G: [0, 0, 126, 255],
  B: [0, 0, 0, 255],
  A: [0, 64, 96, 128],
  I: [0, 128, 191, 255]
};

// src/cmaps/hot.json
var hot_default = {
  R: [3, 255, 255, 255],
  G: [0, 0, 255, 255],
  B: [0, 0, 0, 255],
  A: [0, 48, 96, 128],
  I: [0, 95, 191, 255]
};

// src/cmaps/hsv.json
var hsv_default = {
  R: [255, 255, 0, 0, 0, 255, 255],
  G: [0, 255, 255, 255, 0, 0, 0],
  B: [0, 0, 0, 255, 255, 255, 0],
  A: [0, 14, 28, 43, 57, 71, 85],
  I: [0, 43, 85, 128, 170, 213, 255]
};

// src/cmaps/inferno.json
var inferno_default = {
  R: [0, 120, 237, 240],
  G: [0, 28, 105, 249],
  B: [4, 109, 37, 33],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
};

// src/cmaps/jet.json
var jet_default = {
  R: [0, 0, 127, 255, 127],
  G: [0, 127, 255, 127, 0],
  B: [127, 255, 127, 0, 0],
  A: [0, 32, 64, 96, 128],
  I: [0, 63, 128, 192, 255]
};

// src/cmaps/kry.json
var kry_default = {
  R: [0, 255, 255],
  G: [0, 0, 255],
  B: [0, 0, 0],
  A: [0, 64, 64],
  I: [0, 86, 255]
};

// src/cmaps/linspecer.json
var linspecer_default = {
  R: [94, 50, 90, 152, 215, 238, 249, 254, 252, 241, 209, 158],
  G: [79, 131, 186, 214, 240, 244, 237, 210, 157, 100, 57, 1],
  B: [162, 189, 167, 164, 155, 169, 168, 123, 86, 68, 79, 66],
  A: [0, 12, 23, 35, 47, 58, 70, 81, 93, 105, 116, 128],
  I: [0, 23, 46, 70, 93, 116, 139, 162, 185, 209, 232, 255]
};

// src/cmaps/lipari.json
var lipari_default = {
  R: [3, 7, 13, 25, 45, 67, 84, 98, 110, 124, 138, 154, 173, 191, 210, 225, 233, 233, 231, 229, 230, 235, 243, 253],
  G: [19, 33, 48, 63, 77, 87, 92, 94, 95, 96, 96, 97, 99, 101, 106, 118, 133, 149, 163, 177, 192, 208, 225, 245],
  B: [38, 58, 79, 99, 114, 122, 122, 120, 117, 113, 110, 105, 101, 97, 94, 96, 103, 112, 122, 134, 149, 169, 192, 218],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
};

// src/cmaps/magma.json
var magma_default = {
  R: [0, 148, 183, 223, 247, 252],
  G: [0, 44, 55, 74, 112, 253],
  B: [4, 128, 121, 104, 92, 191],
  A: [0, 44, 53, 64, 75, 107],
  I: [0, 107, 128, 154, 179, 255]
};

// src/cmaps/mako.json
var mako_default = {
  R: [11, 59, 55, 222],
  G: [4, 45, 165, 245],
  B: [5, 91, 172, 229],
  A: [0, 23, 70, 107],
  I: [0, 56, 167, 255]
};

// src/cmaps/navia.json
var navia_default = {
  R: [3, 5, 6, 8, 12, 19, 28, 36, 42, 48, 54, 61, 68, 76, 86, 96, 110, 129, 154, 181, 205, 224, 239, 252],
  G: [19, 32, 44, 58, 72, 86, 98, 108, 116, 122, 128, 134, 141, 149, 157, 167, 178, 191, 204, 216, 225, 232, 239, 244],
  B: [39, 60, 82, 104, 123, 137, 144, 145, 142, 138, 134, 130, 126, 121, 116, 110, 105, 104, 112, 131, 155, 178, 198, 217],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
};

// src/cmaps/nih.json
var nih_default = {
  R: [0, 85, 0, 0, 0, 0, 0, 0, 85, 255, 255, 255, 172],
  G: [0, 0, 0, 0, 85, 170, 255, 255, 255, 255, 85, 0, 0],
  B: [0, 170, 85, 255, 255, 170, 170, 0, 85, 0, 0, 0, 0],
  A: [0, 5, 10, 21, 26, 32, 37, 42, 48, 53, 64, 72, 85],
  I: [0, 15, 31, 63, 79, 95, 111, 127, 143, 159, 191, 217, 255]
};

// src/cmaps/plasma.json
var plasma_default = {
  R: [13, 156, 237, 240],
  G: [8, 23, 121, 249],
  B: [135, 158, 83, 33],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
};

// src/cmaps/random.json
var random_default = {
  R: [
    208,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248,
    161,
    189,
    41,
    114,
    65,
    121,
    97,
    50,
    238,
    149,
    44,
    214,
    124,
    167,
    40,
    167,
    127,
    178,
    231,
    30,
    173,
    244,
    193,
    203,
    204,
    238,
    139,
    135,
    71,
    234,
    234,
    217,
    66,
    14,
    129,
    19,
    97,
    165,
    112,
    244,
    35,
    73,
    192,
    12,
    149,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248,
    161,
    189,
    41,
    114,
    65,
    121,
    97,
    50,
    238,
    149,
    44,
    214,
    124,
    167,
    40,
    167,
    127,
    178,
    231,
    30,
    173,
    244,
    193,
    203,
    204,
    238,
    139,
    135,
    71,
    234,
    234,
    217,
    66,
    14,
    129,
    19,
    97,
    165,
    112,
    244,
    35,
    73,
    192,
    12,
    149,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248
  ],
  G: [
    182,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21,
    42,
    22,
    241,
    61,
    99,
    115,
    199,
    166,
    114,
    190,
    204,
    60,
    233,
    66,
    115,
    230,
    125,
    103,
    203,
    125,
    13,
    176,
    94,
    131,
    39,
    198,
    167,
    124,
    67,
    175,
    254,
    1,
    15,
    198,
    62,
    237,
    159,
    31,
    218,
    58,
    244,
    47,
    61,
    67,
    94,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21,
    42,
    22,
    241,
    61,
    99,
    115,
    199,
    166,
    114,
    190,
    204,
    60,
    233,
    66,
    115,
    230,
    125,
    103,
    203,
    125,
    13,
    176,
    94,
    131,
    39,
    198,
    167,
    124,
    67,
    175,
    254,
    1,
    15,
    198,
    62,
    237,
    159,
    31,
    218,
    58,
    244,
    47,
    61,
    67,
    94,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21
  ],
  B: [
    191,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77,
    89,
    112,
    59,
    125,
    226,
    50,
    205,
    227,
    125,
    128,
    104,
    27,
    59,
    66,
    53,
    133,
    159,
    203,
    97,
    125,
    139,
    159,
    158,
    7,
    215,
    47,
    140,
    226,
    223,
    231,
    44,
    110,
    184,
    61,
    233,
    47,
    67,
    148,
    22,
    120,
    173,
    156,
    117,
    181,
    94,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77,
    89,
    112,
    59,
    125,
    226,
    50,
    205,
    227,
    125,
    128,
    104,
    27,
    59,
    66,
    53,
    133,
    159,
    203,
    97,
    125,
    139,
    159,
    158,
    7,
    215,
    47,
    140,
    226,
    223,
    231,
    44,
    110,
    184,
    61,
    233,
    47,
    67,
    148,
    22,
    120,
    173,
    156,
    117,
    181,
    94,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
};

// src/cmaps/red.json
var red_default = {
  R: [0, 128, 255],
  G: [0, 0, 0],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/redyell.json
var redyell_default = {
  R: [192, 224, 255],
  G: [1, 128, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/rocket.json
var rocket_default = {
  R: [3, 112, 144, 188, 236, 246, 255],
  G: [5, 31, 29, 22, 76, 158, 250],
  B: [26, 87, 91, 86, 62, 117, 235],
  A: [0, 30, 38, 49, 67, 85, 107],
  I: [0, 73, 92, 118, 160, 205, 255]
};

// src/cmaps/surface.json
var surface_default = {
  R: [1, 240, 255],
  G: [1, 128, 255],
  B: [1, 128, 255],
  A: [0, 76, 128],
  I: [0, 153, 255]
};

// src/cmaps/thermal.json
var thermal_default = {
  R: [0, 5, 18, 34, 53, 72, 90, 107, 126, 144, 161, 178, 194, 209, 222, 233, 242, 248, 251, 251, 249, 244, 241, 252],
  G: [0, 4, 10, 11, 9, 11, 17, 23, 30, 36, 43, 50, 59, 70, 83, 98, 117, 136, 157, 177, 199, 220, 240, 254],
  B: [3, 24, 50, 76, 96, 106, 109, 110, 108, 104, 97, 89, 79, 67, 55, 42, 26, 12, 6, 22, 47, 79, 121, 164],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
};

// src/cmaps/turbo.json
var turbo_default = {
  R: [48, 48, 64, 70, 65, 25, 132, 195, 244, 254, 218, 122],
  G: [18, 18, 64, 107, 150, 226, 255, 241, 199, 158, 57, 4],
  B: [59, 59, 162, 227, 255, 187, 81, 52, 58, 47, 7, 3],
  A: [0, 22, 26, 30, 34, 43, 52, 57, 63, 67, 77, 86],
  I: [0, 1, 16, 32, 49, 83, 118, 140, 164, 181, 219, 255]
};

// src/cmaps/violet.json
var violet_default = {
  R: [0, 128, 255],
  G: [0, 0, 0],
  B: [0, 128, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/viridis.json
var viridis_default = {
  R: [68, 49, 53, 253],
  G: [1, 104, 183, 231],
  B: [84, 142, 121, 37],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
};

// src/cmaps/warm.json
var warm_default = {
  R: [255, 255, 255],
  G: [127, 196, 254],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/winter.json
var winter_default = {
  R: [0, 0, 0],
  G: [0, 128, 255],
  B: [255, 196, 128],
  A: [0, 64, 128],
  I: [0, 128, 255]
};

// src/cmaps/x_rain.json
var x_rain_default = {
  R: [3, 64, 0, 0, 255, 255, 255],
  G: [0, 0, 0, 255, 255, 192, 3],
  B: [0, 32, 48, 56, 64, 96, 128],
  A: [0, 8, 16, 24, 32, 52, 80],
  I: [0, 32, 64, 96, 160, 192, 255]
};

// src/cmaps/afni_blues_inv.json
var afni_blues_inv_default = {
  min: 0,
  max: 0,
  R: [0, 37],
  G: [242, 0],
  B: [255, 255],
  A: [0, 64],
  I: [0, 255]
};

// src/cmaps/afni_reds_inv.json
var afni_reds_inv_default = {
  R: [255, 255],
  G: [255, 11],
  B: [0, 0],
  A: [0, 64],
  I: [0, 255]
};

// src/cmaps/roi_i256.json
var roi_i256_default = {
  min: 0,
  max: 0,
  R: [
    65,
    10,
    223,
    120,
    216,
    207,
    251,
    93,
    252,
    217,
    21,
    253,
    131,
    165,
    173,
    143,
    144,
    217,
    86,
    89,
    63,
    254,
    172,
    1,
    142,
    107,
    42,
    78,
    221,
    8,
    222,
    71,
    127,
    126,
    167,
    33,
    104,
    2,
    208,
    216,
    0,
    251,
    7,
    105,
    2,
    101,
    248,
    190,
    253,
    62,
    255,
    224,
    166,
    37,
    110,
    138,
    45,
    34,
    6,
    37,
    69,
    201,
    43,
    122,
    199,
    37,
    173,
    194,
    103,
    211,
    75,
    159,
    96,
    4,
    239,
    98,
    110,
    193,
    253,
    166,
    40,
    255,
    48,
    130,
    140,
    243,
    101,
    9,
    177,
    220,
    133,
    32,
    4,
    81,
    48,
    48,
    210,
    109,
    60,
    132,
    1,
    119,
    1,
    159,
    247,
    33,
    212,
    187,
    253,
    144,
    196,
    254,
    168,
    79,
    64,
    196,
    39,
    97,
    73,
    173,
    104,
    216,
    217,
    43,
    101,
    119,
    254,
    5,
    237,
    103,
    203,
    122,
    57,
    87,
    251,
    164,
    19,
    75,
    200,
    2,
    252,
    150,
    66,
    0,
    255,
    157,
    23,
    254,
    55,
    16,
    240,
    161,
    69,
    253,
    207,
    195,
    5,
    60,
    255,
    251,
    200,
    217,
    134,
    123,
    253,
    180,
    27,
    246,
    130,
    136,
    250,
    232,
    4,
    125,
    140,
    22,
    253,
    255,
    13,
    180,
    123,
    61,
    254,
    111,
    10,
    185,
    76,
    192,
    255,
    223,
    186,
    61,
    198,
    5,
    172,
    13,
    83,
    172,
    171,
    6,
    23,
    73,
    134,
    133,
    109,
    61,
    213,
    55,
    57,
    132,
    36,
    209,
    2,
    144,
    1,
    253,
    68,
    155,
    3,
    160,
    2,
    77,
    121,
    70,
    67,
    176,
    223,
    131,
    4,
    162,
    232,
    255,
    150,
    94,
    235,
    191,
    207,
    10,
    246,
    0,
    225,
    4,
    209,
    116,
    57,
    112,
    172,
    253,
    1,
    6,
    92,
    227,
    73,
    62,
    135,
    223
  ],
  G: [
    162,
    50,
    112,
    245,
    4,
    124,
    176,
    243,
    56,
    125,
    183,
    139,
    182,
    68,
    189,
    4,
    225,
    10,
    20,
    223,
    7,
    46,
    31,
    193,
    225,
    250,
    219,
    41,
    2,
    100,
    83,
    181,
    34,
    150,
    72,
    223,
    168,
    248,
    80,
    253,
    7,
    117,
    214,
    2,
    248,
    10,
    3,
    59,
    179,
    160,
    90,
    244,
    146,
    4,
    207,
    4,
    125,
    255,
    96,
    100,
    1,
    208,
    130,
    51,
    116,
    181,
    236,
    53,
    244,
    5,
    165,
    28,
    181,
    86,
    96,
    42,
    254,
    1,
    134,
    194,
    214,
    92,
    41,
    204,
    137,
    86,
    207,
    3,
    143,
    3,
    100,
    239,
    164,
    94,
    65,
    251,
    131,
    244,
    173,
    57,
    143,
    107,
    217,
    53,
    210,
    0,
    148,
    250,
    45,
    198,
    81,
    40,
    61,
    218,
    252,
    88,
    171,
    0,
    248,
    24,
    248,
    4,
    41,
    100,
    187,
    46,
    208,
    145,
    43,
    168,
    121,
    46,
    175,
    250,
    125,
    107,
    233,
    112,
    207,
    231,
    174,
    215,
    53,
    9,
    43,
    153,
    52,
    124,
    128,
    65,
    210,
    147,
    255,
    147,
    63,
    200,
    148,
    254,
    0,
    179,
    241,
    42,
    239,
    2,
    230,
    8,
    82,
    135,
    87,
    16,
    3,
    87,
    86,
    151,
    254,
    8,
    255,
    86,
    53,
    19,
    7,
    192,
    171,
    201,
    253,
    247,
    197,
    103,
    251,
    126,
    0,
    149,
    54,
    183,
    61,
    126,
    79,
    113,
    10,
    103,
    184,
    75,
    11,
    195,
    222,
    136,
    149,
    131,
    8,
    99,
    240,
    177,
    252,
    255,
    198,
    16,
    7,
    68,
    178,
    66,
    191,
    150,
    73,
    26,
    211,
    109,
    78,
    209,
    240,
    254,
    1,
    166,
    247,
    131,
    2,
    0,
    167,
    127,
    133,
    10,
    43,
    99,
    235,
    3,
    214,
    142,
    176,
    82,
    132,
    38,
    10,
    249,
    255,
    215,
    44,
    81
  ],
  B: [
    176,
    182,
    248,
    37,
    117,
    35,
    96,
    69,
    32,
    152,
    108,
    20,
    237,
    250,
    2,
    89,
    141,
    216,
    111,
    251,
    211,
    149,
    10,
    44,
    214,
    103,
    31,
    251,
    3,
    32,
    252,
    246,
    97,
    1,
    219,
    167,
    197,
    4,
    36,
    116,
    206,
    118,
    106,
    43,
    205,
    204,
    114,
    69,
    127,
    205,
    87,
    80,
    41,
    251,
    145,
    204,
    253,
    161,
    247,
    1,
    149,
    9,
    43,
    253,
    97,
    72,
    136,
    161,
    171,
    181,
    26,
    255,
    108,
    80,
    218,
    214,
    231,
    255,
    84,
    31,
    109,
    4,
    218,
    3,
    217,
    36,
    68,
    85,
    241,
    39,
    221,
    2,
    240,
    2,
    173,
    42,
    206,
    5,
    110,
    46,
    103,
    27,
    212,
    184,
    2,
    207,
    246,
    45,
    116,
    72,
    110,
    253,
    38,
    105,
    248,
    159,
    243,
    81,
    192,
    93,
    141,
    145,
    24,
    157,
    234,
    131,
    57,
    178,
    62,
    75,
    65,
    176,
    148,
    40,
    253,
    66,
    76,
    240,
    51,
    154,
    17,
    251,
    139,
    253,
    207,
    9,
    114,
    49,
    200,
    254,
    96,
    73,
    138,
    118,
    204,
    102,
    137,
    89,
    145,
    161,
    4,
    112,
    66,
    234,
    147,
    178,
    212,
    205,
    185,
    11,
    203,
    131,
    2,
    250,
    118,
    169,
    1,
    185,
    154,
    53,
    171,
    197,
    61,
    175,
    249,
    96,
    15,
    254,
    95,
    5,
    222,
    75,
    246,
    194,
    2,
    61,
    180,
    25,
    133,
    165,
    15,
    233,
    59,
    35,
    221,
    140,
    109,
    7,
    114,
    255,
    198,
    0,
    115,
    168,
    252,
    23,
    242,
    80,
    75,
    142,
    137,
    255,
    12,
    182,
    68,
    201,
    4,
    111,
    37,
    228,
    83,
    248,
    24,
    192,
    249,
    5,
    54,
    223,
    160,
    122,
    160,
    114,
    145,
    119,
    252,
    31,
    253,
    250,
    10,
    214,
    8,
    47,
    0,
    142,
    222,
    70
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
};

// src/colortables.ts
var ColorTables = class {
  /**
   * Sets cluts to alphabetically sorted cmaps
   */
  constructor() {
    __publicField(this, "gamma", 1);
    __publicField(this, "version", 0.1);
    __publicField(this, "cluts", {});
    const cmapKeys = Object.keys(cmaps_exports);
    const cmapsSorted = cmapKeys.filter((k) => !k.startsWith("$")).sort(new Intl.Collator("en").compare);
    for (const key of cmapsSorted) {
      this.cluts[key] = cmaps_exports[key];
    }
  }
  addColormap(key, cmap) {
    this.cluts[key] = cmap;
  }
  colormaps() {
    return Object.keys(this.cluts);
  }
  // for backward compatibility: prior to v0.34 "colormaps" used to be "colorMaps"
  colorMaps() {
    return this.colormaps();
  }
  // returns key name if it exists, otherwise returns default "gray"
  colormapFromKey(name) {
    let cmap = this.cluts[name];
    if (cmap !== void 0) {
      return cmap;
    }
    cmap = this.cluts[name.toLowerCase()];
    if (cmap !== void 0) {
      return cmap;
    }
    if (name.length > 0) {
      log.warn("No color map named " + name);
    }
    return {
      min: 0,
      max: 0,
      R: [0, 255],
      G: [0, 255],
      B: [0, 255],
      A: [0, 255],
      I: [0, 255]
    };
  }
  // not included in public docs
  colormap(key = "", isInvert = false) {
    const cmap = this.colormapFromKey(key);
    return this.makeLut(cmap.R, cmap.G, cmap.B, cmap.A, cmap.I, isInvert);
  }
  makeLabelLut(cm, alphaFill = 255) {
    if (cm.R === void 0 || cm.G === void 0 || cm.B === void 0) {
      throw new Error(`Invalid colormap table: ${cm}`);
    }
    const nLabels = cm.R.length;
    const idxs = cm.I ?? [...Array(nLabels).keys()];
    if (nLabels !== cm.G.length || nLabels !== cm.B.length || nLabels !== idxs.length) {
      throw new Error(
        `colormap does not make sense: ${cm} Rs ${cm.R.length} Gs ${cm.G.length} Bs ${cm.B.length} Is ${idxs.length}`
      );
    }
    let As = new Uint8ClampedArray(nLabels).fill(alphaFill);
    As[0] = 0;
    if (cm.A !== void 0) {
      As = Uint8ClampedArray.from(cm.A);
    }
    const mnIdx = Math.min(...idxs);
    const mxIdx = Math.max(...idxs);
    const nLabelsDense = mxIdx - mnIdx + 1;
    const lut = new Uint8ClampedArray(nLabelsDense * 4).fill(0);
    for (let i = 0; i < nLabels; i++) {
      let k = (idxs[i] - mnIdx) * 4;
      lut[k++] = cm.R[i];
      lut[k++] = cm.G[i];
      lut[k++] = cm.B[i];
      lut[k++] = As[i];
    }
    const cmap = {
      lut,
      min: mnIdx,
      max: mxIdx
    };
    if (cm.labels) {
      const nL = cm.labels.length;
      if (nL === nLabelsDense) {
        cmap.labels = cm.labels;
      } else if (nL === nLabels) {
        cmap.labels = Array(nLabelsDense).fill("?");
        for (let i = 0; i < nLabels; i++) {
          const idx = idxs[i];
          cmap.labels[idx] = cm.labels[i];
        }
      }
    }
    return cmap;
  }
  async makeLabelLutFromUrl(name) {
    const response = await fetch(name);
    const cm = await response.json();
    return this.makeLabelLut(cm);
  }
  // not included in public docs
  // The drawing colormap is a variant of the label colormap with precisely 256 colors
  makeDrawLut(name) {
    let cmap = typeof name === "object" ? name : cmaps_exports[name];
    if (cmap === void 0) {
      cmap = {
        min: 0,
        max: 0,
        R: [0, 255, 0, 0, 255, 0, 255],
        G: [0, 0, 255, 0, 255, 255, 0],
        B: [0, 0, 0, 255, 0, 255, 255],
        A: [0, 255, 255, 255, 255, 255, 255],
        I: [0, 255]
      };
    }
    const cm = this.makeLabelLut(cmap, 255);
    if (cm.labels === void 0) {
      cm.labels = [];
    }
    if (cm.labels.length < 256) {
      const j = cm.labels.length;
      for (let i = j; i < 256; i++) {
        cm.labels.push(i.toString());
      }
    }
    const lut = new Uint8ClampedArray(256 * 4);
    let k = 0;
    for (let i = 0; i < 256; i++) {
      lut[k++] = 255;
      lut[k++] = 0;
      lut[k++] = 0;
      lut[k++] = 255;
    }
    lut[3] = 0;
    const explicitLUTbytes = Math.min(cm.lut.length, 256 * 4);
    if (explicitLUTbytes > 0) {
      for (let i = 0; i < explicitLUTbytes; i++) {
        lut[i] = cm.lut[i];
      }
    }
    return {
      lut,
      labels: cm.labels
    };
  }
  // not included in public docs
  makeLut(Rsi, Gsi, Bsi, Asi, Isi, isInvert) {
    const nIdx = Rsi.length;
    const Rs = [...Rsi];
    const Gs = [...Gsi];
    const Bs = [...Bsi];
    if (!Isi) {
      Isi = new Array(nIdx);
      for (let i = 0; i < nIdx; i++) {
        Isi[i] = i / (nIdx - 1) * 255;
      }
    }
    if (!Asi) {
      Asi = new Array(nIdx).fill(64);
      Asi[0] = 0;
    }
    let As = Uint8ClampedArray.from(Asi);
    let Is = Uint8ClampedArray.from(Isi);
    if (isInvert) {
      for (let i = 0; i < nIdx; i++) {
        Rs[i] = Rsi[nIdx - 1 - i];
        Gs[i] = Gsi[nIdx - 1 - i];
        Bs[i] = Bsi[nIdx - 1 - i];
        As[i] = 255 - Asi[nIdx - 1 - i];
        Is[i] = 255 - Isi[nIdx - 1 - i];
      }
    }
    const lut = new Uint8ClampedArray(256 * 4);
    if (typeof Is === "undefined") {
      Is = new Uint8ClampedArray(nIdx).fill(0);
      for (let i = 0; i < nIdx; i++) {
        Is[i] = Math.round(i * 255 / (nIdx - 1));
      }
    }
    if (typeof As === "undefined") {
      As = new Uint8ClampedArray(nIdx).fill(64);
      As[0] = 0;
    }
    for (let i = 0; i < nIdx - 1; i++) {
      const idxLo = Is[i];
      let idxHi = Is[i + 1];
      if (i === 0 && idxLo !== 0) {
        log.warn("colormap issue: indices expected to start with 0 not ", idxLo);
      }
      if (i === Is.length - 2 && idxHi !== 255) {
        log.warn("padding colormap: indices expected end with 255 not ", idxHi);
        idxHi = 255;
      }
      const idxRng = idxHi - idxLo;
      let k = idxLo * 4;
      for (let j = idxLo; j <= idxHi; j++) {
        const f = (j - idxLo) / idxRng;
        lut[k++] = Rs[i] + f * (Rs[i + 1] - Rs[i]);
        lut[k++] = Gs[i] + f * (Gs[i + 1] - Gs[i]);
        lut[k++] = Bs[i] + f * (Bs[i + 1] - Bs[i]);
        lut[k++] = As[i] + f * (As[i + 1] - As[i]);
      }
    }
    if (this.gamma === 1) {
      return lut;
    }
    for (let i = 0; i < 255 * 4; i++) {
      if (i % 4 === 3) {
        continue;
      }
      lut[i] = Math.pow(lut[i] / 255, 1 / this.gamma) * 255;
    }
    return lut;
  }
};
var cmapper = new ColorTables();

// src/nvmesh-utilities.ts
var NVMeshUtilities = class {
  static getClusterBoundaryU8(u82, faces) {
    const border = new Array(u82.length).fill(false);
    const binary = new Array(u82.length).fill(false);
    for (let i = 0; i < u82.length; i++) {
      if (u82[i] > 0) {
        binary[i] = true;
      }
    }
    const nTri = faces.length / 3;
    let j = 0;
    for (let i = 0; i < nTri; i++) {
      const v0 = faces[j];
      const v1 = faces[j + 1];
      const v2 = faces[j + 2];
      j += 3;
      if (binary[v0] === binary[v1] && binary[v0] === binary[v2] && binary[v1] === binary[v2]) {
        continue;
      }
      border[v0] = true;
      border[v1] = true;
      border[v2] = true;
    }
    return border;
  }
  static async gzip(data) {
    const stream = new CompressionStream("gzip");
    const writer = stream.writable.getWriter();
    writer.write(data).catch(console.error);
    const closePromise = writer.close().catch(console.error);
    const response = new Response(stream.readable);
    const result = new Uint8Array(await response.arrayBuffer());
    await closePromise;
    return result;
  }
  static createMZ3(vertices, indices, compress = false, colors = null) {
    const magic = 23117;
    const isRGBA = colors instanceof Uint8Array && colors.length === vertices.length / 3 * 4;
    const attr = isRGBA ? 7 : 3;
    const nface = indices.length / 3;
    const nvert = vertices.length / 3;
    const nskip = 0;
    const headerSize = 16;
    const indexSize = nface * 3 * 4;
    const vertexSize = nvert * 3 * 4;
    const totalSize = headerSize + indexSize + vertexSize;
    const buffer = new ArrayBuffer(totalSize);
    const writer = new DataView(buffer);
    writer.setUint16(0, magic, true);
    writer.setUint16(2, attr, true);
    writer.setUint32(4, nface, true);
    writer.setUint32(8, nvert, true);
    writer.setUint32(12, nskip, true);
    let offset = headerSize;
    new Uint32Array(buffer, offset, indices.length).set(indices);
    offset += indexSize;
    new Float32Array(buffer, offset, vertices.length).set(vertices);
    if (isRGBA) {
      offset += vertexSize;
      new Uint8Array(buffer, offset, colors.length).set(colors);
    }
    if (compress) {
      throw new Error("Call async createMZ3Async() for compression");
    }
    return buffer;
  }
  static async createMZ3Async(vertices, indices, compress = false, colors = null) {
    const buffer = this.createMZ3(vertices, indices, compress, colors);
    if (compress) {
      return await this.gzip(new Uint8Array(buffer));
    }
    return buffer;
  }
  static createOBJ(vertices, indices) {
    let objContent = "";
    for (let i = 0; i < vertices.length; i += 3) {
      objContent += `v ${vertices[i]} ${vertices[i + 1]} ${vertices[i + 2]}
`;
    }
    for (let i = 0; i < indices.length; i += 3) {
      objContent += `f ${indices[i] + 1} ${indices[i + 1] + 1} ${indices[i + 2] + 1}
`;
    }
    const encoder = new TextEncoder();
    const arrayBuffer = encoder.encode(objContent).buffer;
    return arrayBuffer;
  }
  static createSTL(vertices, indices) {
    const numTriangles = indices.length / 3;
    const bufferLength = 84 + numTriangles * 50;
    const arrayBuffer = new ArrayBuffer(bufferLength);
    const dataView = new DataView(arrayBuffer);
    for (let i = 0; i < 80; i++) {
      dataView.setUint8(i, 0);
    }
    dataView.setUint32(80, numTriangles, true);
    let offset = 84;
    for (let i = 0; i < indices.length; i += 3) {
      const i0 = indices[i] * 3;
      const i1 = indices[i + 1] * 3;
      const i2 = indices[i + 2] * 3;
      dataView.setFloat32(offset, 0, true);
      dataView.setFloat32(offset + 4, 0, true);
      dataView.setFloat32(offset + 8, 0, true);
      offset += 12;
      dataView.setFloat32(offset, vertices[i0], true);
      dataView.setFloat32(offset + 4, vertices[i0 + 1], true);
      dataView.setFloat32(offset + 8, vertices[i0 + 2], true);
      offset += 12;
      dataView.setFloat32(offset, vertices[i1], true);
      dataView.setFloat32(offset + 4, vertices[i1 + 1], true);
      dataView.setFloat32(offset + 8, vertices[i1 + 2], true);
      offset += 12;
      dataView.setFloat32(offset, vertices[i2], true);
      dataView.setFloat32(offset + 4, vertices[i2 + 1], true);
      dataView.setFloat32(offset + 8, vertices[i2 + 2], true);
      offset += 12;
      dataView.setUint16(offset, 0, true);
      offset += 2;
    }
    return arrayBuffer;
  }
  static downloadArrayBuffer(buffer, filename) {
    const blob = new Blob([buffer], { type: "application/octet-stream" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.style.display = "none";
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  }
  static async saveMesh(vertices, indices, filename = ".mz3", compress = false) {
    let buff = new ArrayBuffer(0);
    if (/\.obj$/i.test(filename)) {
      buff = this.createOBJ(vertices, indices);
    } else if (/\.stl$/i.test(filename)) {
      buff = this.createSTL(vertices, indices);
    } else {
      if (!/\.mz3$/i.test(filename)) {
        filename += ".mz3";
      }
      buff = await this.createMZ3Async(vertices, indices, compress);
    }
    if (filename.length > 4) {
      this.downloadArrayBuffer(buff, filename);
    }
    return buff;
  }
  static getClusterBoundary(rgba8, faces) {
    const rgba32 = new Uint32Array(rgba8.buffer);
    const border = new Array(rgba32.length).fill(false);
    const nTri = faces.length / 3;
    let j = 0;
    for (let i = 0; i < nTri; i++) {
      const v0 = faces[j];
      const v1 = faces[j + 1];
      const v2 = faces[j + 2];
      j += 3;
      if (rgba32[v0] === rgba32[v1] && rgba32[v0] === rgba32[v2] && rgba32[v1] === rgba32[v2]) {
        continue;
      }
      border[v0] = true;
      border[v1] = true;
      border[v2] = true;
    }
    return border;
  }
  // return spatial extremes for vertices
  static getExtents(pts) {
    if (!ArrayBuffer.isView(pts) && !Array.isArray(pts) || pts.length < 3) {
      return { mxDx: 0, extentsMin: 0, extentsMax: 0 };
    }
    let mxDx = 0;
    const mn = vec3_exports.fromValues(pts[0], pts[1], pts[2]);
    const mx = vec3_exports.fromValues(pts[0], pts[1], pts[2]);
    for (let i = 0; i < pts.length; i += 3) {
      const v = vec3_exports.fromValues(pts[i], pts[i + 1], pts[i + 2]);
      mxDx = Math.max(mxDx, vec3_exports.len(v));
      vec3_exports.min(mn, mn, v);
      vec3_exports.max(mx, mx, v);
    }
    const extentsMin = [mn[0], mn[1], mn[2]];
    const extentsMax = [mx[0], mx[1], mx[2]];
    return { mxDx, extentsMin, extentsMax };
  }
  // determine vector orthogonal to plane defined by triangle
  // triangle winding determines front/back face
  static generateNormals(pts, tris) {
    const normal = [];
    let ctr;
    const normalsDataLength = pts.length;
    let qx;
    let qy;
    let qz;
    let px;
    let py;
    let pz;
    let index1;
    let index2;
    let index3;
    const norms = new Float32Array(normalsDataLength);
    const numIndices = tris.length;
    for (ctr = 0; ctr < numIndices; ctr += 3) {
      index1 = tris[ctr] * 3;
      index2 = tris[ctr + 1] * 3;
      index3 = tris[ctr + 2] * 3;
      const p1 = [pts[index1], pts[index1 + 1], pts[index1 + 2]];
      const p2 = [pts[index2], pts[index2 + 1], pts[index2 + 2]];
      const p3 = [pts[index3], pts[index3 + 1], pts[index3 + 2]];
      qx = p2[0] - p1[0];
      qy = p2[1] - p1[1];
      qz = p2[2] - p1[2];
      px = p3[0] - p1[0];
      py = p3[1] - p1[1];
      pz = p3[2] - p1[2];
      normal[0] = py * qz - pz * qy;
      normal[1] = pz * qx - px * qz;
      normal[2] = px * qy - py * qx;
      norms[index1] += normal[0];
      norms[index1 + 1] += normal[1];
      norms[index1 + 2] += normal[2];
      norms[index2] += normal[0];
      norms[index2 + 1] += normal[1];
      norms[index2 + 2] += normal[2];
      norms[index3] += normal[0];
      norms[index3 + 1] += normal[1];
      norms[index3 + 2] += normal[2];
    }
    for (ctr = 0; ctr < normalsDataLength; ctr += 3) {
      normal[0] = -1 * norms[ctr];
      normal[1] = -1 * norms[ctr + 1];
      normal[2] = -1 * norms[ctr + 2];
      let len4 = normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2];
      if (len4 > 0) {
        len4 = 1 / Math.sqrt(len4);
        normal[0] *= len4;
        normal[1] *= len4;
        normal[2] *= len4;
      }
      norms[ctr] = normal[0];
      norms[ctr + 1] = normal[1];
      norms[ctr + 2] = normal[2];
    }
    return norms;
  }
};

// src/nvutilities.ts
var import_array_equal = __toESM(require_array_equal(), 1);
var _dataView, _index, _localFiles, _centralDirectories, _endOfCentralDirectory;
var Zip = class {
  constructor(arrayBuffer) {
    __privateAdd(this, _dataView);
    __privateAdd(this, _index, 0);
    __privateAdd(this, _localFiles, []);
    __privateAdd(this, _centralDirectories, []);
    __privateAdd(this, _endOfCentralDirectory);
    __privateSet(this, _dataView, new DataView(arrayBuffer));
    this.read();
  }
  async extract(entry) {
    const buffer = new Uint8Array(__privateGet(this, _dataView).buffer.slice(entry.startsAt, entry.startsAt + entry.compressedSize));
    if (entry.compressionMethod === 0) {
      return buffer;
    } else if (entry.compressionMethod === 8) {
      const stream = new DecompressionStream("deflate-raw");
      const writer = stream.writable.getWriter();
      writer.write(buffer).catch(console.error);
      const closePromise = writer.close().catch(console.error);
      const response = new Response(stream.readable);
      const result = new Uint8Array(await response.arrayBuffer());
      await closePromise;
      return result;
    }
    throw new Error(`Unsupported compression method: ${entry.compressionMethod}`);
  }
  read() {
    while (!__privateGet(this, _endOfCentralDirectory) && __privateGet(this, _index) < __privateGet(this, _dataView).byteLength) {
      const signature = __privateGet(this, _dataView).getUint32(__privateGet(this, _index), true);
      if (signature === 67324752) {
        const entry = this.readLocalFile(__privateGet(this, _index));
        entry.extract = this.extract.bind(this, entry);
        __privateGet(this, _localFiles).push(entry);
        const hasDataDescriptor = (entry.generalPurpose & 8) !== 0;
        entry.startsAt = __privateGet(this, _index) + 30 + entry.fileNameLength + entry.extraLength;
        if (entry.compressedSize === 0 && hasDataDescriptor) {
          let scanIndex = entry.startsAt;
          while (scanIndex + 20 <= __privateGet(this, _dataView).byteLength) {
            const possibleSignature = __privateGet(this, _dataView).getUint32(scanIndex, true);
            if (possibleSignature === 134695760) {
              const nextPK = __privateGet(this, _dataView).getUint16(scanIndex + 16, true) === 19280;
              if (nextPK) {
                scanIndex += 4;
                break;
              }
            }
            scanIndex++;
          }
          entry.crc = __privateGet(this, _dataView).getUint32(scanIndex, true);
          entry.compressedSize = __privateGet(this, _dataView).getUint32(scanIndex + 4, true);
          entry.uncompressedSize = __privateGet(this, _dataView).getUint32(scanIndex + 8, true);
          __privateSet(this, _index, scanIndex + 12);
        } else {
          __privateSet(this, _index, entry.startsAt + entry.compressedSize);
        }
      } else if (signature === 33639248) {
        const entry = this.readCentralDirectory(__privateGet(this, _index));
        __privateGet(this, _centralDirectories).push(entry);
        __privateSet(this, _index, __privateGet(this, _index) + (46 + entry.fileNameLength + entry.extraLength + entry.fileCommentLength));
      } else if (signature === 101010256) {
        __privateSet(this, _endOfCentralDirectory, this.readEndCentralDirectory(__privateGet(this, _index)));
        break;
      } else if (signature === 101075792) {
        __privateSet(this, _endOfCentralDirectory, this.readEndCentralDirectory64(__privateGet(this, _index)));
        break;
      } else {
        console.error(`Unexpected ZIP signature 0x${signature.toString(16).padStart(8, "0")} at index ${__privateGet(this, _index)}`);
        break;
      }
    }
  }
  readLocalFile(offset) {
    let compressedSize = __privateGet(this, _dataView).getUint32(offset + 18, true);
    let uncompressedSize = __privateGet(this, _dataView).getUint32(offset + 22, true);
    const fileNameLength = __privateGet(this, _dataView).getUint16(offset + 26, true);
    const extraLength = __privateGet(this, _dataView).getUint16(offset + 28, true);
    const extraOffset = offset + 30 + fileNameLength;
    const extra = this.readString(extraOffset, extraLength);
    if (compressedSize === 4294967295 && uncompressedSize === 4294967295) {
      let zip64Offset = extraOffset;
      let foundZip64 = false;
      while (zip64Offset < extraOffset + extraLength - 4) {
        const fieldSignature = __privateGet(this, _dataView).getUint16(zip64Offset, true);
        const fieldLength = __privateGet(this, _dataView).getUint16(zip64Offset + 2, true);
        zip64Offset += 4;
        if (fieldSignature === 1) {
          if (fieldLength >= 16) {
            uncompressedSize = Number(__privateGet(this, _dataView).getBigUint64(zip64Offset, true));
            zip64Offset += 8;
            compressedSize = Number(__privateGet(this, _dataView).getBigUint64(zip64Offset, true));
            foundZip64 = true;
            break;
          } else {
            throw new Error(
              `ZIP64 extra field found but is too small (expected at least 16 bytes, got ${fieldLength}).`
            );
          }
        }
        zip64Offset += fieldLength;
      }
      if (!foundZip64) {
        throw new Error("ZIP64 format missing extra field with signature 0x0001.");
      }
    }
    return {
      signature: this.readString(offset, 4),
      version: __privateGet(this, _dataView).getUint16(offset + 4, true),
      generalPurpose: __privateGet(this, _dataView).getUint16(offset + 6, true),
      compressionMethod: __privateGet(this, _dataView).getUint16(offset + 8, true),
      lastModifiedTime: __privateGet(this, _dataView).getUint16(offset + 10, true),
      lastModifiedDate: __privateGet(this, _dataView).getUint16(offset + 12, true),
      crc: __privateGet(this, _dataView).getUint32(offset + 14, true),
      compressedSize,
      uncompressedSize,
      fileNameLength,
      extraLength,
      fileName: this.readString(offset + 30, fileNameLength),
      extra: this.readString(offset + 30 + fileNameLength, extraLength)
    };
  }
  readCentralDirectory(offset) {
    return {
      versionCreated: __privateGet(this, _dataView).getUint16(offset + 4, true),
      versionNeeded: __privateGet(this, _dataView).getUint16(offset + 6, true),
      fileNameLength: __privateGet(this, _dataView).getUint16(offset + 28, true),
      extraLength: __privateGet(this, _dataView).getUint16(offset + 30, true),
      fileCommentLength: __privateGet(this, _dataView).getUint16(offset + 32, true),
      diskNumber: __privateGet(this, _dataView).getUint16(offset + 34, true),
      internalAttributes: __privateGet(this, _dataView).getUint16(offset + 36, true),
      externalAttributes: __privateGet(this, _dataView).getUint32(offset + 38, true),
      offset: __privateGet(this, _dataView).getUint32(offset + 42, true),
      comments: this.readString(offset + 46, __privateGet(this, _dataView).getUint16(offset + 32, true))
    };
  }
  readEndCentralDirectory(offset) {
    const commentLength = __privateGet(this, _dataView).getUint16(offset + 20, true);
    return {
      numberOfDisks: __privateGet(this, _dataView).getUint16(offset + 4, true),
      centralDirectoryStartDisk: __privateGet(this, _dataView).getUint16(offset + 6, true),
      numberCentralDirectoryRecordsOnThisDisk: __privateGet(this, _dataView).getUint16(offset + 8, true),
      numberCentralDirectoryRecords: __privateGet(this, _dataView).getUint16(offset + 10, true),
      centralDirectorySize: __privateGet(this, _dataView).getUint32(offset + 12, true),
      centralDirectoryOffset: __privateGet(this, _dataView).getUint32(offset + 16, true),
      commentLength,
      comment: this.readString(offset + 22, commentLength)
    };
  }
  readEndCentralDirectory64(offset) {
    const commentLength = Number(__privateGet(this, _dataView).getBigUint64(offset + 0, true));
    return {
      numberOfDisks: __privateGet(this, _dataView).getUint32(offset + 16, true),
      centralDirectoryStartDisk: __privateGet(this, _dataView).getUint32(offset + 20, true),
      numberCentralDirectoryRecordsOnThisDisk: Number(__privateGet(this, _dataView).getBigUint64(offset + 24, true)),
      numberCentralDirectoryRecords: Number(__privateGet(this, _dataView).getBigUint64(offset + 32, true)),
      centralDirectorySize: Number(__privateGet(this, _dataView).getBigUint64(offset + 40, true)),
      centralDirectoryOffset: Number(__privateGet(this, _dataView).getBigUint64(offset + 48, true)),
      commentLength,
      comment: ""
    };
  }
  readString(offset, length4) {
    return Array.from({ length: length4 }, (_, i) => String.fromCharCode(__privateGet(this, _dataView).getUint8(offset + i))).join("");
  }
  get entries() {
    return __privateGet(this, _localFiles);
  }
};
_dataView = new WeakMap();
_index = new WeakMap();
_localFiles = new WeakMap();
_centralDirectories = new WeakMap();
_endOfCentralDirectory = new WeakMap();
var NVUtilities = class _NVUtilities {
  static arrayBufferToBase64(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    return _NVUtilities.uint8tob64(bytes);
  }
  static async decompress(data) {
    const format = data[0] === 31 && data[1] === 139 && data[2] === 8 ? "gzip" : data[0] === 120 && (data[1] === 1 || data[1] === 94 || data[1] === 156 || data[1] === 218) ? "deflate" : "deflate-raw";
    const stream = new DecompressionStream(format);
    const writer = stream.writable.getWriter();
    writer.write(data).catch(console.error);
    const closePromise = writer.close().catch(console.error);
    const response = new Response(stream.readable);
    const result = new Uint8Array(await response.arrayBuffer());
    await closePromise;
    return result;
  }
  static async decompressToBuffer(data) {
    const decompressed = await _NVUtilities.decompress(data);
    return decompressed.buffer.slice(decompressed.byteOffset, decompressed.byteOffset + decompressed.byteLength);
  }
  static async readMatV4(buffer, isReplaceDots = false) {
    let len4 = buffer.byteLength;
    if (len4 < 40) {
      throw new Error("File too small to be MAT v4: bytes = " + buffer.byteLength);
    }
    let reader = new DataView(buffer);
    let magic = reader.getUint16(0, true);
    let _buffer = buffer;
    if (magic === 35615 || magic === 8075) {
      const raw = await this.decompress(new Uint8Array(buffer));
      reader = new DataView(raw.buffer);
      magic = reader.getUint16(0, true);
      _buffer = raw.buffer;
      len4 = _buffer.byteLength;
    }
    const textDecoder = new TextDecoder("utf-8");
    const bytes = new Uint8Array(_buffer);
    let pos = 0;
    const mat = {};
    function getTensDigit(v) {
      return Math.floor(v / 10) % 10;
    }
    function readArray(tagDataType, tagBytesStart, tagBytesEnd) {
      const byteArray = new Uint8Array(bytes.subarray(tagBytesStart, tagBytesEnd));
      if (tagDataType === 1) {
        return new Float32Array(byteArray.buffer);
      }
      if (tagDataType === 2) {
        return new Int32Array(byteArray.buffer);
      }
      if (tagDataType === 3) {
        return new Int16Array(byteArray.buffer);
      }
      if (tagDataType === 4) {
        return new Uint16Array(byteArray.buffer);
      }
      if (tagDataType === 5) {
        return new Uint8Array(byteArray.buffer);
      }
      return new Float64Array(byteArray.buffer);
    }
    function readTag() {
      const mtype = reader.getUint32(pos, true);
      const mrows = reader.getUint32(pos + 4, true);
      const ncols = reader.getUint32(pos + 8, true);
      const imagf = reader.getUint32(pos + 12, true);
      const namlen = reader.getUint32(pos + 16, true);
      pos += 20;
      if (imagf !== 0) {
        throw new Error("Matlab V4 reader does not support imaginary numbers");
      }
      const tagArrayItems = mrows * ncols;
      if (tagArrayItems < 1) {
        throw new Error("mrows * ncols must be greater than one");
      }
      const byteArray = new Uint8Array(bytes.subarray(pos, pos + namlen));
      let tagName = textDecoder.decode(byteArray).trim().replaceAll("\0", "");
      if (isReplaceDots) {
        tagName = tagName.replaceAll(".", "_");
      }
      const tagDataType = getTensDigit(mtype);
      let tagBytesPerItem = 8;
      if (tagDataType >= 1 && tagDataType <= 2) {
        tagBytesPerItem = 4;
      } else if (tagDataType >= 3 && tagDataType <= 4) {
        tagBytesPerItem = 2;
      } else if (tagDataType === 5) {
        tagBytesPerItem = 1;
      } else if (tagDataType !== 0) {
        throw new Error("impossible Matlab v4 datatype");
      }
      pos += namlen;
      if (mtype > 50) {
        throw new Error("Does not appear to be little-endian V4 Matlab file");
      }
      const posEnd = pos + tagArrayItems * tagBytesPerItem;
      mat[tagName] = readArray(tagDataType, pos, posEnd);
      pos = posEnd;
    }
    while (pos + 20 < len4) {
      readTag();
    }
    return mat;
  }
  // readMatV4()
  static b64toUint8(base64) {
    const binaryString = atob(base64);
    const length4 = binaryString.length;
    const bytes = new Uint8Array(length4);
    for (let i = 0; i < length4; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  /*
  https://gist.github.com/jonleighton/958841
  MIT LICENSE
  Copyright 2011 Jon Leighton
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  static uint8tob64(bytes) {
    let base64 = "";
    const encodings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const byteLength = bytes.byteLength;
    const byteRemainder = byteLength % 3;
    const mainLength = byteLength - byteRemainder;
    let a, b, c, d;
    let chunk;
    for (let i = 0; i < mainLength; i = i + 3) {
      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
      a = (chunk & 16515072) >> 18;
      b = (chunk & 258048) >> 12;
      c = (chunk & 4032) >> 6;
      d = chunk & 63;
      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }
    if (byteRemainder === 1) {
      chunk = bytes[mainLength];
      a = (chunk & 252) >> 2;
      b = (chunk & 3) << 4;
      base64 += encodings[a] + encodings[b] + "==";
    } else if (byteRemainder === 2) {
      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
      a = (chunk & 64512) >> 10;
      b = (chunk & 1008) >> 4;
      c = (chunk & 15) << 2;
      base64 += encodings[a] + encodings[b] + encodings[c] + "=";
    }
    return base64;
  }
  // https://stackoverflow.com/questions/34156282/how-do-i-save-json-to-local-text-file
  static download(content, fileName, contentType) {
    const a = document.createElement("a");
    const contentArray = Array.isArray(content) ? content : [content];
    const file = new Blob(contentArray, { type: contentType });
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
  }
  static readFileAsync(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  }
  static blobToBase64(blob) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }
  static async decompressBase64String(base64) {
    const compressed = atob(base64);
    const compressedBuffer = new ArrayBuffer(compressed.length);
    const compressedView = new Uint8Array(compressedBuffer);
    for (let i = 0; i < compressed.length; i++) {
      compressedView[i] = compressed.charCodeAt(i);
    }
    return _NVUtilities.decompressArrayBuffer(compressedView);
  }
  static async compressToBase64String(string) {
    const buf = await _NVUtilities.compressStringToArrayBuffer(string);
    return _NVUtilities.uint8tob64(new Uint8Array(buf));
  }
  /**
   * Converts a string into a Uint8Array for use with compression/decompression methods (101arrowz/fflate: MIT License)
   * @param str The string to encode
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless decoding a binary string.
   * @returns The string encoded in UTF-8/Latin-1 binary
   */
  static strToU8(str6, latin1) {
    if (latin1) {
      const ar2 = new Uint8Array(str6.length);
      for (let i = 0; i < str6.length; ++i) {
        ar2[i] = str6.charCodeAt(i);
      }
      return ar2;
    }
    const l = str6.length;
    const slc2 = (v, s, e) => {
      if (s == null || s < 0) {
        s = 0;
      }
      if (e == null || e > v.length) {
        e = v.length;
      }
      return new Uint8Array(v.subarray(s, e));
    };
    let ar = new Uint8Array(str6.length + (str6.length >> 1));
    let ai = 0;
    const w = (v) => {
      ar[ai++] = v;
    };
    for (let i = 0; i < l; ++i) {
      if (ai + 5 > ar.length) {
        const n = new Uint8Array(ai + 8 + (l - i << 1));
        n.set(ar);
        ar = n;
      }
      let c = str6.charCodeAt(i);
      if (c < 128 || latin1) {
        w(c);
      } else if (c < 2048) {
        w(192 | c >> 6);
        w(128 | c & 63);
      } else if (c > 55295 && c < 57344) {
        c = 65536 + (c & 1023 << 10) | str6.charCodeAt(++i) & 1023;
        w(240 | c >> 18);
        w(128 | c >> 12 & 63);
        w(128 | c >> 6 & 63);
        w(128 | c & 63);
      } else {
        c = 65536 + (c & 1023 << 10) | str6.charCodeAt(++i) & 1023;
        w(240 | c >> 18);
        w(128 | c >> 12 & 63);
        w(128 | c >> 6 & 63);
        w(128 | c & 63);
      }
    }
    return slc2(ar, 0, ai);
  }
  static async compress(data, format = "gzip") {
    const stream = new CompressionStream(format);
    const writer = stream.writable.getWriter();
    writer.write(data).catch(console.error);
    const closePromise = writer.close().catch(console.error);
    const response = new Response(stream.readable);
    const result = await response.arrayBuffer();
    await closePromise;
    return result;
  }
  static async compressStringToArrayBuffer(input) {
    const uint8Array = this.strToU8(input);
    return await this.compress(uint8Array);
  }
  static isArrayBufferCompressed(buffer) {
    if (buffer && buffer.byteLength) {
      const arr = new Uint8Array(buffer);
      const magicNumber = arr[0] << 8 | arr[1];
      return magicNumber === 8075;
    } else {
      return false;
    }
  }
  /**
   * Converts a Uint8Array to a string (101arrowz/fflate: MIT License)
   * @param dat The data to decode to string
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless encoding to binary string.
   * @returns The original UTF-8/Latin-1 string
   */
  static strFromU8(dat, latin1) {
    if (latin1) {
      let r = "";
      for (let i = 0; i < dat.length; i += 16384) {
        r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
      }
      return r;
    } else {
      const slc2 = (v, s2, e) => {
        if (s2 == null || s2 < 0) {
          s2 = 0;
        }
        if (e == null || e > v.length) {
          e = v.length;
        }
        return new Uint8Array(v.subarray(s2, e));
      };
      const dutf8 = (d) => {
        for (let r2 = "", i = 0; ; ) {
          let c = d[i++];
          const eb = (c > 127) + (c > 223) + (c > 239);
          if (i + eb > d.length) {
            return { s: r2, r: slc2(d, i - 1) };
          }
          if (!eb) {
            r2 += String.fromCharCode(c);
          } else if (eb === 3) {
            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536;
            r2 += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
          } else if (eb & 1) {
            r2 += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
          } else {
            r2 += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
          }
        }
      };
      const { s, r } = dutf8(dat);
      if (r.length) {
        throw new Error("Unexpected trailing bytes in UTF-8 decoding");
      }
      return s;
    }
  }
  static async decompressArrayBuffer(buffer) {
    const decompressed = await this.decompress(new Uint8Array(buffer));
    return this.strFromU8(decompressed);
  }
  static arraysAreEqual(a, b) {
    return (0, import_array_equal.default)(a, b);
  }
  /**
   * Generate a pre-filled number array.
   *
   * @param start - start value
   * @param stop - stop value
   * @param step - step value
   * @returns filled number array
   */
  static range(start, stop, step) {
    return Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);
  }
  /**
   * convert spherical AZIMUTH, ELEVATION to Cartesian
   * @param azimuth - azimuth number
   * @param elevation - elevation number
   * @returns the converted [x, y, z] coordinates
   * @example
   * xyz = NVUtilities.sph2cartDeg(42, 42)
   */
  static sph2cartDeg(azimuth, elevation) {
    const Phi = -elevation * (Math.PI / 180);
    const Theta = (azimuth - 90) % 360 * (Math.PI / 180);
    const ret = [Math.cos(Phi) * Math.cos(Theta), Math.cos(Phi) * Math.sin(Theta), Math.sin(Phi)];
    const len4 = Math.sqrt(ret[0] * ret[0] + ret[1] * ret[1] + ret[2] * ret[2]);
    if (len4 <= 0) {
      return ret;
    }
    ret[0] /= len4;
    ret[1] /= len4;
    ret[2] /= len4;
    return ret;
  }
  static vox2mm(XYZ, mtx) {
    const sform = mat4_exports.clone(mtx);
    mat4_exports.transpose(sform, sform);
    const pos = vec4_exports.fromValues(XYZ[0], XYZ[1], XYZ[2], 1);
    vec4_exports.transformMat4(pos, pos, sform);
    const pos3 = vec3_exports.fromValues(pos[0], pos[1], pos[2]);
    return pos3;
  }
};

// src/nvmesh-loaders.ts
var utiltiesLogger = log;
var NVMeshLoaders = class _NVMeshLoaders {
  // read undocumented AFNI tract.niml format streamlines
  static readTRACT(buffer) {
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be niml.tract: bytes = " + len4);
    }
    const reader = new DataView(buffer);
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] !== 60) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 62) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1)).trim();
    }
    let line = readStr();
    function readNumericTag(TagName) {
      const pos2 = line.indexOf(TagName);
      if (pos2 < 0) {
        return 0;
      }
      const spos = line.indexOf('"', pos2) + 1;
      const epos = line.indexOf('"', spos);
      const str6 = line.slice(spos, epos);
      return parseInt(str6);
    }
    const n_tracts = readNumericTag("N_tracts=");
    if (!line.startsWith("<network") || n_tracts < 1) {
      log.warn("This is not a valid niml.tract file " + line);
    }
    let npt = 0;
    const offsetPt0 = [];
    offsetPt0.push(npt);
    const pts = [];
    const bundleTags = [];
    for (let t = 0; t < n_tracts; t++) {
      line = readStr();
      const new_tracts = readNumericTag("ni_dimen=");
      const bundleTag = readNumericTag("Bundle_Tag=");
      const isLittleEndian = line.includes("binary.lsbfirst");
      for (let i = 0; i < new_tracts; i++) {
        pos += 4;
        const new_pts = reader.getUint32(pos, isLittleEndian) / 3;
        pos += 4;
        for (let j = 0; j < new_pts; j++) {
          pts.push(reader.getFloat32(pos, isLittleEndian));
          pos += 4;
          pts.push(-reader.getFloat32(pos, isLittleEndian));
          pos += 4;
          pts.push(reader.getFloat32(pos, isLittleEndian));
          pos += 4;
        }
        npt += new_pts;
        offsetPt0.push(npt);
        bundleTags.push(bundleTag);
      }
      line = readStr();
    }
    const dps = [];
    dps.push({
      id: "tract",
      vals: Float32Array.from(bundleTags)
    });
    return {
      pts: new Float32Array(pts),
      offsetPt0: new Uint32Array(offsetPt0),
      dps
    };
  }
  // readTRACT()
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // https://brain.labsolver.org/hcp_trk_atlas.html
  static async readTT(buffer) {
    let offsetPt0 = new Uint32Array(0);
    let pts = new Float32Array(0);
    const mat = await NVUtilities.readMatV4(buffer);
    if (!("trans_to_mni" in mat)) {
      throw new Error("TT format file must have 'trans_to_mni'");
    }
    if (!("voxel_size" in mat)) {
      throw new Error("TT format file must have 'voxel_size'");
    }
    if (!("track" in mat)) {
      throw new Error("TT format file must have 'track'");
    }
    let trans_to_mni = mat4_exports.create();
    const m = mat.trans_to_mni;
    trans_to_mni = mat4_exports.fromValues(
      m[0],
      m[1],
      m[2],
      m[3],
      m[4],
      m[5],
      m[6],
      m[7],
      m[8],
      m[9],
      m[10],
      m[11],
      m[12],
      m[13],
      m[14],
      m[15]
    );
    mat4_exports.transpose(trans_to_mni, trans_to_mni);
    function parse_tt(track) {
      const dv = new DataView(track.buffer);
      const pos = [];
      let nvert3 = 0;
      let i = 0;
      while (i < track.length) {
        pos.push(i);
        const newpts = dv.getUint32(i, true);
        i = i + newpts + 13;
        nvert3 += newpts;
      }
      offsetPt0 = new Uint32Array(pos.length + 1);
      pts = new Float32Array(nvert3);
      let npt = 0;
      for (let i2 = 0; i2 < pos.length; i2++) {
        offsetPt0[i2] = npt / 3;
        let p = pos[i2];
        const sz = dv.getUint32(p, true) / 3;
        let x = dv.getInt32(p + 4, true);
        let y = dv.getInt32(p + 8, true);
        let z = dv.getInt32(p + 12, true);
        p += 16;
        pts[npt++] = x;
        pts[npt++] = y;
        pts[npt++] = z;
        for (let j = 2; j <= sz; j++) {
          x = x + dv.getInt8(p++);
          y = y + dv.getInt8(p++);
          z = z + dv.getInt8(p++);
          pts[npt++] = x;
          pts[npt++] = y;
          pts[npt++] = z;
        }
      }
      for (let i2 = 0; i2 < npt; i2++) {
        pts[i2] = pts[i2] / 32;
      }
      let v = 0;
      for (let i2 = 0; i2 < npt / 3; i2++) {
        const pos2 = vec4_exports.fromValues(pts[v], pts[v + 1], pts[v + 2], 1);
        vec4_exports.transformMat4(pos2, pos2, trans_to_mni);
        pts[v++] = pos2[0];
        pts[v++] = pos2[1];
        pts[v++] = pos2[2];
      }
      offsetPt0[pos.length] = npt / 3;
    }
    parse_tt(mat.track);
    return {
      pts,
      offsetPt0
    };
  }
  // readTT
  // read TRX format tractogram
  // https://github.com/tee-ar-ex/trx-spec/blob/master/specifications.md
  static async readTRX(buffer) {
    function decodeFloat16(binary) {
      "use strict";
      const exponent = (binary & 31744) >> 10;
      const fraction = binary & 1023;
      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
    }
    let noff = 0;
    let npt = 0;
    let pts = new Float32Array([]);
    const offsetPt0 = [];
    const dpg = [];
    const dps = [];
    const dpv = [];
    let header = [];
    let isOverflowUint64 = false;
    const zip = new Zip(buffer);
    for (let i = 0; i < zip.entries.length; i++) {
      const entry = zip.entries[i];
      if (entry.uncompressedSize === 0) {
        continue;
      }
      const parts = entry.fileName.split("/");
      const fname = parts.slice(-1)[0];
      if (fname.startsWith(".")) {
        continue;
      }
      const pname = parts.slice(-2)[0];
      const tag = fname.split(".")[0];
      const data = await entry.extract();
      if (fname.includes("header.json")) {
        const jsonString = new TextDecoder().decode(data);
        header = JSON.parse(jsonString);
        continue;
      }
      let nval = 0;
      let vals = [];
      if (fname.endsWith(".uint64") || fname.endsWith(".int64")) {
        nval = data.length / 8;
        vals = new Uint32Array(nval);
        const u32 = new Uint32Array(data.buffer);
        let j = 0;
        for (let i2 = 0; i2 < nval; i2++) {
          vals[i2] = u32[j];
          if (u32[j + 1] !== 0) {
            isOverflowUint64 = true;
          }
          j += 2;
        }
      } else if (fname.endsWith(".uint32")) {
        vals = new Uint32Array(data.buffer);
      } else if (fname.endsWith(".uint16")) {
        vals = new Uint16Array(data.buffer);
      } else if (fname.endsWith(".uint8")) {
        vals = new Uint8Array(data.buffer);
      } else if (fname.endsWith(".int32")) {
        vals = new Int32Array(data.buffer);
      } else if (fname.endsWith(".int16")) {
        vals = new Int16Array(data.buffer);
      } else if (fname.endsWith(".int8")) {
        vals = new Int8Array(data.buffer);
      } else if (fname.endsWith(".float64")) {
        vals = new Float64Array(data.buffer);
      } else if (fname.endsWith(".float32")) {
        vals = new Float32Array(data.buffer);
      } else if (fname.endsWith(".float16")) {
        nval = data.length / 2;
        vals = new Float32Array(nval);
        const u162 = new Uint16Array(data.buffer);
        const lut = new Float32Array(65536);
        for (let i2 = 0; i2 < 65536; i2++) {
          lut[i2] = decodeFloat16(i2);
        }
        for (let i2 = 0; i2 < nval; i2++) {
          vals[i2] = lut[u162[i2]];
        }
      } else {
        continue;
      }
      nval = vals.length;
      if (pname.includes("groups")) {
        dpg.push({
          id: tag,
          vals: Float32Array.from(vals.slice())
        });
        continue;
      }
      if (pname.includes("dpv")) {
        dpv.push({
          id: tag,
          vals: Float32Array.from(vals.slice())
        });
        continue;
      }
      if (pname.includes("dps")) {
        dps.push({
          id: tag,
          vals: Float32Array.from(vals.slice())
        });
        continue;
      }
      if (fname.startsWith("offsets.")) {
        noff = nval;
        for (let i2 = 0; i2 < nval; i2++) {
          offsetPt0[i2] = vals[i2];
        }
      }
      if (fname.startsWith("positions.3.")) {
        npt = nval;
        pts = new Float32Array(vals);
      }
    }
    if (noff === 0 || npt === 0) {
      throw new Error("Failure reading TRX format (no offsets or points).");
    }
    if (isOverflowUint64) {
      throw new Error("Too many vertices: JavaScript does not support 64 bit integers");
    }
    offsetPt0[noff] = npt / 3;
    return {
      pts,
      offsetPt0: new Uint32Array(offsetPt0),
      dpg,
      dps,
      dpv,
      header
    };
  }
  // readTRX()
  // read mrtrix tsf format Track Scalar Files - these are are DPV
  // https://mrtrix.readthedocs.io/en/dev/getting_started/image_data.html#track-scalar-file-format-tsf
  static readTSF(buffer, n_vert = 0) {
    const vals = new Float32Array(n_vert);
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be TSF: bytes = " + len4);
    }
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.includes("mrtrix track scalars")) {
      throw new Error("Not a valid TSF file");
    }
    let offset = -1;
    while (pos < len4 && !line.includes("END")) {
      line = readStr();
      if (line.toLowerCase().startsWith("file:")) {
        offset = parseInt(line.split(" ").pop());
      }
      if (line.toLowerCase().startsWith("datatype:") && !line.endsWith("Float32LE")) {
        throw new Error("Only supports TSF files with Float32LE");
      }
    }
    if (offset < 20) {
      throw new Error("Not a valid TSF file (missing file offset)");
    }
    pos = offset;
    const reader = new DataView(buffer);
    let npt = 0;
    while (pos + 4 <= len4 && npt < n_vert) {
      const ptx = reader.getFloat32(pos, true);
      pos += 4;
      if (!isFinite(ptx)) {
        if (!isNaN(ptx)) {
          break;
        }
      } else {
        vals[npt++] = ptx;
      }
    }
    return vals;
  }
  // readTSF
  // read mrtrix tck format streamlines
  // https://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html#tracks-file-format-tck
  static readTCK(buffer) {
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be TCK: bytes = " + len4);
    }
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.includes("mrtrix tracks")) {
      throw new Error("Not a valid TCK file");
    }
    let offset = -1;
    while (pos < len4 && !line.includes("END")) {
      line = readStr();
      if (line.toLowerCase().startsWith("file:")) {
        offset = parseInt(line.split(" ").pop());
      }
    }
    if (offset < 20) {
      throw new Error("Not a valid TCK file (missing file offset)");
    }
    pos = offset;
    const reader = new DataView(buffer);
    let npt = 0;
    let offsetPt0 = new Uint32Array(len4 / (4 * 4));
    let noffset = 0;
    let npt3 = 0;
    let pts = new Float32Array(len4 / 4);
    offsetPt0[0] = 0;
    while (pos + 12 < len4) {
      const ptx = reader.getFloat32(pos, true);
      pos += 4;
      const pty = reader.getFloat32(pos, true);
      pos += 4;
      const ptz = reader.getFloat32(pos, true);
      pos += 4;
      if (!isFinite(ptx)) {
        offsetPt0[noffset++] = npt;
        if (!isNaN(ptx)) {
          break;
        }
      } else {
        pts[npt3++] = ptx;
        pts[npt3++] = pty;
        pts[npt3++] = ptz;
        npt++;
      }
    }
    pts = pts.slice(0, npt3);
    offsetPt0 = offsetPt0.slice(0, noffset);
    return {
      pts,
      offsetPt0
    };
  }
  // readTCK()
  // not included in public docs
  // read trackvis trk format streamlines
  // http://trackvis.org/docs/?subsect=fileformat
  static async readTRK(buffer) {
    let reader = new DataView(buffer);
    let magic = reader.getUint32(0, true);
    if (magic !== 1128354388) {
      let raw;
      if (magic === 4247762216) {
        throw new Error("zstd TRK decompression is not supported");
      } else {
        raw = await NVUtilities.decompress(new Uint8Array(buffer));
      }
      buffer = raw.buffer;
      reader = new DataView(buffer);
      magic = reader.getUint32(0, true);
    }
    const vers = reader.getUint32(992, true);
    const hdr_sz = reader.getUint32(996, true);
    if (vers > 2 || hdr_sz !== 1e3 || magic !== 1128354388) {
      throw new Error("Not a valid TRK file");
    }
    const n_scalars = reader.getInt16(36, true);
    const dpv = [];
    for (let i2 = 0; i2 < n_scalars; i2++) {
      const arr = new Uint8Array(buffer.slice(38 + i2 * 20, 58 + i2 * 20));
      const str6 = new TextDecoder().decode(arr).split("\0").shift();
      dpv.push({
        id: str6.trim(),
        // TODO can we guarantee this?
        vals: []
      });
    }
    const voxel_sizeX = reader.getFloat32(12, true);
    const voxel_sizeY = reader.getFloat32(16, true);
    const voxel_sizeZ = reader.getFloat32(20, true);
    const zoomMat = mat4_exports.fromValues(
      1 / voxel_sizeX,
      0,
      0,
      -0.5,
      0,
      1 / voxel_sizeY,
      0,
      -0.5,
      0,
      0,
      1 / voxel_sizeZ,
      -0.5,
      0,
      0,
      0,
      1
    );
    const n_properties = reader.getInt16(238, true);
    const dps = [];
    for (let i2 = 0; i2 < n_properties; i2++) {
      const arr = new Uint8Array(buffer.slice(240 + i2 * 20, 260 + i2 * 20));
      const str6 = new TextDecoder().decode(arr).split("\0").shift();
      dps.push({
        id: str6.trim(),
        // TODO can we guarantee this?
        vals: []
      });
    }
    const mat = mat4_exports.create();
    for (let i2 = 0; i2 < 16; i2++) {
      mat[i2] = reader.getFloat32(440 + i2 * 4, true);
    }
    if (mat[15] === 0) {
      log.warn("TRK vox_to_ras not set");
      mat4_exports.identity(mat);
    }
    const vox2mmMat = mat4_exports.create();
    mat4_exports.mul(vox2mmMat, zoomMat, mat);
    let i322 = null;
    let f32 = null;
    i322 = new Int32Array(buffer.slice(hdr_sz));
    f32 = new Float32Array(i322.buffer);
    const ntracks = i322.length;
    if (ntracks < 1) {
      throw new Error("Empty TRK file.");
    }
    let i = 0;
    let npt = 0;
    let offsetPt0 = new Uint32Array(i322.length / 4);
    let noffset = 0;
    let pts = new Float32Array(i322.length);
    let npt3 = 0;
    while (i < ntracks) {
      const n_pts = i322[i];
      i = i + 1;
      offsetPt0[noffset++] = npt;
      for (let j = 0; j < n_pts; j++) {
        const ptx = f32[i + 0];
        const pty = f32[i + 1];
        const ptz = f32[i + 2];
        i += 3;
        pts[npt3++] = ptx * vox2mmMat[0] + pty * vox2mmMat[1] + ptz * vox2mmMat[2] + vox2mmMat[3];
        pts[npt3++] = ptx * vox2mmMat[4] + pty * vox2mmMat[5] + ptz * vox2mmMat[6] + vox2mmMat[7];
        pts[npt3++] = ptx * vox2mmMat[8] + pty * vox2mmMat[9] + ptz * vox2mmMat[10] + vox2mmMat[11];
        if (n_scalars > 0) {
          for (let s = 0; s < n_scalars; s++) {
            dpv[s].vals.push(f32[i]);
            i++;
          }
        }
        npt++;
      }
      if (n_properties > 0) {
        for (let j = 0; j < n_properties; j++) {
          dps[j].vals.push(f32[i]);
          i++;
        }
      }
    }
    const dps32 = [];
    for (let i2 = 0; i2 < dps.length; i2++) {
      dps32.push({
        id: dps[i2].id,
        vals: Float32Array.from(dps[i2].vals)
      });
    }
    const dpv32 = [];
    for (let i2 = 0; i2 < dpv.length; i2++) {
      dpv32.push({
        id: dpv[i2].id,
        vals: Float32Array.from(dpv[i2].vals)
      });
    }
    offsetPt0[noffset++] = npt;
    pts = pts.slice(0, npt3);
    offsetPt0 = offsetPt0.slice(0, noffset);
    return {
      pts,
      offsetPt0,
      dps: dps32,
      dpv: dpv32
    };
  }
  // readTRK()
  // read legacy VTK text format file
  static readTxtVTK(buffer) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const lines = txt.split("\n");
    const n = lines.length;
    if (n < 7 || !lines[0].startsWith("# vtk DataFile")) {
      throw new Error("Invalid VTK image");
    }
    if (!lines[2].startsWith("ASCII")) {
      throw new Error("Not ASCII VTK mesh");
    }
    let pos = 3;
    while (lines[pos].length < 1) {
      pos++;
    }
    if (!lines[pos].includes("POLYDATA")) {
      throw new Error("Not ASCII VTK polydata");
    }
    pos++;
    while (lines[pos].length < 1) {
      pos++;
    }
    if (!lines[pos].startsWith("POINTS")) {
      throw new Error("Not VTK POINTS");
    }
    let items = lines[pos].trim().split(/\s+/);
    const nvert = parseInt(items[1]);
    const nvert3 = nvert * 3;
    const positions = new Float32Array(nvert * 3);
    let v = 0;
    while (v < nvert * 3) {
      pos++;
      const str6 = lines[pos].trim();
      const pts = str6.trim().split(/\s+/);
      for (let i = 0; i < pts.length; i++) {
        if (v >= nvert3) {
          break;
        }
        positions[v] = parseFloat(pts[i]);
        v++;
      }
    }
    const tris = [];
    pos++;
    while (lines[pos].length < 1) {
      pos++;
    }
    if (lines[pos].startsWith("METADATA")) {
      while (lines[pos].length > 1) {
        pos++;
      }
      pos++;
    }
    items = lines[pos].trim().split(/\s+/);
    pos++;
    if (items[0].includes("LINES")) {
      const n_count = parseInt(items[1]);
      if (n_count < 1) {
        throw new Error("Corrupted VTK ASCII");
      }
      let str6 = lines[pos].trim();
      const offsetPt0 = [];
      let pts = [];
      if (str6.startsWith("OFFSETS")) {
        pos++;
        let c = 0;
        while (c < n_count) {
          str6 = lines[pos].trim();
          pos++;
          const items2 = str6.trim().split(/\s+/);
          for (let i = 0; i < items2.length; i++) {
            offsetPt0[c] = parseInt(items2[i]);
            c++;
            if (c >= n_count) {
              break;
            }
          }
        }
        pts = Array.from(positions);
      } else {
        let lineToInts = function() {
          str6 = lines[pos].trim();
          const items2 = str6.trim().split(/\s+/);
          asciiInts = [];
          for (let i = 0; i < items2.length; i++) {
            asciiInts.push(parseInt(items2[i]));
          }
          asciiIntsPos = 0;
          pos++;
        };
        let npt = 0;
        offsetPt0[0] = 0;
        let asciiInts = [];
        let asciiIntsPos = 0;
        lineToInts();
        for (let c = 0; c < n_count; c++) {
          if (asciiIntsPos >= asciiInts.length) {
            lineToInts();
          }
          const numPoints = asciiInts[asciiIntsPos++];
          npt += numPoints;
          offsetPt0[c + 1] = npt;
          for (let i = 0; i < numPoints; i++) {
            if (asciiIntsPos >= asciiInts.length) {
              lineToInts();
            }
            const idx = asciiInts[asciiIntsPos++] * 3;
            pts.push(positions[idx + 0]);
            pts.push(positions[idx + 1]);
            pts.push(positions[idx + 2]);
          }
        }
      }
      return {
        pts: Float32Array.from(pts),
        offsetPt0: Uint32Array.from(offsetPt0)
      };
    } else if (items[0].includes("TRIANGLE_STRIPS")) {
      const nstrip = parseInt(items[1]);
      for (let i = 0; i < nstrip; i++) {
        const str6 = lines[pos].trim();
        pos++;
        const vs = str6.trim().split(/\s+/);
        const ntri = parseInt(vs[0]) - 2;
        let k = 1;
        for (let t = 0; t < ntri; t++) {
          if (t % 2) {
            tris.push(parseInt(vs[k + 2]));
            tris.push(parseInt(vs[k + 1]));
            tris.push(parseInt(vs[k]));
          } else {
            tris.push(parseInt(vs[k]));
            tris.push(parseInt(vs[k + 1]));
            tris.push(parseInt(vs[k + 2]));
          }
          k += 1;
        }
      }
    } else if (items[0].includes("POLYGONS")) {
      const npoly = parseInt(items[1]);
      for (let i = 0; i < npoly; i++) {
        const str6 = lines[pos].trim();
        pos++;
        const vs = str6.trim().split(/\s+/);
        const ntri = parseInt(vs[0]) - 2;
        const fx = parseInt(vs[1]);
        let fy = parseInt(vs[2]);
        for (let t = 0; t < ntri; t++) {
          const fz = parseInt(vs[3 + t]);
          tris.push(fx);
          tris.push(fy);
          tris.push(fz);
          fy = fz;
        }
      }
    } else {
      throw new Error("Unsupported ASCII VTK datatype " + items[0]);
    }
    const indices = new Uint32Array(tris);
    return {
      positions,
      indices
    };
  }
  // readTxtVTK()
  // read mesh overlay to influence vertex colors
  static async readLayer(name = "", buffer, nvmesh, opacity = 0.5, colormap = "warm", colormapNegative = "winter", useNegativeCmap = false, cal_min = null, cal_max = null, outlineBorder = 0) {
    const layer = {
      ...NVMeshLayerDefaults,
      colormapInvert: false,
      colormapType: 0,
      // COLORMAP_TYPE.MIN_TO_MAX
      isTransparentBelowCalMin: true,
      isAdditiveBlend: false,
      colorbarVisible: true,
      colormapLabel: null
    };
    const isReadColortables = true;
    const re = /(?:\.([^.]+))?$/;
    let ext = re.exec(name)[1];
    ext = ext.toUpperCase();
    if (ext === "GZ") {
      ext = re.exec(name.slice(0, -3))[1];
      ext = ext.toUpperCase();
    }
    const n_vert = nvmesh.vertexCount / 3;
    if (nvmesh.offsetPt0) {
      if (ext !== "TSF") {
        throw new Error("readLayer for streamlines only supports TSF files.");
      }
      const npt = nvmesh.pts.length / 3;
      const splitResult = name.split("/");
      let tag = "Unknown";
      if (splitResult.length > 1) {
        const tag1 = splitResult.pop();
        if (tag1) {
          tag = tag.split(".").slice(0, -1).join(".");
        }
      }
      const vals = _NVMeshLoaders.readTSF(buffer, npt);
      if (!nvmesh.dpv) {
        nvmesh.dpv = [];
      }
      const mn2 = vals.reduce((acc, current) => Math.min(acc, current));
      const mx2 = vals.reduce((acc, current) => Math.max(acc, current));
      nvmesh.dpv.push({
        id: tag,
        vals: Float32Array.from(vals.slice()),
        global_min: mn2,
        global_max: mx2,
        cal_min: mn2,
        cal_max: mx2
      });
      return layer;
    }
    if (n_vert < 3) {
      log.error("n_vert < 3 in layer");
      return;
    }
    if (ext === "MZ3") {
      const obj = await _NVMeshLoaders.readMZ3(buffer, n_vert);
      layer.values = obj.scalars;
      if ("colormapLabel" in obj) {
        layer.colormapLabel = obj.colormapLabel;
      }
    } else if (ext === "ANNOT") {
      if (!isReadColortables) {
        layer.values = _NVMeshLoaders.readANNOT(buffer, n_vert);
      } else {
        const obj = _NVMeshLoaders.readANNOT(buffer, n_vert, true);
        if (!(obj instanceof Uint32Array)) {
          layer.values = obj.scalars;
          layer.colormapLabel = obj.colormapLabel;
        } else {
          layer.values = obj;
        }
      }
    } else if (ext === "CRV" || ext === "CURV" || ext === "THICKNESS" || ext === "AREA") {
      layer.values = _NVMeshLoaders.readCURV(buffer, n_vert);
      layer.isTransparentBelowCalMin = false;
    } else if (ext === "GII") {
      const obj = await _NVMeshLoaders.readGII(buffer, n_vert);
      layer.values = obj.scalars;
      layer.colormapLabel = obj.colormapLabel;
    } else if (ext === "MGH" || ext === "MGZ") {
      if (!isReadColortables) {
        layer.values = await _NVMeshLoaders.readMGH(buffer, n_vert);
      } else {
        const obj = await _NVMeshLoaders.readMGH(buffer, n_vert, true);
        if ("scalars" in obj) {
          layer.values = obj.scalars;
          layer.colormapLabel = obj.colormapLabel;
        } else {
          layer.values = obj;
        }
      }
    } else if (ext === "NII") {
      layer.values = await _NVMeshLoaders.readNII(buffer, n_vert, nvmesh.anatomicalStructurePrimary);
    } else if (ext === "SMP") {
      layer.values = await _NVMeshLoaders.readSMP(buffer, n_vert);
    } else if (ext === "STC") {
      layer.values = _NVMeshLoaders.readSTC(buffer, n_vert);
    } else if (_NVMeshLoaders.isCurv(buffer)) {
      layer.values = _NVMeshLoaders.readCURV(buffer, n_vert);
      layer.isTransparentBelowCalMin = false;
    } else {
      log.warn("Unknown layer overlay format " + name);
      return layer;
    }
    if (!layer.values) {
      log.error("no values in layer");
      return;
    }
    layer.nFrame4D = layer.values.length / n_vert;
    layer.frame4D = 0;
    layer.outlineBorder = outlineBorder;
    let mn = layer.values[0];
    let mx = layer.values[0];
    for (let i = 0; i < layer.values.length; i++) {
      mn = Math.min(mn, layer.values[i]);
      mx = Math.max(mx, layer.values[i]);
    }
    layer.global_min = mn;
    layer.global_max = mx;
    layer.cal_min = cal_min || 0;
    if (!cal_min) {
      layer.cal_min = mn;
    }
    layer.cal_max = cal_max || 0;
    if (!cal_max) {
      layer.cal_max = mx;
    }
    layer.cal_minNeg = NaN;
    layer.cal_maxNeg = NaN;
    layer.opacity = opacity;
    layer.colormap = colormap;
    layer.colormapNegative = colormapNegative;
    layer.useNegativeCmap = useNegativeCmap;
    return layer;
  }
  // readLayer()
  // read brainvoyager smp format file
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/40-the-format-of-smp-files
  static async readSMP(buffer, n_vert) {
    const len4 = buffer.byteLength;
    let reader = new DataView(buffer);
    let vers = reader.getUint16(0, true);
    if (vers > 5) {
      const raw = await NVUtilities.decompress(new Uint8Array(buffer));
      reader = new DataView(raw.buffer);
      vers = reader.getUint16(0, true);
      buffer = raw.buffer;
    }
    if (vers > 5) {
      log.error("Unsupported or invalid BrainVoyager SMP version " + vers);
    }
    const nvert = reader.getUint32(2, true);
    if (nvert !== n_vert) {
      log.error("SMP file has " + nvert + " vertices, background mesh has " + n_vert);
    }
    const nMaps = reader.getUint16(6, true);
    const scalars = new Float32Array(nvert * nMaps);
    const maps = [];
    let pos = 9;
    function readStr() {
      const startPos = pos;
      while (pos < len4 && reader.getUint8(pos) !== 0) {
        pos++;
      }
      pos++;
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    const _filenameSRF = readStr();
    for (let i = 0; i < nMaps; i++) {
      const m = {};
      m.mapType = reader.getUint32(pos, true);
      pos += 4;
      if (vers >= 3 && m.mapType === 3) {
        m.nLags = reader.getUint32(pos, true);
        pos += 4;
        m.mnLag = reader.getUint32(pos, true);
        pos += 4;
        m.mxLag = reader.getUint32(pos, true);
        pos += 4;
        m.ccOverlay = reader.getUint32(pos, true);
        pos += 4;
      }
      m.clusterSize = reader.getUint32(pos, true);
      pos += 4;
      m.clusterCheck = reader.getUint8(pos);
      pos += 1;
      m.critThresh = reader.getFloat32(pos, true);
      pos += 4;
      m.maxThresh = reader.getFloat32(pos, true);
      pos += 4;
      if (vers >= 4) {
        m.includeValuesGreaterThreshMax = reader.getUint32(pos, true);
        pos += 4;
      }
      m.df1 = reader.getUint32(pos, true);
      pos += 4;
      m.df2 = reader.getUint32(pos, true);
      pos += 4;
      if (vers >= 5) {
        m.posNegFlag = reader.getUint32(pos, true);
        pos += 4;
      } else {
        m.posNegFlag = 3;
      }
      m.cortexBonferroni = reader.getUint32(pos, true);
      pos += 4;
      m.posMinRGB = [0, 0, 0];
      m.posMaxRGB = [0, 0, 0];
      m.negMinRGB = [0, 0, 0];
      m.negMaxRGB = [0, 0, 0];
      if (vers >= 2) {
        m.posMinRGB[0] = reader.getUint8(pos);
        pos++;
        m.posMinRGB[1] = reader.getUint8(pos);
        pos++;
        m.posMinRGB[2] = reader.getUint8(pos);
        pos++;
        m.posMaxRGB[0] = reader.getUint8(pos);
        pos++;
        m.posMaxRGB[1] = reader.getUint8(pos);
        pos++;
        m.posMaxRGB[2] = reader.getUint8(pos);
        pos++;
        if (vers >= 4) {
          m.negMinRGB[0] = reader.getUint8(pos);
          pos++;
          m.negMinRGB[1] = reader.getUint8(pos);
          pos++;
          m.negMinRGB[2] = reader.getUint8(pos);
          pos++;
          m.negMaxRGB[0] = reader.getUint8(pos);
          pos++;
          m.negMaxRGB[1] = reader.getUint8(pos);
          pos++;
          m.negMaxRGB[2] = reader.getUint8(pos);
          pos++;
        }
        m.enableSMPColor = reader.getUint8(pos);
        pos++;
        if (vers >= 4) {
          m.lut = readStr();
        }
        m.colorAlpha = reader.getFloat32(pos, true);
        pos += 4;
      }
      m.name = readStr();
      const scalarsNew = new Float32Array(buffer, pos, nvert);
      scalars.set(scalarsNew, i * nvert);
      pos += nvert * 4;
      maps.push(m);
    }
    return scalars;
  }
  // readSMP()
  // read mne stc format file, not to be confused with brainvoyager stc format
  // https://github.com/mne-tools/mne-python/blob/main/mne/source_estimate.py#L211-L365
  static readSTC(buffer, n_vert) {
    const reader = new DataView(buffer);
    const n_vertex = reader.getInt32(8, false);
    if (n_vertex !== n_vert) {
      throw new Error("Overlay has " + n_vertex + " vertices, expected " + n_vert);
    }
    let pos = 12 + n_vertex * 4;
    const n_time = reader.getUint32(pos, false);
    pos += 4;
    const f32 = new Float32Array(n_time * n_vertex);
    for (let i = 0; i < n_time * n_vertex; i++) {
      f32[i] = reader.getFloat32(pos, false);
      pos += 4;
    }
    return f32;
  }
  // readSTC()
  static isCurv(buffer) {
    const view = new DataView(buffer);
    const sig0 = view.getUint8(0);
    const sig1 = view.getUint8(1);
    const sig2 = view.getUint8(2);
    if (sig0 !== 255 || sig1 !== 255 || sig2 !== 255) {
      utiltiesLogger.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");
      return false;
    }
    return true;
  }
  // read freesurfer curv big-endian format
  // https://github.com/bonilhamusclab/MRIcroS/blob/master/%2BfileUtils/%2Bpial/readPial.m
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm
  static readCURV(buffer, n_vert) {
    const view = new DataView(buffer);
    const sig0 = view.getUint8(0);
    const sig1 = view.getUint8(1);
    const sig2 = view.getUint8(2);
    const n_vertex = view.getUint32(3, false);
    const n_time = view.getUint32(11, false);
    if (sig0 !== 255 || sig1 !== 255 || sig2 !== 255) {
      utiltiesLogger.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");
    }
    if (n_vert !== n_vertex) {
      throw new Error("CURV file has different number of vertices ( " + n_vertex + ")than mesh (" + n_vert + ")");
    }
    if (buffer.byteLength < 15 + 4 * n_vertex * n_time) {
      throw new Error("CURV file smaller than specified");
    }
    const f32 = new Float32Array(n_time * n_vertex);
    let pos = 15;
    for (let i = 0; i < n_time * n_vertex; i++) {
      f32[i] = view.getFloat32(pos, false);
      pos += 4;
    }
    let mn = f32[0];
    let mx = f32[0];
    for (let i = 0; i < f32.length; i++) {
      mn = Math.min(mn, f32[i]);
      mx = Math.max(mx, f32[i]);
    }
    const scale6 = 1 / (mx - mn);
    for (let i = 0; i < f32.length; i++) {
      f32[i] = 1 - (f32[i] - mn) * scale6;
    }
    return f32;
  }
  // readCURV()
  // read freesurfer Annotation file provides vertex colors
  // https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles
  static readANNOT(buffer, n_vert, isReadColortables = false) {
    const view = new DataView(buffer);
    const n_vertex = view.getUint32(0, false);
    const n_vertexDecimated = this.decimateLayerVertices(n_vertex, n_vert);
    if (n_vert !== n_vertexDecimated) {
      throw new Error("ANNOT file has different number of vertices than mesh");
    }
    if (buffer.byteLength < 4 + 8 * n_vertex) {
      throw new Error("ANNOT file smaller than specified");
    }
    let pos = 0;
    const rgba32 = new Uint32Array(n_vertex);
    for (let i = 0; i < n_vertex; i++) {
      const idx = view.getUint32(pos += 4, false);
      rgba32[idx] = view.getUint32(pos += 4, false);
    }
    if (!isReadColortables) {
      return rgba32;
    }
    let tag = 0;
    try {
      tag = view.getInt32(pos += 4, false);
    } catch (error) {
      return rgba32;
    }
    const TAG_OLD_COLORTABLE = 1;
    if (tag !== TAG_OLD_COLORTABLE) {
      return rgba32;
    }
    const ctabversion = view.getInt32(pos += 4, false);
    if (ctabversion > 0) {
      return rgba32;
    }
    const maxstruc = view.getInt32(pos += 4, false);
    const len4 = view.getInt32(pos += 4, false);
    pos += len4;
    const num_entries = view.getInt32(pos += 4, false);
    if (num_entries < 1) {
      return rgba32;
    }
    const LUT4 = {
      R: Array(maxstruc).fill(0),
      G: Array(maxstruc).fill(0),
      B: Array(maxstruc).fill(0),
      A: Array(maxstruc).fill(0),
      I: Array(maxstruc).fill(0),
      labels: Array(maxstruc).fill("")
    };
    for (let i = 0; i < num_entries; i++) {
      const struc = view.getInt32(pos += 4, false);
      const labelLen = view.getInt32(pos += 4, false);
      pos += 4;
      let txt = "";
      for (let c = 0; c < labelLen; c++) {
        const val = view.getUint8(pos++);
        if (val === 0) {
          break;
        }
        txt += String.fromCharCode(val);
      }
      pos -= 4;
      const R = view.getInt32(pos += 4, false);
      const G = view.getInt32(pos += 4, false);
      const B = view.getInt32(pos += 4, false);
      const A = view.getInt32(pos += 4, false);
      if (struc < 0 || struc >= maxstruc) {
        log.warn("annot entry out of range");
        continue;
      }
      LUT4.R[struc] = R;
      LUT4.G[struc] = G;
      LUT4.B[struc] = B;
      LUT4.A[struc] = A;
      LUT4.I[struc] = (A << 24) + (B << 16) + (G << 8) + R;
      LUT4.labels[struc] = txt;
    }
    const scalars = new Float32Array(n_vertex);
    scalars.fill(-1);
    let nError = 0;
    for (let i = 0; i < n_vert; i++) {
      const RGB = rgba32[i];
      for (let c = 0; c < maxstruc; c++) {
        if (LUT4.I[c] === RGB) {
          scalars[i] = c;
          break;
        }
      }
      if (scalars[i] < 0) {
        nError++;
        scalars[i] = 0;
      }
    }
    if (nError > 0) {
      log.error(`annot vertex colors do not match ${nError} of ${n_vertex} vertices.`);
    }
    for (let i = 0; i < maxstruc; i++) {
      LUT4.I[i] = i;
    }
    const colormapLabel = cmapper.makeLabelLut(LUT4);
    return {
      scalars,
      colormapLabel
    };
  }
  // readANNOT()
  // read BrainNet viewer format
  // https://www.nitrc.org/projects/bnv/
  static readNV(buffer) {
    const len4 = buffer.byteLength;
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let nvert = 0;
    let ntri = 0;
    let v = 0;
    let t = 0;
    let positions;
    let indices;
    while (pos < len4) {
      const line = readStr();
      if (line.startsWith("#")) {
        continue;
      }
      const items = line.trim().split(/\s+/);
      if (nvert < 1) {
        nvert = parseInt(items[0]);
        positions = new Float32Array(nvert * 3);
        continue;
      }
      if (v < nvert * 3) {
        positions[v] = parseFloat(items[0]);
        positions[v + 1] = parseFloat(items[1]);
        positions[v + 2] = parseFloat(items[2]);
        v += 3;
        continue;
      }
      if (ntri < 1) {
        ntri = parseInt(items[0]);
        indices = new Uint32Array(ntri * 3);
        continue;
      }
      if (t >= ntri * 3) {
        break;
      }
      indices[t + 2] = parseInt(items[0]) - 1;
      indices[t + 1] = parseInt(items[1]) - 1;
      indices[t + 0] = parseInt(items[2]) - 1;
      t += 3;
    }
    return {
      positions,
      indices
    };
  }
  // readNV()
  // read ASCII Patch File format
  // https://afni.nimh.nih.gov/pub/dist/doc/htmldoc/demos/Bootcamp/CD.html#cd
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm
  static readASC(buffer) {
    const len4 = buffer.byteLength;
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.startsWith("#!ascii")) {
      log.warn("Invalid ASC mesh");
    }
    line = readStr();
    let items = line.trim().split(/\s+/);
    const nvert = parseInt(items[0]);
    const ntri = parseInt(items[1]);
    const positions = new Float32Array(nvert * 3);
    let j = 0;
    for (let i = 0; i < nvert; i++) {
      line = readStr();
      items = line.trim().split(/\s+/);
      positions[j] = parseFloat(items[0]);
      positions[j + 1] = parseFloat(items[1]);
      positions[j + 2] = parseFloat(items[2]);
      j += 3;
    }
    const indices = new Uint32Array(ntri * 3);
    j = 0;
    for (let i = 0; i < ntri; i++) {
      line = readStr();
      items = line.trim().split(/\s+/);
      indices[j] = parseInt(items[0]);
      indices[j + 1] = parseInt(items[1]);
      indices[j + 2] = parseInt(items[2]);
      j += 3;
    }
    return {
      positions,
      indices
    };
  }
  // readASC()
  // read legacy VTK format
  static readVTK(buffer) {
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be VTK: bytes = " + buffer.byteLength);
    }
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr(isSkipBlank = true) {
      if (isSkipBlank) {
        while (pos < len4 && bytes[pos] === 10) {
          pos++;
        }
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.startsWith("# vtk DataFile")) {
      throw new Error("Invalid VTK mesh");
    }
    line = readStr(false);
    line = readStr();
    if (line.startsWith("ASCII")) {
      return _NVMeshLoaders.readTxtVTK(buffer);
    } else if (!line.startsWith("BINARY")) {
      throw new Error("Invalid VTK image, expected ASCII or BINARY " + line);
    }
    line = readStr();
    if (!line.includes("POLYDATA")) {
      throw new Error("Only able to read VTK POLYDATA " + line);
    }
    line = readStr();
    if (!line.includes("POINTS") || !line.includes("double") && !line.includes("float")) {
      log.warn("Only able to read VTK float or double POINTS" + line);
    }
    const isFloat64 = line.includes("double");
    let items = line.trim().split(/\s+/);
    const nvert = parseInt(items[1]);
    const nvert3 = nvert * 3;
    const positions = new Float32Array(nvert3);
    const reader = new DataView(buffer);
    if (isFloat64) {
      for (let i = 0; i < nvert3; i++) {
        positions[i] = reader.getFloat64(pos, false);
        pos += 8;
      }
    } else {
      for (let i = 0; i < nvert3; i++) {
        positions[i] = reader.getFloat32(pos, false);
        pos += 4;
      }
    }
    line = readStr();
    items = line.trim().split(/\s+/);
    const tris = [];
    if (items[0].includes("LINES")) {
      const n_count = parseInt(items[1]);
      const posOK = pos;
      line = readStr();
      if (line.startsWith("OFFSETS")) {
        let isInt64 = false;
        if (line.includes("int64")) {
          isInt64 = true;
        }
        const offsetPt02 = new Uint32Array(n_count);
        if (isInt64) {
          let isOverflowInt32 = false;
          for (let c = 0; c < n_count; c++) {
            let idx = reader.getInt32(pos, false);
            if (idx !== 0) {
              isOverflowInt32 = true;
            }
            pos += 4;
            idx = reader.getInt32(pos, false);
            pos += 4;
            offsetPt02[c] = idx;
          }
          if (isOverflowInt32) {
            log.warn("int32 overflow: JavaScript does not support int64");
          }
        } else {
          for (let c = 0; c < n_count; c++) {
            const idx = reader.getInt32(pos, false);
            pos += 4;
            offsetPt02[c] = idx;
          }
        }
        const pts2 = positions;
        return {
          pts: pts2,
          offsetPt0: offsetPt02
        };
      }
      pos = posOK;
      let npt = 0;
      const offsetPt0 = [];
      const pts = [];
      offsetPt0.push(npt);
      for (let c = 0; c < n_count; c++) {
        const numPoints = reader.getInt32(pos, false);
        pos += 4;
        npt += numPoints;
        offsetPt0.push(npt);
        for (let i = 0; i < numPoints; i++) {
          const idx = reader.getInt32(pos, false) * 3;
          pos += 4;
          pts.push(positions[idx + 0]);
          pts.push(positions[idx + 1]);
          pts.push(positions[idx + 2]);
        }
      }
      return {
        pts: Float32Array.from(pts),
        offsetPt0: Uint32Array.from(offsetPt0)
      };
    } else if (items[0].includes("TRIANGLE_STRIPS")) {
      const nstrip = parseInt(items[1]);
      for (let i = 0; i < nstrip; i++) {
        const ntri = reader.getInt32(pos, false) - 2;
        pos += 4;
        for (let t = 0; t < ntri; t++) {
          if (t % 2) {
            tris.push(reader.getInt32(pos + 8, false));
            tris.push(reader.getInt32(pos + 4, false));
            tris.push(reader.getInt32(pos, false));
          } else {
            tris.push(reader.getInt32(pos, false));
            tris.push(reader.getInt32(pos + 4, false));
            tris.push(reader.getInt32(pos + 8, false));
          }
          pos += 4;
        }
        pos += 8;
      }
    } else if (items[0].includes("POLYGONS")) {
      const npoly = parseInt(items[1]);
      for (let i = 0; i < npoly; i++) {
        const ntri = reader.getInt32(pos, false) - 2;
        if (i === 0 && ntri > 65535) {
          throw new Error("Invalid VTK binary polygons using little-endian data (MRtrix)");
        }
        pos += 4;
        const fx = reader.getInt32(pos, false);
        pos += 4;
        let fy = reader.getInt32(pos, false);
        pos += 4;
        for (let t = 0; t < ntri; t++) {
          const fz = reader.getInt32(pos, false);
          pos += 4;
          tris.push(fx);
          tris.push(fy);
          tris.push(fz);
          fy = fz;
        }
      }
    } else {
      throw new Error("Unsupported binary VTK datatype " + items[0]);
    }
    const indices = new Uint32Array(tris);
    return {
      positions,
      indices
    };
  }
  // readVTK()
  static readWRL(buffer) {
    const wrlText = new TextDecoder("utf-8").decode(buffer);
    const coordRegex = /coord\s+Coordinate\s*\{\s*point\s*\[([\s\S]*?)\]/;
    const indexRegex = /coordIndex\s*\[([\s\S]*?)\]/;
    const colorRegex = /color\s+Color\s*\{\s*color\s*\[([\s\S]*?)\]/;
    const coordMatch = coordRegex.exec(wrlText);
    const indexMatch = indexRegex.exec(wrlText);
    const colorMatch = colorRegex.exec(wrlText);
    if (!coordMatch || !indexMatch) {
      throw new Error("Invalid WRL file: Could not find vertices or indices.");
    }
    const positions = new Float32Array(
      coordMatch[1].trim().split(/[\s,]+/).map(Number)
    );
    let colors = null;
    if (colorMatch) {
      colors = new Float32Array(
        colorMatch[1].trim().split(/[\s,]+/).map(Number)
      );
      const nVert = positions.length / 3;
      if (colors.length !== nVert * 3) {
        console.warn(`Unexpected color count: expected ${nVert * 3}, got ${colors.length}`);
        colors = null;
      }
    }
    const indices = new Uint32Array(
      indexMatch[1].trim().split(/[\s,]+/).map(Number).filter((v) => v !== -1)
    );
    return { positions, indices, colors };
  }
  // readWRL()
  // read brainsuite DFS format
  // http://brainsuite.org/formats/dfs/
  static readDFS(buffer) {
    const reader = new DataView(buffer);
    const magic = reader.getUint32(0, true);
    const LE = reader.getUint16(4, true);
    if (magic !== 1599292996 || LE !== 17740) {
      log.warn("Not a little-endian brainsuite DFS mesh");
    }
    const hdrBytes = reader.getUint32(12, true);
    const nface = reader.getUint32(24, true);
    const nvert = reader.getUint32(28, true);
    const vcoffset = reader.getUint32(48, true);
    let pos = hdrBytes;
    const indices = new Uint32Array(buffer, pos, nface * 3);
    pos += nface * 3 * 4;
    const positions = new Float32Array(buffer, pos, nvert * 3);
    for (let i = 0; i < nvert * 3; i += 3) {
      const tmp = positions[i];
      positions[i] = positions[i + 1];
      positions[i + 1] = tmp;
    }
    let colors;
    if (vcoffset >= 0) {
      colors = new Float32Array(buffer, vcoffset, nvert * 3);
    }
    return {
      positions,
      indices,
      colors
    };
  }
  // read surfice MZ3 format
  // https://github.com/neurolabusc/surf-ice/tree/master/mz3
  static async readMZ3(buffer, n_vert = 0) {
    if (buffer.byteLength < 20) {
      throw new Error("File too small to be mz3: bytes = " + buffer.byteLength);
    }
    let reader = new DataView(buffer);
    let magic = reader.getUint16(0, true);
    let _buffer = buffer;
    if (magic === 35615 || magic === 8075) {
      const raw = await NVUtilities.decompress(new Uint8Array(buffer));
      reader = new DataView(raw.buffer);
      magic = reader.getUint16(0, true);
      _buffer = raw.buffer;
    }
    const attr = reader.getUint16(2, true);
    const nface = reader.getUint32(4, true);
    let nvert = reader.getUint32(8, true);
    const nskip = reader.getUint32(12, true);
    utiltiesLogger.debug("MZ3 magic %d attr %d face %d vert %d skip %d", magic, attr, nface, nvert, nskip);
    if (magic !== 23117) {
      throw new Error("Invalid MZ3 file");
    }
    const isFace = (attr & 1) !== 0;
    const isVert = (attr & 2) !== 0;
    const isRGBA = (attr & 4) !== 0;
    let isSCALAR = (attr & 8) !== 0;
    const isDOUBLE = (attr & 16) !== 0;
    if (attr > 63) {
      throw new Error("Unsupported future version of MZ3 file");
    }
    let bytesPerScalar = 4;
    if (isDOUBLE) {
      bytesPerScalar = 8;
    }
    let NSCALAR = 0;
    if (n_vert > 0 && !isFace && nface < 1 && !isRGBA) {
      isSCALAR = true;
    }
    if (isSCALAR) {
      let nv = n_vert;
      if (n_vert === 0) {
        nv = nvert;
      }
      const FSizeWoScalars = 16 + nskip + (isFace ? 1 : 0) * nface * 12 + (isVert ? 1 : 0) * nv * 12 + (isRGBA ? 1 : 0) * nv * 4;
      const scalarFloats = Math.floor((_buffer.byteLength - FSizeWoScalars) / bytesPerScalar);
      if (nvert !== n_vert && scalarFloats % n_vert === 0) {
        log.warn("Issue 729: mz3 mismatch scalar NVERT does not match mesh NVERT");
        nvert = n_vert;
      }
      NSCALAR = Math.floor(scalarFloats / nvert);
      if (NSCALAR < 1) {
        log.warn("Corrupt MZ3: file reports NSCALAR but not enough bytes");
        isSCALAR = false;
      }
    }
    if (nvert < 3 && n_vert < 3) {
      throw new Error("Not a mesh MZ3 file (maybe scalar)");
    }
    if (n_vert > 0 && n_vert !== nvert) {
      log.warn("Layer has " + nvert + "vertices, but background mesh has " + n_vert);
    }
    let filepos = 16 + nskip;
    let indices = null;
    if (isFace) {
      indices = new Uint32Array(_buffer, filepos, nface * 3);
      filepos += nface * 3 * 4;
    }
    let positions = null;
    if (isVert) {
      positions = new Float32Array(_buffer, filepos, nvert * 3);
      filepos += nvert * 3 * 4;
    }
    let colors = null;
    if (isRGBA) {
      colors = new Float32Array(nvert * 3);
      const rgba8 = new Uint8Array(_buffer, filepos, nvert * 4);
      filepos += nvert * 4;
      let k3 = 0;
      let k4 = 0;
      for (let i = 0; i < nvert; i++) {
        for (let j = 0; j < 3; j++) {
          colors[k3] = rgba8[k4] / 255;
          k3++;
          k4++;
        }
        k4++;
      }
    }
    let scalars = new Float32Array();
    if ((!isRGBA || n_vert > 0) && isSCALAR && NSCALAR > 0) {
      if (isDOUBLE) {
        const flt64 = new Float64Array(_buffer, filepos, NSCALAR * nvert);
        scalars = Float32Array.from(flt64);
      } else {
        scalars = new Float32Array(_buffer, filepos, NSCALAR * nvert);
      }
      filepos += bytesPerScalar * NSCALAR * nvert;
    }
    if (n_vert > 0 && isRGBA && isSCALAR) {
      let mx = scalars[0];
      for (let i = 0; i < nvert; i++) {
        mx = Math.max(mx, scalars[i]);
      }
      const Labels = { R: [], G: [], B: [], A: [], I: [], labels: [] };
      for (let i = 0; i <= mx; i++) {
        for (let v = 0; v < nvert; v++) {
          if (i === scalars[v]) {
            const v3 = v * 3;
            Labels.I.push(i);
            Labels.R.push(colors[v3] * 255);
            Labels.G.push(colors[v3 + 1] * 255);
            Labels.B.push(colors[v3 + 2] * 255);
            Labels.A.push(255);
            Labels.labels.push(`${i}`);
            break;
          }
        }
      }
      const colormapLabel = cmapper.makeLabelLut(Labels);
      return {
        scalars,
        colormapLabel
      };
    }
    if (n_vert > 0) {
      return {
        scalars
      };
    }
    return {
      positions,
      indices,
      scalars,
      colors
    };
  }
  // readMZ3()
  // read PLY format
  // https://en.wikipedia.org/wiki/PLY_(file_format)
  static readPLY(buffer) {
    const len4 = buffer.byteLength;
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.startsWith("ply")) {
      throw new Error("Not a valid PLY file");
    }
    line = readStr();
    const isAscii = line.includes("ascii");
    function dataTypeBytes(str6) {
      if (str6 === "char" || str6 === "uchar" || str6 === "int8" || str6 === "uint8") {
        return 1;
      }
      if (str6 === "short" || str6 === "ushort" || str6 === "int16" || str6 === "uint16") {
        return 2;
      }
      if (str6 === "int" || str6 === "uint" || str6 === "int32" || str6 === "uint32" || str6 === "float" || str6 === "float32") {
        return 4;
      }
      if (str6 === "double") {
        return 8;
      }
      throw new Error("Unknown data type: " + str6);
    }
    const isLittleEndian = line.includes("binary_little_endian");
    let nvert = 0;
    let vertIsDouble = false;
    let vertStride = 0;
    let indexStrideBytes = 0;
    let indexCountBytes = 0;
    let indexBytes = 0;
    let indexPaddingBytes = 0;
    let nIndexPadding = 0;
    let nface = 0;
    while (pos < len4 && !line.startsWith("end_header")) {
      line = readStr();
      if (line.startsWith("comment")) {
        continue;
      }
      let items = line.split(/\s/);
      if (line.startsWith("element vertex")) {
        nvert = parseInt(items[items.length - 1]);
        line = readStr();
        items = line.split(/\s/);
        while (line.startsWith("property")) {
          const datatype = items[1];
          if (items[2] === "x" && datatype.startsWith("double")) {
            vertIsDouble = true;
          } else if (items[2] === "x" && !datatype.startsWith("float")) {
            log.error("Error: expect ply xyz to be float or double: " + line);
          }
          vertStride += dataTypeBytes(datatype);
          line = readStr();
          items = line.split(/\s/);
        }
      }
      if (line.startsWith("element face")) {
        nface = parseInt(items[items.length - 1]);
        line = readStr();
        items = line.split(/\s/);
        while (line.startsWith("property")) {
          if (items[1] === "list") {
            indexCountBytes = dataTypeBytes(items[2]);
            indexBytes = dataTypeBytes(items[3]);
            indexStrideBytes += indexCountBytes + 3 * indexBytes;
          } else {
            const bytes2 = dataTypeBytes(items[1]);
            indexStrideBytes += bytes2;
            if (indexBytes === 0) {
              indexPaddingBytes += bytes2;
              nIndexPadding++;
            }
          }
          line = readStr();
          items = line.split(/\s/);
        }
      }
    }
    if (isAscii) {
      if (nface < 1) {
        log.error(`Malformed ply format: faces ${nface} `);
      }
      const positions2 = new Float32Array(nvert * 3);
      let v = 0;
      for (let i = 0; i < nvert; i++) {
        line = readStr();
        const items = line.split(/\s/);
        positions2[v] = parseFloat(items[0]);
        positions2[v + 1] = parseFloat(items[1]);
        positions2[v + 2] = parseFloat(items[2]);
        v += 3;
      }
      let indices2 = new Uint32Array(nface * 3);
      let f = 0;
      for (let i = 0; i < nface; i++) {
        line = readStr();
        const items = line.split(/\s/);
        const nTri = parseInt(items[nIndexPadding]) - 2;
        if (nTri < 1) {
          break;
        }
        if (f + nTri * 3 > indices2.length) {
          const c = new Uint32Array(indices2.length + indices2.length);
          c.set(indices2);
          indices2 = c.slice();
        }
        const idx0 = parseInt(items[nIndexPadding + 1]);
        let idx1 = parseInt(items[nIndexPadding + 2]);
        for (let j2 = 0; j2 < nTri; j2++) {
          const idx2 = parseInt(items[nIndexPadding + 3 + j2]);
          indices2[f + 0] = idx0;
          indices2[f + 1] = idx1;
          indices2[f + 2] = idx2;
          idx1 = idx2;
          f += 3;
        }
      }
      if (indices2.length !== f) {
        indices2 = indices2.slice(0, f);
      }
      return {
        positions: positions2,
        indices: indices2
      };
    }
    if (vertStride < 12 || indexCountBytes < 1 || indexBytes < 1 || nface < 1) {
      log.warn(
        `Malformed ply format: stride ${vertStride} count ${indexCountBytes} iBytes ${indexBytes} iStrideBytes ${indexStrideBytes} iPadBytes ${indexPaddingBytes} faces ${nface}`
      );
    }
    const reader = new DataView(buffer);
    let positions;
    if (pos % 4 === 0 && vertStride === 12 && isLittleEndian) {
      positions = new Float32Array(buffer, pos, nvert * 3);
      pos += nvert * vertStride;
    } else {
      positions = new Float32Array(nvert * 3);
      let v = 0;
      for (let i = 0; i < nvert; i++) {
        if (vertIsDouble) {
          positions[v] = reader.getFloat64(pos, isLittleEndian);
          positions[v + 1] = reader.getFloat64(pos + 8, isLittleEndian);
          positions[v + 2] = reader.getFloat64(pos + 16, isLittleEndian);
        } else {
          positions[v] = reader.getFloat32(pos, isLittleEndian);
          positions[v + 1] = reader.getFloat32(pos + 4, isLittleEndian);
          positions[v + 2] = reader.getFloat32(pos + 8, isLittleEndian);
        }
        v += 3;
        pos += vertStride;
      }
    }
    const indices = new Uint32Array(nface * 3);
    let isTriangular = true;
    let j = 0;
    if (indexCountBytes === 1 && indexBytes === 4 && indexStrideBytes === 13) {
      for (let i = 0; i < nface; i++) {
        const nIdx = reader.getUint8(pos);
        pos += indexCountBytes;
        if (nIdx !== 3) {
          isTriangular = false;
        }
        indices[j] = reader.getUint32(pos, isLittleEndian);
        pos += 4;
        indices[j + 1] = reader.getUint32(pos, isLittleEndian);
        pos += 4;
        indices[j + 2] = reader.getUint32(pos, isLittleEndian);
        pos += 4;
        j += 3;
      }
    } else {
      let startPos = pos;
      for (let i = 0; i < nface; i++) {
        pos = startPos + indexPaddingBytes;
        let nIdx = 0;
        if (indexCountBytes === 1) {
          nIdx = reader.getUint8(pos);
        } else if (indexCountBytes === 2) {
          nIdx = reader.getUint16(pos, isLittleEndian);
        } else if (indexCountBytes === 4) {
          nIdx = reader.getUint32(pos, isLittleEndian);
        }
        pos += indexCountBytes;
        if (nIdx !== 3) {
          isTriangular = false;
        }
        for (let k = 0; k < 3; k++) {
          if (indexBytes === 1) {
            indices[j] = reader.getUint8(pos);
          } else if (indexBytes === 2) {
            indices[j] = reader.getUint16(pos, isLittleEndian);
          } else if (indexBytes === 4) {
            indices[j] = reader.getUint32(pos, isLittleEndian);
          }
          j++;
          pos += indexBytes;
        }
        startPos += indexStrideBytes;
      }
    }
    if (!isTriangular) {
      log.warn("Only able to read PLY meshes limited to triangles.");
    }
    return {
      positions,
      indices
    };
  }
  // readPLY()
  // FreeSurfer can convert meshes to ICO/TRI format text files
  // https://github.com/dfsp-spirit/freesurferformats/blob/434962608108c75d4337d5e7a5096e3bd4ee6ee6/R/read_fs_surface.R#L1090
  // detect TRI format that uses same extension
  // http://paulbourke.net/dataformats/tri/
  static readICO(buffer) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const lines = txt.split("\n");
    let header = lines[0].trim().split(/\s+/);
    if (header.length > 1) {
      log.warn("This is not a valid FreeSurfer ICO/TRI mesh.");
    }
    const num_v = parseInt(header[0]);
    const positions = new Float32Array(num_v * 3);
    let line = 1;
    for (let i = 0; i < num_v; i++) {
      const items = lines[line].trim().split(/\s+/);
      line++;
      let idx = parseInt(items[0]) - 1;
      const x = parseFloat(items[1]);
      const y = parseFloat(items[2]);
      const z = parseFloat(items[3]);
      if (idx < 0 || idx >= num_v) {
        log.error("ICO vertices corrupted");
        break;
      }
      idx *= 3;
      positions[idx] = x;
      positions[idx + 1] = y;
      positions[idx + 2] = z;
    }
    header = lines[line].trim().split(/\s+/);
    line++;
    const num_f = parseInt(header[0]);
    const indices = new Uint32Array(num_f * 3);
    for (let i = 0; i < num_f; i++) {
      const items = lines[line].trim().split(/\s+/);
      line++;
      let idx = parseInt(items[0]) - 1;
      const x = parseInt(items[1]) - 1;
      const y = parseInt(items[2]) - 1;
      const z = parseInt(items[3]) - 1;
      if (idx < 0 || idx >= num_f) {
        log.error("ICO indices corrupted");
        break;
      }
      idx *= 3;
      indices[idx] = x;
      indices[idx + 1] = y;
      indices[idx + 2] = z;
    }
    for (let j = 0; j < indices.length; j += 3) {
      const tri = indices[j];
      indices[j] = indices[j + 1];
      indices[j + 1] = tri;
    }
    return {
      positions,
      indices
    };
  }
  // readICO()
  // While BYU and FreeSurfer GEO are related
  // - BYU can have multiple parts
  // - BYU faces not always triangular
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm#GeoFile
  // http://www.eg-models.de/formats/Format_Byu.html
  // https://github.com/dfsp-spirit/freesurferformats/blob/dafaf88a601dac90fa3c9aae4432f003f5344546/R/read_fs_surface.R#L924
  // https://github.com/dfsp-spirit/freesurferformats/blob/434962608108c75d4337d5e7a5096e3bd4ee6ee6/R/read_fs_surface.R#L1144
  // n.b. AFNI uses the '.g' extension for this format 'ConvertSurface  -i_gii L.surf.gii -o_byu L'
  static readGEO(buffer, isFlipWinding = false) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const lines = txt.split("\n");
    const header = lines[0].trim().split(/\s+/);
    const num_p = parseInt(header[0]);
    let num_v = parseInt(header[1]);
    let num_f = parseInt(header[2]);
    const num_c = parseInt(header[3]);
    if (num_p > 1 || num_c !== num_f * 3) {
      log.warn("Multi-part BYU/GEO header or not a triangular mesh.");
    }
    const pts = [];
    num_v *= 3;
    let v = 0;
    let line = 2;
    while (v < num_v) {
      const items = lines[line].trim().split(/\s+/);
      line++;
      for (let i = 0; i < items.length; i++) {
        pts.push(parseFloat(items[i]));
        v++;
        if (v >= num_v) {
          break;
        }
      }
    }
    const t = [];
    num_f *= 3;
    let f = 0;
    while (f < num_f) {
      const items = lines[line].trim().split(/\s+/);
      line++;
      for (let i = 0; i < items.length; i++) {
        t.push(Math.abs(parseInt(items[i])) - 1);
        f++;
        if (f >= num_f) {
          break;
        }
      }
    }
    if (isFlipWinding) {
      for (let j = 0; j < t.length; j += 3) {
        const tri = t[j];
        t[j] = t[j + 1];
        t[j + 1] = tri;
      }
    }
    const positions = new Float32Array(pts);
    const indices = new Uint32Array(t);
    return {
      positions,
      indices
    };
  }
  // readGEO()
  // read OFF format
  // https://en.wikipedia.org/wiki/OFF_(file_format)
  static readOFF(buffer) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const lines = txt.split("\n");
    const pts = [];
    const t = [];
    let i = 0;
    if (!lines[i].includes("OFF")) {
      log.warn("File does not start with OFF");
    } else {
      i++;
    }
    let items = lines[i].trim().split(/\s+/);
    const num_v = parseInt(items[0]);
    const num_f = parseInt(items[1]);
    i++;
    for (let j = 0; j < num_v; j++) {
      const str6 = lines[i];
      items = str6.trim().split(/\s+/);
      pts.push(parseFloat(items[0]));
      pts.push(parseFloat(items[1]));
      pts.push(parseFloat(items[2]));
      i++;
    }
    for (let j = 0; j < num_f; j++) {
      const str6 = lines[i];
      items = str6.trim().split(/\s+/);
      const n = parseInt(items[0]);
      if (n !== 3) {
        log.warn("Only able to read OFF files with triangular meshes");
      }
      t.push(parseInt(items[1]));
      t.push(parseInt(items[2]));
      t.push(parseInt(items[3]));
      i++;
    }
    const positions = new Float32Array(pts);
    const indices = new Uint32Array(t);
    return {
      positions,
      indices
    };
  }
  // readOFF()
  static readOBJMNI(buffer) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const items = txt.trim().split(/\s*,\s*|\s+/);
    if (items.length < 1 || items[0] !== "P") {
      log.warn("This is not a valid MNI OBJ mesh.");
    }
    let j = 6;
    const nVert = parseInt(items[j++]);
    const nVertX3 = nVert * 3;
    const positions = new Float32Array(nVertX3);
    for (let i = 0; i < nVertX3; i++) {
      positions[i] = parseFloat(items[j++]);
    }
    j += nVertX3;
    const nTri = parseInt(items[j++]);
    const colour_flag = parseInt(items[j++]);
    if (nTri < 1 || colour_flag < 0 || colour_flag > 2) {
      log.warn("This is not a valid MNI OBJ mesh.");
    }
    let num_c = 1;
    if (colour_flag === 1) {
      num_c = nTri;
    } else if (colour_flag === 1) {
      num_c = nVert;
    }
    j += num_c * 4;
    j += nTri;
    const nTriX3 = nTri * 3;
    const indices = new Uint32Array(nTriX3);
    for (let i = 0; i < nTriX3; i++) {
      indices[i] = parseInt(items[j++]);
    }
    return {
      positions,
      indices
    };
  }
  // readOBJMNI()
  static async readOBJ(buffer) {
    const headerBytes = new Uint8Array(buffer, 0, 2);
    if (headerBytes[0] === 31 && headerBytes[1] === 139) {
      buffer = await NVUtilities.decompressToBuffer(new Uint8Array(buffer));
    }
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    if (txt[0] === "P") {
      return this.readOBJMNI(buffer);
    }
    const lines = txt.split("\n");
    const n = lines.length;
    const pts = [];
    const tris = [];
    for (let i = 0; i < n; i++) {
      const str6 = lines[i];
      if (str6[0] === "v" && str6[1] === " ") {
        const items = str6.trim().split(/\s+/);
        pts.push(parseFloat(items[1]));
        pts.push(parseFloat(items[2]));
        pts.push(parseFloat(items[3]));
      }
      if (str6[0] === "f") {
        const items = str6.trim().split(/\s+/);
        const new_t = items.length - 3;
        if (new_t < 1) {
          break;
        }
        let tn = items[1].split("/");
        const t0 = parseInt(tn[0]) - 1;
        tn = items[2].split("/");
        let tprev = parseInt(tn[0]) - 1;
        for (let j = 0; j < new_t; j++) {
          tn = items[3 + j].split("/");
          const tcurr = parseInt(tn[0]) - 1;
          tris.push(t0);
          tris.push(tprev);
          tris.push(tcurr);
          tprev = tcurr;
        }
      }
    }
    const positions = new Float32Array(pts);
    const indices = new Uint32Array(tris);
    let min4 = indices[0];
    let max5 = indices[0];
    for (let i = 1; i < indices.length; i++) {
      if (indices[i] < min4) {
        min4 = indices[i];
      }
      if (indices[i] > max5) {
        max5 = indices[i];
      }
    }
    if (max5 - min4 + 1 > positions.length / 3) {
      throw new Error("Not a valid OBJ file");
    }
    for (let i = 0; i < indices.length; i++) {
      indices[i] -= min4;
    }
    return {
      positions,
      indices
    };
  }
  // readOBJ()
  // read FreeSurfer big endian format
  static readFreeSurfer(buffer) {
    const bytes = new Uint8Array(buffer);
    if (bytes[0] === 35 && bytes[1] === 33 && bytes[2] === 97) {
      return _NVMeshLoaders.readASC(buffer);
    }
    const view = new DataView(buffer);
    const sig0 = view.getUint32(0, false);
    const sig1 = view.getUint32(4, false);
    if (sig0 !== 4294966883 || sig1 !== 1919246708) {
      utiltiesLogger.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");
    }
    let offset = 0;
    while (view.getUint8(offset) !== 10) {
      offset++;
    }
    offset += 2;
    let nv = view.getUint32(offset, false);
    offset += 4;
    let nf = view.getUint32(offset, false);
    offset += 4;
    nv *= 3;
    const positions = new Float32Array(nv);
    for (let i = 0; i < nv; i++) {
      positions[i] = view.getFloat32(offset, false);
      offset += 4;
    }
    nf *= 3;
    const indices = new Uint32Array(nf);
    for (let i = 0; i < nf; i++) {
      indices[i] = view.getUint32(offset, false);
      offset += 4;
    }
    const head0 = view.getUint32(offset, false);
    offset += 4;
    let isHeadOK = head0 === 20;
    if (!isHeadOK) {
      const head1 = view.getUint32(offset, false);
      offset += 4;
      const head2 = view.getUint32(offset, false);
      offset += 4;
      isHeadOK = head0 === 2 && head1 === 0 && head2 === 20;
    }
    if (!isHeadOK) {
      log.warn("Unknown FreeSurfer Mesh extension code.");
    } else {
      const footer = new TextDecoder().decode(buffer.slice(offset)).trim();
      const strings = footer.split("\n");
      for (let s = 0; s < strings.length; s++) {
        if (!strings[s].startsWith("cras")) {
          continue;
        }
        const cras = strings[s].split("=")[1].trim();
        const FreeSurferTranlate = cras.split(" ").map(Number);
        const nvert = Math.floor(positions.length / 3);
        let i = 0;
        for (let v = 0; v < nvert; v++) {
          positions[i] += FreeSurferTranlate[0];
          i++;
          positions[i] += FreeSurferTranlate[1];
          i++;
          positions[i] += FreeSurferTranlate[2];
          i++;
        }
      }
    }
    return {
      positions,
      indices
    };
  }
  // readFreeSurfer()
  // read brainvoyager SRF format
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/344-users-guide-2-3-the-format-of-srf-files
  static async readSRF(buffer) {
    const bytes = new Uint8Array(buffer);
    if (bytes[0] === 35 && bytes[1] === 33 && bytes[2] === 97) {
      return _NVMeshLoaders.readASC(buffer);
    }
    if (bytes[0] === 31 && bytes[1] === 139) {
      const raw = await NVUtilities.decompress(new Uint8Array(buffer));
      buffer = raw.buffer;
    }
    const reader = new DataView(buffer);
    const ver = reader.getFloat32(0, true);
    const nVert = reader.getUint32(8, true);
    const nTri = reader.getUint32(12, true);
    const oriX = reader.getFloat32(16, true);
    const oriY = reader.getFloat32(20, true);
    const oriZ = reader.getFloat32(24, true);
    const positions = new Float32Array(nVert * 3);
    let pos = 28;
    let j = 1;
    for (let i = 0; i < nVert; i++) {
      positions[j] = -reader.getFloat32(pos, true) + oriX;
      j += 3;
      pos += 4;
    }
    j = 2;
    for (let i = 0; i < nVert; i++) {
      positions[j] = -reader.getFloat32(pos, true) + oriY;
      j += 3;
      pos += 4;
    }
    j = 0;
    for (let i = 0; i < nVert; i++) {
      positions[j] = -reader.getFloat32(pos, true) + oriZ;
      j += 3;
      pos += 4;
    }
    pos = 28 + 4 * 6 * nVert;
    const rVex = reader.getFloat32(pos, true);
    const gVex = reader.getFloat32(pos + 4, true);
    const bVex = reader.getFloat32(pos + 8, true);
    const rCave = reader.getFloat32(pos + 16, true);
    const gCave = reader.getFloat32(pos + 20, true);
    const bCave = reader.getFloat32(pos + 24, true);
    pos += 8 * 4;
    const colors = new Float32Array(nVert * 3);
    const colorsIdx = new Uint32Array(buffer, pos, nVert);
    j = 0;
    for (let i = 0; i < nVert; i++) {
      const c = colorsIdx[i];
      if (c > 1056964608) {
        colors[j + 0] = (c >> 16 & 255) / 255;
        colors[j + 1] = (c >> 8 & 255) / 255;
        colors[j + 2] = (c & 255) / 255;
      }
      if (c === 0) {
        colors[j + 0] = rVex;
        colors[j + 1] = gVex;
        colors[j + 2] = bVex;
      }
      if (c === 1) {
        colors[j + 0] = rCave;
        colors[j + 1] = gCave;
        colors[j + 2] = bCave;
      }
      j += 3;
    }
    pos += nVert * 4;
    for (let i = 0; i < nVert; i++) {
      const nNearest = reader.getUint32(pos, true);
      pos += 4 + 4 * nNearest;
    }
    const indices = new Uint32Array(nTri * 3);
    for (let i = 0; i < nTri * 3; i++) {
      indices[i] = reader.getInt32(pos, true);
      pos += 4;
    }
    if (ver !== 4) {
      log.warn("Not valid SRF");
    }
    return {
      positions,
      indices,
      colors
    };
  }
  // readSRF()
  // read STL ASCII format file
  // http://paulbourke.net/dataformats/stl/
  static readTxtSTL(buffer) {
    const enc = new TextDecoder("utf-8");
    const txt = enc.decode(buffer);
    const lines = txt.split("\n");
    if (!lines[0].startsWith("solid")) {
      throw new Error("Not a valid STL file");
    }
    const pts = [];
    for (let i = 1; i < lines.length; i++) {
      if (!lines[i].includes("vertex")) {
        continue;
      }
      const items = lines[i].trim().split(/\s+/);
      for (let j = 1; j < items.length; j++) {
        pts.push(parseFloat(items[j]));
      }
    }
    const npts = Math.floor(pts.length / 3);
    if (npts * 3 !== pts.length) {
      throw new Error("Unable to parse ASCII STL file.");
    }
    const positions = new Float32Array(pts);
    const indices = new Uint32Array(npts);
    for (let i = 0; i < npts; i++) {
      indices[i] = i;
    }
    return {
      positions,
      indices
    };
  }
  // readTxtSTL()
  // read STL format, nb this format does not reuse vertices
  // https://en.wikipedia.org/wiki/STL_(file_format)
  static readSTL(buffer) {
    if (buffer.byteLength < 80 + 4 + 50) {
      throw new Error("File too small to be STL: bytes = " + buffer.byteLength);
    }
    const reader = new DataView(buffer);
    const sig = reader.getUint32(0, true);
    if (sig === 1768714099) {
      return _NVMeshLoaders.readTxtSTL(buffer);
    }
    const ntri = reader.getUint32(80, true);
    const ntri3 = 3 * ntri;
    if (buffer.byteLength < 80 + 4 + ntri * 50) {
      throw new Error("STL file too small to store triangles = " + ntri);
    }
    const indices = new Uint32Array(ntri3);
    const positions = new Float32Array(ntri3 * 3);
    let pos = 80 + 4 + 12;
    let v = 0;
    for (let i = 0; i < ntri; i++) {
      for (let j = 0; j < 9; j++) {
        positions[v] = reader.getFloat32(pos, true);
        v += 1;
        pos += 4;
      }
      pos += 14;
    }
    for (let i = 0; i < ntri3; i++) {
      indices[i] = i;
    }
    return {
      positions,
      indices
    };
  }
  // readSTL()
  static decimateLayerVertices(nVertLayer, nVertMesh) {
    if (nVertLayer % nVertMesh === 0) {
      return nVertLayer;
    }
    const V0 = 12;
    const orderLayer = Math.round(Math.log((nVertLayer - 2) / (V0 - 2)) / Math.log(4));
    const orderMesh = Math.round(Math.log((nVertMesh - 2) / (V0 - 2)) / Math.log(4));
    const nVLayer = Math.pow(4, orderLayer) * (V0 - 2) + 2;
    const nVMesh = Math.pow(4, orderMesh) * (V0 - 2) + 2;
    if (nVLayer !== nVertLayer || nVMesh !== nVertMesh) {
      return nVertLayer;
    }
    return nVertMesh;
  }
  // read NIfTI2 format with embedded CIfTI
  // this variation very specific to connectome workbench
  // https://brainder.org/2015/04/03/the-nifti-2-file-format/
  static async readNII2(buffer, n_vert = 0, anatomicalStructurePrimary = "") {
    let scalars = new Float32Array();
    const len4 = buffer.byteLength;
    let isLittleEndian = true;
    const reader = new DataView(buffer);
    let magic = reader.getUint16(0, isLittleEndian);
    if (magic === 469893120) {
      isLittleEndian = false;
      magic = reader.getUint16(0, isLittleEndian);
    }
    if (magic !== 540) {
      throw new Error("Not a valid NIfTI-2 dataset");
    }
    const voxoffset = Number(reader.getBigInt64(168, isLittleEndian));
    const scl_slope = reader.getFloat64(176, isLittleEndian);
    const scl_inter = reader.getFloat64(184, isLittleEndian);
    if (scl_slope !== 1 || scl_inter !== 0) {
      log.warn("ignoring scale slope and intercept");
    }
    const intent_code = reader.getUint32(504, isLittleEndian);
    const datatype = reader.getUint16(12, isLittleEndian);
    if (datatype !== 2 && datatype !== 4 && datatype !== 8 && datatype !== 16) {
      throw new Error("Unsupported NIfTI datatype " + datatype);
    }
    let nvert = 1;
    const dim = [1, 1, 1, 1, 1, 1, 1, 1];
    for (let i = 1; i < 8; i++) {
      dim[i] = Math.max(Number(reader.getBigInt64(16 + i * 8, isLittleEndian)), 1);
      nvert *= dim[i];
    }
    if (intent_code >= 3e3 && intent_code <= 3099 && voxoffset > 580) {
      let readStrX = function() {
        while (pos < len4 && bytes[pos] === 10) {
          pos++;
        }
        const startPos = pos;
        while (pos < len4 && bytes[pos] !== 10) {
          pos++;
        }
        pos++;
        if (pos - startPos < 1) {
          return "";
        }
        return new TextDecoder().decode(buffer.slice(startPos, pos - 1)).trim();
      }, readStr = function() {
        let line2 = readStrX();
        if (!line2.startsWith("<") || line2.endsWith(">")) {
          return line2;
        }
        while (pos < len4 && !line2.endsWith(">")) {
          line2 += readStrX();
        }
        return line2;
      }, readNumericTag = function(TagName, asString = false) {
        const tpos = line.indexOf(TagName);
        if (tpos < 0) {
          return 1;
        }
        const spos = line.indexOf('"', tpos) + 1;
        const epos = line.indexOf('"', spos);
        const str6 = line.slice(spos, epos);
        if (asString) {
          return str6;
        }
        return parseInt(str6);
      };
      let indexOffset = 0;
      let indexCount = 0;
      let surfaceNumberOfVertices = 0;
      let brainStructure = "";
      let vertexIndices = new Uint32Array();
      const bytes = new Uint8Array(buffer);
      let pos = 552;
      let line;
      const nFrame4D = dim[5];
      const scalars2 = new Float32Array(n_vert * nFrame4D);
      while (pos < len4) {
        line = readStr();
        if (line.includes("</CIFTI>")) {
          break;
        }
        if (line.includes("<BrainModel")) {
          const nv = readNumericTag("SurfaceNumberOfVertices=");
          const bStruct = readNumericTag("BrainStructure=", true).toUpperCase();
          if (nv % n_vert !== 0) {
            continue;
          }
          let isMatch = false;
          if (anatomicalStructurePrimary.includes("CORTEX") && bStruct.includes("CORTEX")) {
            isMatch = true;
          }
          if (!isMatch) {
            continue;
          }
          isMatch = false;
          if (anatomicalStructurePrimary.includes("LEFT") && bStruct.includes("LEFT")) {
            isMatch = true;
          }
          if (anatomicalStructurePrimary.includes("RIGHT") && bStruct.includes("RIGHT")) {
            isMatch = true;
          }
          if (!isMatch) {
            continue;
          }
          surfaceNumberOfVertices = nv;
          indexOffset = readNumericTag("IndexOffset=");
          indexCount = readNumericTag("IndexCount=");
          brainStructure = bStruct;
          if (!line.includes("<VertexIndices>")) {
            line = readStr();
          }
          if (!line.startsWith("<VertexIndices>") || !line.endsWith("</VertexIndices>")) {
            log.warn("Unable to find CIfTI <VertexIndices>");
            return scalars2;
          }
          line = line.slice(15, -16);
          const items = line.trim().split(/\s+/);
          if (items.length < indexCount) {
            log.error("Error parsing VertexIndices");
          }
          vertexIndices = new Uint32Array(indexCount);
          for (let i = 0; i < indexCount; i++) {
            vertexIndices[i] = parseInt(items[i]);
          }
        }
      }
      if (surfaceNumberOfVertices === 0 || vertexIndices.length === 0) {
        log.warn("Unable to find CIfTI structure that matches the mesh.");
        return scalars2;
      }
      if (datatype !== 16) {
        log.warn("Only able to read float32 CIfTI (only known datatype).");
        return scalars2;
      }
      const vals = new Float32Array(indexCount * nFrame4D);
      const off = voxoffset + nFrame4D * indexOffset * 4;
      for (let i = 0; i < indexCount * nFrame4D; i++) {
        vals[i] = reader.getFloat32(off + i * 4, isLittleEndian);
      }
      let j = 0;
      for (let i = 0; i < indexCount; i++) {
        for (let f = 0; f < nFrame4D; f++) {
          scalars2[vertexIndices[i] + f * n_vert] = vals[j];
          j++;
        }
      }
      log.debug(
        "CIfTI diagnostics",
        surfaceNumberOfVertices,
        brainStructure,
        indexOffset,
        indexCount,
        indexOffset,
        anatomicalStructurePrimary
      );
      return scalars2;
    }
    nvert = this.decimateLayerVertices(nvert, n_vert);
    if (nvert % n_vert !== 0) {
      throw new Error("Vertices in layer (" + nvert + ") is not a multiple of number of vertices (" + n_vert + ")");
    }
    if (isLittleEndian) {
      if (datatype === 16) {
        scalars = new Float32Array(buffer, voxoffset, nvert);
      } else if (datatype === 8) {
        scalars = new Int32Array(buffer, voxoffset, nvert);
      } else if (datatype === 4) {
        scalars = new Int16Array(buffer, voxoffset, nvert);
      }
    } else {
      if (datatype === 16) {
        scalars = new Float32Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getFloat32(voxoffset + i * 4, isLittleEndian);
        }
      } else if (datatype === 8) {
        scalars = new Int32Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getInt32(voxoffset + i * 4, isLittleEndian);
        }
      } else if (datatype === 4) {
        scalars = new Int16Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getInt16(voxoffset + i * 2, isLittleEndian);
        }
      }
    }
    if (datatype === 2) {
      scalars = new Uint8Array(buffer, voxoffset, nvert);
    }
    return scalars;
  }
  // readNII2()
  // read NIfTI1/2 as vertex colors
  // https://brainder.org/2012/09/23/the-nifti-file-format/#:~:text=In%20the%20nifti%20format%2C%20the,seventh%2C%20are%20for%20other%20uses.
  static async readNII(buffer, n_vert = 0, anatomicalStructurePrimary = "") {
    let scalars = new Float32Array();
    let isLittleEndian = true;
    let reader = new DataView(buffer);
    let magic = reader.getUint16(0, isLittleEndian);
    if (magic === 540 || magic === 469893120) {
      return _NVMeshLoaders.readNII2(buffer, n_vert, anatomicalStructurePrimary);
    }
    if (magic === 23553) {
      isLittleEndian = false;
      magic = reader.getUint16(0, isLittleEndian);
    }
    if (magic !== 348) {
      const raw = await NVUtilities.decompress(new Uint8Array(buffer));
      reader = new DataView(raw.buffer);
      buffer = raw.buffer;
      magic = reader.getUint16(0, isLittleEndian);
      if (magic === 540 || magic === 469893120) {
        return _NVMeshLoaders.readNII2(buffer, n_vert, anatomicalStructurePrimary);
      }
      if (magic === 23553) {
        isLittleEndian = false;
        magic = reader.getUint16(0, isLittleEndian);
      }
    }
    if (magic !== 348) {
      log.error("Not a valid NIfTI image.");
    }
    const voxoffset = reader.getFloat32(108, isLittleEndian);
    const scl_slope = reader.getFloat32(112, isLittleEndian);
    const scl_inter = reader.getFloat32(116, isLittleEndian);
    if (scl_slope !== 1 || scl_inter !== 0) {
      log.warn("ignoring scale slope and intercept");
    }
    const datatype = reader.getUint16(70, isLittleEndian);
    if (datatype !== 2 && datatype !== 4 && datatype !== 8 && datatype !== 16) {
      throw new Error("Unsupported NIfTI datatype " + datatype);
    }
    let nvert = 1;
    for (let i = 1; i < 8; i++) {
      const dim = reader.getUint16(40 + i * 2, isLittleEndian);
      nvert *= Math.max(dim, 1);
    }
    nvert = this.decimateLayerVertices(nvert, n_vert);
    if (nvert % n_vert !== 0) {
      throw new Error("Vertices in layer (" + nvert + ") is not a multiple of number of vertices (" + n_vert + ")");
    }
    if (isLittleEndian) {
      if (datatype === 16) {
        scalars = new Float32Array(buffer, voxoffset, nvert);
      } else if (datatype === 8) {
        scalars = new Int32Array(buffer, voxoffset, nvert);
      } else if (datatype === 4) {
        scalars = new Int16Array(buffer, voxoffset, nvert);
      }
    } else {
      if (datatype === 16) {
        scalars = new Float32Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getFloat32(voxoffset + i * 4, isLittleEndian);
        }
      } else if (datatype === 8) {
        scalars = new Int32Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getInt32(voxoffset + i * 4, isLittleEndian);
        }
      } else if (datatype === 4) {
        scalars = new Int16Array(nvert);
        for (let i = 0; i < nvert; i++) {
          scalars[i] = reader.getInt16(voxoffset + i * 2, isLittleEndian);
        }
      }
    }
    if (datatype === 2) {
      scalars = new Uint8Array(buffer, voxoffset, nvert);
    }
    return scalars;
  }
  // readNII();
  // read MGH format as vertex colors (not voxel-based image)
  // https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/MghFormat
  static async readMGH(buffer, n_vert = 0, isReadColortables = false) {
    let reader = new DataView(buffer);
    let raw = buffer;
    if (reader.getUint8(0) === 31 && reader.getUint8(1) === 139) {
      const decompressed = await NVUtilities.decompress(new Uint8Array(buffer));
      raw = new ArrayBuffer(decompressed.byteLength);
      new Uint8Array(raw).set(new Uint8Array(decompressed));
      reader = new DataView(decompressed.buffer);
    }
    const version2 = reader.getInt32(0, false);
    const width = Math.max(1, reader.getInt32(4, false));
    const height = Math.max(1, reader.getInt32(8, false));
    const depth = Math.max(1, reader.getInt32(12, false));
    const nframes = Math.max(1, reader.getInt32(16, false));
    const mtype = reader.getInt32(20, false);
    let voxoffset = 284;
    const isLittleEndian = false;
    if (version2 !== 1 || mtype < 0 || mtype > 4) {
      log.warn("Not a valid MGH file");
    }
    let nvert = width * height * depth * nframes;
    let scalars = [];
    nvert = this.decimateLayerVertices(nvert, n_vert);
    if (nvert % n_vert !== 0) {
      log.warn("Vertices in layer (" + nvert + ") is not a multiple of number of vertices (" + n_vert + ")");
      return scalars;
    }
    if (mtype === 3) {
      scalars = new Float32Array(nvert);
      for (let i = 0; i < nvert; i++) {
        scalars[i] = reader.getFloat32(voxoffset + i * 4, isLittleEndian);
      }
    } else if (mtype === 1) {
      scalars = new Int32Array(nvert);
      for (let i = 0; i < nvert; i++) {
        scalars[i] = reader.getInt32(voxoffset + i * 4, isLittleEndian);
      }
    } else if (mtype === 4) {
      scalars = new Int16Array(nvert);
      for (let i = 0; i < nvert; i++) {
        scalars[i] = reader.getInt16(voxoffset + i * 2, isLittleEndian);
      }
    } else if (mtype === 0) {
      scalars = new Uint8Array(buffer, voxoffset, nvert);
    }
    if (!isReadColortables) {
      return scalars;
    }
    let bytesPerVertex = 4;
    if (mtype === 4) {
      bytesPerVertex = 2;
    }
    if (mtype === 0) {
      bytesPerVertex = 1;
    }
    voxoffset += bytesPerVertex * nvert;
    voxoffset += 4 * 4;
    const TAG_OLD_COLORTABLE = 1;
    const TAG_OLD_USEREALRAS = 2;
    const TAG_OLD_SURF_GEOM = 20;
    const TAG_OLD_MGH_XFORM = 30;
    const nBytes = raw.byteLength;
    let colormapLabel;
    while (voxoffset < nBytes - 8) {
      const tagType = reader.getInt32(voxoffset += 4, isLittleEndian);
      let plen = 0;
      switch (tagType) {
        case TAG_OLD_MGH_XFORM:
          plen = reader.getInt32(voxoffset += 4, isLittleEndian) - 1;
          break;
        case TAG_OLD_SURF_GEOM:
        // these don't take lengths at all
        case TAG_OLD_USEREALRAS:
          plen = 0;
          break;
        case TAG_OLD_COLORTABLE:
          plen = 0;
          {
            let version3 = reader.getInt32(voxoffset += 4, isLittleEndian);
            if (version3 > 0) {
              log.warn("unsupported CTABreadFromBinaryV1");
              return scalars;
            }
            version3 = -version3;
            if (version3 !== 2) {
              log.warn("CTABreadFromBinary: unknown version");
              return scalars;
            }
            const nentries = reader.getInt32(voxoffset += 4, isLittleEndian);
            if (nentries < 0) {
              log.warn("CTABreadFromBinaryV2: nentries was ", nentries);
              return scalars;
            }
            const len4 = reader.getInt32(voxoffset += 4, isLittleEndian);
            voxoffset += len4;
            const num_entries_to_read = reader.getInt32(voxoffset += 4, isLittleEndian);
            if (num_entries_to_read < 0) {
              return scalars;
            }
            const Labels = { R: [], G: [], B: [], A: [], I: [], labels: [] };
            for (let i = 0; i < num_entries_to_read; i++) {
              const structure = reader.getInt32(voxoffset += 4, isLittleEndian);
              const labelLen = reader.getInt32(voxoffset += 4, isLittleEndian);
              let pos = voxoffset + 4;
              let txt = "";
              for (let c = 0; c < labelLen; c++) {
                const val = reader.getUint8(pos++);
                if (val === 0) {
                  break;
                }
                txt += String.fromCharCode(val);
              }
              voxoffset += labelLen;
              const R = reader.getInt32(voxoffset += 4, isLittleEndian);
              const G = reader.getInt32(voxoffset += 4, isLittleEndian);
              const B = reader.getInt32(voxoffset += 4, isLittleEndian);
              const A = 255 - reader.getInt32(voxoffset += 4, isLittleEndian);
              Labels.I.push(structure);
              Labels.R.push(R);
              Labels.G.push(G);
              Labels.B.push(B);
              Labels.A.push(A);
              Labels.labels.push(txt);
            }
            colormapLabel = cmapper.makeLabelLut(Labels);
          }
          break;
        default:
          plen = reader.getInt32(voxoffset += 8, isLittleEndian);
      }
      voxoffset += plen;
    }
    return {
      scalars,
      colormapLabel
      // TODO can we guarantee this?
    };
  }
  // readMGH()
  // read X3D format mesh
  // https://en.wikipedia.org/wiki/X3D
  static readX3D(buffer) {
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be X3D: bytes = " + len4);
    }
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] !== 60) {
        pos++;
      }
      const startP = pos;
      while (pos < len4 && bytes[pos] !== 62) {
        pos++;
      }
      const endP = pos;
      return new TextDecoder().decode(buffer.slice(startP, endP + 1)).trim();
    }
    let line = readStr();
    function readStringTag(TagName) {
      const fpos = line.indexOf(TagName + "=");
      if (fpos < 0) {
        return "";
      }
      const delimiter = line[fpos + TagName.length + 1];
      const spos = line.indexOf(delimiter, fpos) + 1;
      const epos = line.indexOf(delimiter, spos);
      return line.slice(spos, epos);
    }
    function readNumericTag(TagName) {
      const fpos = line.indexOf(TagName + "=");
      if (fpos < 0) {
        return 1;
      }
      const delimiter = line[fpos + TagName.length + 1];
      const spos = line.indexOf(delimiter, fpos) + 1;
      const epos = line.indexOf(delimiter, spos);
      let str6 = line.slice(spos, epos).trim();
      str6 = str6.replace(/,\s*$/, "");
      const items = str6.trim().split(/\s*,\s*|\s+/);
      if (items.length < 2) {
        return parseFloat(str6);
      }
      let ret = new Array(items.length);
      let j = 0;
      for (let i = 0; i < items.length; i++) {
        const v = parseFloat(items[i]);
        if (!isFinite(v)) {
          continue;
        }
        ret[j] = v;
        j++;
      }
      ret = ret.slice(0, j);
      return ret;
    }
    if (!line.includes("xml version")) {
      log.warn("Not a X3D image");
    }
    let positions = [];
    let indices = [];
    let rgba255 = [];
    let color = [];
    let translation = [0, 0, 0, 0];
    let rotation = [0, 0, 0, 0];
    let rgba = [255, 255, 255, 255];
    let rgbaGlobal = [255, 255, 255, 255];
    const appearanceStyles = {};
    function readAppearance() {
      if (!line.endsWith("/>")) {
        if (line.startsWith("<Appearance>")) {
          while (pos < len4 && !line.endsWith("</Appearance>")) {
            line += readStr();
          }
        } else {
          while (pos < len4 && !line.endsWith("/>")) {
            line += readStr();
          }
        }
      }
      const ref = readStringTag("USE");
      if (ref.length > 1) {
        if (ref in appearanceStyles) {
          rgba = appearanceStyles[ref];
        } else {
          log.warn("Unable to find DEF for " + ref);
        }
        return;
      }
      const diffuseColor = readNumericTag("diffuseColor");
      if (diffuseColor.length < 3) {
        return;
      }
      rgba[0] = Math.round(diffuseColor[0] * 255);
      rgba[1] = Math.round(diffuseColor[1] * 255);
      rgba[2] = Math.round(diffuseColor[2] * 255);
      const def = readStringTag("DEF");
      if (def.length < 1) {
        return;
      }
      appearanceStyles[def] = rgba;
    }
    while (pos < len4) {
      line = readStr();
      rgba = rgbaGlobal.slice();
      if (line.startsWith("<Transform")) {
        translation = readNumericTag("translation");
        rotation = readNumericTag("rotation");
      }
      if (line.startsWith("<Appearance")) {
        readAppearance();
        rgbaGlobal = rgba.slice();
      }
      if (line.startsWith("<Shape")) {
        let radius = 1;
        let height = 1;
        let coordIndex = [];
        let point = [];
        while (pos < len4) {
          line = readStr();
          if (line.startsWith("<Appearance")) {
            readAppearance();
          }
          if (line.startsWith("</Shape")) {
            break;
          }
          if (line.startsWith("<Sphere")) {
            radius = readNumericTag("radius");
            height = -1;
          }
          if (line.startsWith("<Cylinder")) {
            radius = readNumericTag("radius");
            height = readNumericTag("height");
          }
          if (line.startsWith("<IndexedFaceSet")) {
            height = -2;
            coordIndex = readNumericTag("coordIndex");
          }
          if (line.startsWith("<IndexedTriangleSet")) {
            height = -7;
            coordIndex = readNumericTag("index");
          }
          if (line.startsWith("<IndexedTriangleStripSet")) {
            height = -3;
            coordIndex = readNumericTag("index");
          }
          if (line.startsWith("<Coordinate")) {
            point = readNumericTag("point");
            const rem = point.length % 3;
            if (rem !== 0) {
              point = point.slice(0, -rem);
            }
          }
          if (line.startsWith("<Color")) {
            color = readNumericTag("color");
          }
          if (line.startsWith("<Box")) {
            height = -4;
            log.warn("Unsupported x3d shape: Box");
          }
          if (line.startsWith("<Cone")) {
            height = -5;
            log.warn("Unsupported x3d shape: Cone");
          }
          if (line.startsWith("<ElevationGrid")) {
            height = -6;
            log.warn("Unsupported x3d shape: ElevationGrid");
          }
        }
        if (height < -3 && height !== -7) {
        } else if (height < -1) {
          if (coordIndex.length < 1 || point.length < 3 || point.length === void 0) {
            log.warn("Indexed mesh must specify indices and points");
            break;
          }
          const idx0 = Math.floor(positions.length / 3);
          let j = 2;
          if (height === -7) {
            indices = [...indices, ...coordIndex];
          } else if (height === -2) {
            let triStart = 0;
            while (j < coordIndex.length) {
              if (coordIndex[j] >= 0) {
                indices.push(coordIndex[triStart] + idx0);
                indices.push(coordIndex[j - 1] + idx0);
                indices.push(coordIndex[j - 0] + idx0);
                j += 1;
              } else {
                j += 3;
                triStart = j - 2;
              }
            }
          } else {
            while (j < coordIndex.length) {
              if (coordIndex[j] >= 0) {
                indices.push(coordIndex[j - 2] + idx0);
                indices.push(coordIndex[j - 1] + idx0);
                indices.push(coordIndex[j - 0] + idx0);
                j += 1;
              } else {
                j += 3;
              }
            }
          }
          positions = [...positions, ...point];
          const npt = Math.floor(point.length / 3);
          const rgbas = Array(npt).fill(rgba).flat();
          if (color.length === npt * 3) {
            let c3 = 0;
            let c4 = 0;
            for (let i = 0; i < npt; i++) {
              for (let j2 = 0; j2 < 3; j2++) {
                rgbas[c4] = Math.round(color[c3] * 255);
                c3++;
                c4++;
              }
              c4++;
            }
          }
          rgba255 = [...rgba255, ...rgbas];
        } else if (height < 0) {
          NiivueObject3D.makeColoredSphere(positions, indices, rgba255, radius, translation, rgba);
        } else {
          const r = mat4_exports.create();
          mat4_exports.fromRotation(r, rotation[3], [rotation[0], rotation[1], rotation[2]]);
          const pti = vec4_exports.fromValues(0, -height * 0.5, 0, 1);
          const ptj = vec4_exports.fromValues(0, +height * 0.5, 0, 1);
          vec4_exports.transformMat4(pti, pti, r);
          vec4_exports.transformMat4(ptj, ptj, r);
          vec4_exports.add(pti, pti, translation);
          vec4_exports.add(ptj, ptj, translation);
          const pti3 = vec3_exports.fromValues(pti[0], pti[1], pti[2]);
          const ptj3 = vec3_exports.fromValues(ptj[0], ptj[1], ptj[2]);
          NiivueObject3D.makeColoredCylinder(positions, indices, rgba255, pti3, ptj3, radius, rgba);
        }
      }
    }
    return {
      positions: Float32Array.from(positions),
      indices: Uint32Array.from(indices),
      rgba255: Uint8Array.from(rgba255)
    };
  }
  // readX3D()
  // read GIfTI format mesh
  // https://www.nitrc.org/projects/gifti/
  static async readGII(buffer, n_vert = 0) {
    let len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be GII: bytes = " + len4);
    }
    let chars = new TextDecoder("ascii").decode(buffer);
    if (chars[0].charCodeAt(0) === 31) {
      const raw = await NVUtilities.decompress(new Uint8Array(buffer));
      buffer = raw.buffer;
      chars = new TextDecoder("ascii").decode(raw.buffer);
    }
    let pos = 0;
    function readXMLtag() {
      let isEmptyTag = true;
      let startPos = pos;
      while (isEmptyTag) {
        while (pos < len4 && chars[pos] !== "<") {
          pos++;
        }
        startPos = pos;
        while (pos < len4 && chars[pos] !== ">") {
          pos++;
        }
        isEmptyTag = chars[pos - 1] === "/";
        if (startPos + 1 < len4 && chars[startPos + 1] === "/") {
          pos += 1;
          isEmptyTag = true;
        }
        if (pos >= len4) {
          break;
        }
      }
      const tagString = new TextDecoder().decode(buffer.slice(startPos + 1, pos)).trim();
      const startTag = tagString.split(" ")[0].trim();
      const contentStartPos = pos;
      let contentEndPos = pos;
      let endPos = pos;
      if (chars[startPos + 1] !== "?" && chars[startPos + 1] !== "!") {
        const endTag = "</" + startTag + ">";
        contentEndPos = chars.indexOf(endTag, contentStartPos);
        endPos = contentEndPos + endTag.length - 1;
      }
      return {
        name: tagString,
        startPos,
        contentStartPos,
        contentEndPos,
        endPos
      };
    }
    let tag = readXMLtag();
    if (!tag.name.startsWith("?xml")) {
      throw new Error("readGII: Invalid XML file");
    }
    while (!tag.name.startsWith("GIFTI") && tag.endPos < len4) {
      tag = readXMLtag();
    }
    if (!tag.name.startsWith("GIFTI") || tag.contentStartPos === tag.contentEndPos) {
      throw new Error("readGII: XML file does not include GIFTI tag");
    }
    len4 = tag.contentEndPos;
    let positions = new Float32Array();
    let indices = new Uint32Array();
    let scalars = new Float32Array();
    let anatomicalStructurePrimary = "";
    let isIdx = false;
    let isPts = false;
    let isVectors = false;
    let isColMajor = false;
    let Dims = [1, 1, 1];
    const FreeSurferTranlate = [0, 0, 0];
    let dataType = 0;
    let isGzip = false;
    let isASCII = false;
    let nvert = 0;
    let isDataSpaceScanner = false;
    tag.endPos = tag.contentStartPos;
    let line = "";
    function readNumericTag(TagName, isFloat = false) {
      const pos2 = line.indexOf(TagName);
      if (pos2 < 0) {
        return 1;
      }
      const spos = line.indexOf('"', pos2) + 1;
      const epos = line.indexOf('"', spos);
      const str6 = line.slice(spos, epos);
      if (isFloat) {
        return parseFloat(str6);
      } else {
        return parseInt(str6);
      }
    }
    function readBracketTag(TagName) {
      const pos2 = line.indexOf(TagName);
      if (pos2 < 0) {
        return "";
      }
      const spos = pos2 + TagName.length;
      const epos = line.indexOf("]", spos);
      return line.slice(spos, epos);
    }
    const Labels = { R: [], G: [], B: [], A: [], I: [], labels: [] };
    while (tag.endPos < len4 && tag.name.length > 1) {
      tag = readXMLtag();
      if (tag.name.startsWith("Label Key")) {
        line = tag.name;
        Labels.I.push(readNumericTag("Key="));
        Labels.R.push(Math.round(255 * readNumericTag("Red=", true)));
        Labels.G.push(Math.round(255 * readNumericTag("Green=", true)));
        Labels.B.push(Math.round(255 * readNumericTag("Blue=", true)));
        Labels.A.push(Math.round(255 * readNumericTag("Alpha", true)));
        line = new TextDecoder().decode(buffer.slice(tag.contentStartPos + 1, tag.contentEndPos)).trim();
        Labels.labels.push(readBracketTag("<![CDATA["));
      }
      if (tag.name.trim() === "Data") {
        if (isVectors) {
          continue;
        }
        line = new TextDecoder().decode(buffer.slice(tag.contentStartPos + 1, tag.contentEndPos)).trim();
        let datBin;
        if (isASCII) {
          const nvert2 = Dims[0] * Dims[1] * Dims[2];
          const lines = line.split(/\s+/);
          if (nvert2 !== lines.length) {
            throw new Error("Unable to parse ASCII GIfTI");
          }
          if (dataType === 2) {
            dataType = 8;
          }
          if (dataType === 32) {
            dataType = 16;
          }
          if (dataType === 8) {
            datBin = new Int32Array(nvert2);
            for (let v = 0; v < nvert2; v++) {
              datBin[v] = parseInt(lines[v]);
            }
          }
          if (dataType === 16) {
            datBin = new Float32Array(nvert2);
            for (let v = 0; v < nvert2; v++) {
              datBin[v] = parseFloat(lines[v]);
            }
          }
        } else if (typeof Buffer === "undefined") {
          let base64ToUint8 = function(base64) {
            const binary_string = atob(base64);
            const len5 = binary_string.length;
            const bytes = new Uint8Array(len5);
            for (let i = 0; i < len5; i++) {
              bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
          };
          if (isGzip) {
            const datZ = base64ToUint8(line.slice());
            datBin = await NVUtilities.decompress(new Uint8Array(datZ));
          } else {
            datBin = base64ToUint8(line.slice());
          }
        } else {
          if (isGzip) {
            const datZ = Buffer.from(line.slice(), "base64");
            datBin = await NVUtilities.decompress(new Uint8Array(datZ));
          } else {
            datBin = Buffer.from(line.slice(), "base64");
          }
        }
        if (isPts) {
          if (dataType !== 16) {
            log.warn("expect positions as FLOAT32");
          }
          positions = new Float32Array(datBin.buffer);
          if (isColMajor) {
            const tmp = positions.slice();
            const np = tmp.length / 3;
            let j = 0;
            for (let p = 0; p < np; p++) {
              for (let i = 0; i < 3; i++) {
                positions[j] = tmp[i * np + p];
                j++;
              }
            }
          }
        } else if (isIdx) {
          if (dataType !== 8) {
            log.warn("expect indices as INT32");
          }
          indices = new Uint32Array(datBin.buffer);
          if (isColMajor) {
            const tmp = indices.slice();
            const np = tmp.length / 3;
            let j = 0;
            for (let p = 0; p < np; p++) {
              for (let i = 0; i < 3; i++) {
                indices[j] = tmp[i * np + p];
                j++;
              }
            }
          }
        } else {
          let Float32Concat = function(first, second) {
            const firstLength = first.length;
            const result = new Float32Array(firstLength + second.length);
            result.set(first);
            result.set(second, firstLength);
            return result;
          };
          nvert = Dims[0] * Dims[1] * Dims[2];
          if (n_vert !== 0) {
            if (nvert % n_vert !== 0) {
              log.warn("Number of vertices in scalar overlay (" + nvert + ") does not match mesh (" + n_vert + ")");
            }
          }
          let scalarsNew;
          if (dataType === 2) {
            const scalarsInt = new Uint8Array(datBin.buffer);
            scalarsNew = Float32Array.from(scalarsInt);
          } else if (dataType === 8) {
            const scalarsInt = new Int32Array(datBin.buffer);
            scalarsNew = Float32Array.from(scalarsInt);
          } else if (dataType === 16) {
            scalarsNew = new Float32Array(datBin.buffer);
          } else if (dataType === 32) {
            const scalarFloat = new Float64Array(datBin.buffer);
            scalarsNew = Float32Array.from(scalarFloat);
          } else {
            throw new Error(`Invalid dataType: ${dataType}`);
          }
          scalars = Float32Concat(scalars, scalarsNew);
        }
        continue;
      }
      if (tag.name.trim() === "DataSpace") {
        line = new TextDecoder().decode(buffer.slice(tag.contentStartPos + 1, tag.contentEndPos)).trim();
        if (line.includes("NIFTI_XFORM_SCANNER_ANAT")) {
          isDataSpaceScanner = true;
        }
      }
      if (tag.name.trim() === "MD") {
        line = new TextDecoder().decode(buffer.slice(tag.contentStartPos + 1, tag.contentEndPos)).trim();
        if (line.includes("AnatomicalStructurePrimary") && line.includes("CDATA[")) {
          anatomicalStructurePrimary = readBracketTag("<Value><![CDATA[").toUpperCase();
        }
        if (line.includes("VolGeom") && line.includes("CDATA[")) {
          let e = -1;
          if (line.includes("VolGeomC_R")) {
            e = 0;
          }
          if (line.includes("VolGeomC_A")) {
            e = 1;
          }
          if (line.includes("VolGeomC_S")) {
            e = 2;
          }
          if (e < 0) {
            continue;
          }
          FreeSurferTranlate[e] = parseFloat(readBracketTag("<Value><![CDATA["));
        }
      }
      if (!tag.name.startsWith("DataArray")) {
        continue;
      }
      line = tag.name;
      Dims = [1, 1, 1];
      isGzip = line.includes('Encoding="GZipBase64Binary"');
      isASCII = line.includes('Encoding="ASCII"');
      isIdx = line.includes('Intent="NIFTI_INTENT_TRIANGLE"');
      isPts = line.includes('Intent="NIFTI_INTENT_POINTSET"');
      isVectors = line.includes('Intent="NIFTI_INTENT_VECTOR"');
      isColMajor = line.includes('ArrayIndexingOrder="ColumnMajorOrder"');
      if (line.includes('DataType="NIFTI_TYPE_UINT8"')) {
        dataType = 2;
      }
      if (line.includes('DataType="NIFTI_TYPE_INT32"')) {
        dataType = 8;
      }
      if (line.includes('DataType="NIFTI_TYPE_FLOAT32"')) {
        dataType = 16;
      }
      if (line.includes('DataType="NIFTI_TYPE_FLOAT64"')) {
        dataType = 32;
      }
      Dims[0] = readNumericTag("Dim0=");
      Dims[1] = readNumericTag("Dim1=");
      Dims[2] = readNumericTag("Dim2=");
    }
    let colormapLabel;
    if (Labels.I.length > 1) {
      colormapLabel = cmapper.makeLabelLut(Labels);
    }
    if (n_vert > 0) {
      return { scalars, colormapLabel, anatomicalStructurePrimary };
    }
    if (positions.length > 2 && !isDataSpaceScanner && (FreeSurferTranlate[0] !== 0 || FreeSurferTranlate[1] !== 0 || FreeSurferTranlate[2] !== 0)) {
      nvert = Math.floor(positions.length / 3);
      let i = 0;
      for (let v = 0; v < nvert; v++) {
        positions[i] += FreeSurferTranlate[0];
        i++;
        positions[i] += FreeSurferTranlate[1];
        i++;
        positions[i] += FreeSurferTranlate[2];
        i++;
      }
    }
    return {
      positions,
      indices,
      scalars,
      colormapLabel,
      anatomicalStructurePrimary
    };
  }
  // readGII()
};

// ../../node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// ../../node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($, _) => {
  const as = (out, index) => {
    $.set(index, out);
    return out;
  };
  const unpair = (index) => {
    if ($.has(index))
      return $.get(index);
    const [type, value] = _[index];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index);
      case ARRAY: {
        const arr = as([], index);
        for (const index2 of value)
          arr.push(unpair(index2));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index);
        for (const [key, index2] of value)
          object[unpair(key)] = unpair(index2);
        return object;
      }
      case DATE:
        return as(new Date(value), index);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index);
      }
      case MAP: {
        const map = as(/* @__PURE__ */ new Map(), index);
        for (const [key, index2] of value)
          map.set(unpair(key), unpair(index2));
        return map;
      }
      case SET: {
        const set6 = as(/* @__PURE__ */ new Set(), index);
        for (const index2 of value)
          set6.add(unpair(index2));
        return set6;
      }
      case ERROR: {
        const { name, message } = value;
        return as(new env[name](message), index);
      }
      case BIGINT:
        return as(BigInt(value), index);
      case "BigInt":
        return as(Object(BigInt(value)), index);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// ../../node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $, _) => {
  const as = (out, value) => {
    const index = _.push(out) - 1;
    $.set(value, index);
    return index;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }
        const arr = [];
        const index = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index;
      }
      case SET: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// ../../node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max4 = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max4(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max4(lt);
        dbt = max4(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add6 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add6 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add6;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
var Inflate = /* @__PURE__ */ function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gunzip = /* @__PURE__ */ function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}

// ../../node_modules/nifti-reader-js/dist/nifti-extension.js
var NIFTIEXTENSION = class {
  constructor(esize, ecode, edata, littleEndian) {
    __publicField(this, "esize");
    __publicField(this, "ecode");
    __publicField(this, "edata");
    __publicField(this, "littleEndian");
    if (esize % 16 != 0) {
      throw new Error("This does not appear to be a NIFTI extension");
    }
    this.esize = esize;
    this.ecode = ecode;
    this.edata = edata;
    this.littleEndian = littleEndian;
  }
  /**
   * Returns extension as ArrayBuffer.
   * @returns {ArrayBuffer}
   */
  toArrayBuffer() {
    let byteArray = new Uint8Array(this.esize);
    let data = new Uint8Array(this.edata);
    byteArray.set(data, 8);
    let view = new DataView(byteArray.buffer);
    view.setInt32(0, this.esize, this.littleEndian);
    view.setInt32(4, this.ecode, this.littleEndian);
    return byteArray.buffer;
  }
};

// ../../node_modules/nifti-reader-js/dist/utilities.js
var _Utils = class _Utils {
  /*** Static methods ***/
  static getStringAt(data, start, end) {
    var str6 = "", ctr, ch;
    for (ctr = start; ctr < end; ctr += 1) {
      ch = data.getUint8(ctr);
      if (ch !== 0) {
        str6 += String.fromCharCode(ch);
      }
    }
    return str6;
  }
  static getIntAt(data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
  }
  static getFloatAt(data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
  }
  static getDoubleAt(data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
  }
  static getInt64At(dataView, index, littleEndian) {
    const low = dataView.getUint32(index, littleEndian);
    const high = dataView.getInt32(index + 4, littleEndian);
    let result;
    if (littleEndian) {
      result = high * 2 ** 32 + low;
    } else {
      result = low * 2 ** 32 + high;
    }
    if (high < 0) {
      result += -1 * 2 ** 32 * 2 ** 32;
    }
    return result;
  }
  static getUint64At(dataView, index, littleEndian) {
    const low = dataView.getUint32(index + (littleEndian ? 0 : 4), littleEndian);
    const high = dataView.getUint32(index + (littleEndian ? 4 : 0), littleEndian);
    return littleEndian ? high * 2 ** 32 + low : low * 2 ** 32 + high;
  }
  static getExtensionsAt(data, start, littleEndian, voxOffset) {
    let extensions = [];
    let extensionByteIndex = start;
    while (extensionByteIndex < voxOffset) {
      let extensionLittleEndian = littleEndian;
      let esize = _Utils.getIntAt(data, extensionByteIndex, littleEndian);
      if (!esize) {
        break;
      }
      if (esize + extensionByteIndex > voxOffset) {
        extensionLittleEndian = !extensionLittleEndian;
        esize = _Utils.getIntAt(data, extensionByteIndex, extensionLittleEndian);
        if (esize + extensionByteIndex > voxOffset) {
          throw new Error("This does not appear to be a valid NIFTI extension");
        }
      }
      if (esize % 16 != 0) {
        throw new Error("This does not appear to be a NIFTI extension");
      }
      let ecode = _Utils.getIntAt(data, extensionByteIndex + 4, extensionLittleEndian);
      let edata = data.buffer.slice(extensionByteIndex + 8, extensionByteIndex + esize);
      let extension = new NIFTIEXTENSION(esize, ecode, edata, extensionLittleEndian);
      extensions.push(extension);
      extensionByteIndex += esize;
    }
    return extensions;
  }
  static toArrayBuffer(buffer) {
    var ab, view, i;
    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
      view[i] = buffer[i];
    }
    return ab;
  }
  static isString(obj) {
    return typeof obj === "string" || obj instanceof String;
  }
  static formatNumber(num, shortFormat = void 0) {
    let val;
    if (_Utils.isString(num)) {
      val = Number(num);
    } else {
      val = num;
    }
    if (shortFormat) {
      val = val.toPrecision(5);
    } else {
      val = val.toPrecision(7);
    }
    return parseFloat(val);
  }
  // http://stackoverflow.com/questions/18638900/javascript-crc32
  static makeCRCTable() {
    let c;
    let crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      crcTable[n] = c;
    }
    return crcTable;
  }
  static crc32(dataView) {
    if (!_Utils.crcTable) {
      _Utils.crcTable = _Utils.makeCRCTable();
    }
    const crcTable = _Utils.crcTable;
    let crc = 0 ^ -1;
    for (var i = 0; i < dataView.byteLength; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ dataView.getUint8(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
};
/*** Static Pseudo-constants ***/
__publicField(_Utils, "crcTable", null);
__publicField(_Utils, "GUNZIP_MAGIC_COOKIE1", 31);
__publicField(_Utils, "GUNZIP_MAGIC_COOKIE2", 139);
__publicField(_Utils, "getByteAt", function(data, start) {
  return data.getUint8(start);
});
__publicField(_Utils, "getShortAt", function(data, start, littleEndian) {
  return data.getInt16(start, littleEndian);
});
var Utils = _Utils;

// ../../node_modules/nifti-reader-js/dist/nifti1.js
var _NIFTI1 = class _NIFTI1 {
  constructor() {
    __publicField(this, "littleEndian", false);
    __publicField(this, "dim_info", 0);
    __publicField(this, "dims", []);
    __publicField(this, "intent_p1", 0);
    __publicField(this, "intent_p2", 0);
    __publicField(this, "intent_p3", 0);
    __publicField(this, "intent_code", 0);
    __publicField(this, "datatypeCode", 0);
    __publicField(this, "numBitsPerVoxel", 0);
    __publicField(this, "slice_start", 0);
    __publicField(this, "slice_end", 0);
    __publicField(this, "slice_code", 0);
    __publicField(this, "pixDims", []);
    __publicField(this, "vox_offset", 0);
    __publicField(this, "scl_slope", 1);
    __publicField(this, "scl_inter", 0);
    __publicField(this, "xyzt_units", 0);
    __publicField(this, "cal_max", 0);
    __publicField(this, "cal_min", 0);
    __publicField(this, "slice_duration", 0);
    __publicField(this, "toffset", 0);
    __publicField(this, "description", "");
    __publicField(this, "aux_file", "");
    __publicField(this, "intent_name", "");
    __publicField(this, "qform_code", 0);
    __publicField(this, "sform_code", 0);
    __publicField(this, "quatern_a", 0);
    __publicField(this, "quatern_b", 0);
    __publicField(this, "quatern_c", 0);
    __publicField(this, "quatern_d", 0);
    __publicField(this, "qoffset_x", 0);
    __publicField(this, "qoffset_y", 0);
    __publicField(this, "qoffset_z", 0);
    __publicField(this, "affine", [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]);
    __publicField(this, "qfac", 1);
    __publicField(this, "quatern_R");
    __publicField(this, "magic", "0");
    __publicField(this, "isHDR", false);
    __publicField(this, "extensionFlag", [0, 0, 0, 0]);
    __publicField(this, "extensionSize", 0);
    __publicField(this, "extensionCode", 0);
    __publicField(this, "extensions", []);
    /**
     * Returns a human-readable string of datatype.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getDatatypeCodeString", function(code) {
      if (code === _NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
      } else if (code === _NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
      } else if (code === _NIFTI1.TYPE_RGB24) {
        return "RGB";
      } else if (code === _NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
      } else {
        return "Unknown";
      }
    });
    /**
     * Returns a human-readable string of transform type.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getTransformCodeString", function(code) {
      if (code === _NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
      } else if (code === _NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
      } else if (code === _NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
      } else if (code === _NIFTI1.XFORM_MNI_152) {
        return "MNI";
      } else {
        return "Unknown";
      }
    });
    /**
     * Returns a human-readable string of spatial and temporal units.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getUnitsCodeString", function(code) {
      if (code === _NIFTI1.UNITS_METER) {
        return "Meters";
      } else if (code === _NIFTI1.UNITS_MM) {
        return "Millimeters";
      } else if (code === _NIFTI1.UNITS_MICRON) {
        return "Microns";
      } else if (code === _NIFTI1.UNITS_SEC) {
        return "Seconds";
      } else if (code === _NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
      } else if (code === _NIFTI1.UNITS_USEC) {
        return "Microseconds";
      } else if (code === _NIFTI1.UNITS_HZ) {
        return "Hz";
      } else if (code === _NIFTI1.UNITS_PPM) {
        return "PPM";
      } else if (code === _NIFTI1.UNITS_RADS) {
        return "Rads";
      } else {
        return "Unknown";
      }
    });
    __publicField(this, "nifti_mat33_mul", function(A, B) {
      var C = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ], i, j;
      for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
          C[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
      }
      return C;
    });
    __publicField(this, "nifti_mat33_determ", function(R) {
      var r11, r12, r13, r21, r22, r23, r31, r32, r33;
      r11 = R[0][0];
      r12 = R[0][1];
      r13 = R[0][2];
      r21 = R[1][0];
      r22 = R[1][1];
      r23 = R[1][2];
      r31 = R[2][0];
      r32 = R[2][1];
      r33 = R[2][2];
      return r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13;
    });
  }
  /*** Prototype Methods ***/
  /**
   * Reads the header data.
   * @param {ArrayBuffer} data
   */
  readHeader(data) {
    var rawData = new DataView(data), magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian), ctr, ctrOut, ctrIn, index;
    if (magicCookieVal !== _NIFTI1.MAGIC_COOKIE) {
      this.littleEndian = true;
      magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian);
    }
    if (magicCookieVal !== _NIFTI1.MAGIC_COOKIE) {
      throw new Error("This does not appear to be a NIFTI file!");
    }
    this.dim_info = Utils.getByteAt(rawData, 39);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 40 + ctr * 2;
      this.dims[ctr] = Utils.getShortAt(rawData, index, this.littleEndian);
    }
    this.intent_p1 = Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = Utils.getShortAt(rawData, 68, this.littleEndian);
    this.datatypeCode = Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = Utils.getShortAt(rawData, 72, this.littleEndian);
    this.slice_start = Utils.getShortAt(rawData, 74, this.littleEndian);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 76 + ctr * 4;
      this.pixDims[ctr] = Utils.getFloatAt(rawData, index, this.littleEndian);
    }
    this.vox_offset = Utils.getFloatAt(rawData, 108, this.littleEndian);
    this.scl_slope = Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = Utils.getFloatAt(rawData, 116, this.littleEndian);
    this.slice_end = Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = Utils.getByteAt(rawData, 122);
    this.xyzt_units = Utils.getByteAt(rawData, 123);
    this.cal_max = Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = Utils.getFloatAt(rawData, 128, this.littleEndian);
    this.slice_duration = Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = Utils.getFloatAt(rawData, 136, this.littleEndian);
    this.description = Utils.getStringAt(rawData, 148, 228);
    this.aux_file = Utils.getStringAt(rawData, 228, 252);
    this.qform_code = Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = Utils.getShortAt(rawData, 254, this.littleEndian);
    this.quatern_b = Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.quatern_a = Math.sqrt(1 - (Math.pow(this.quatern_b, 2) + Math.pow(this.quatern_c, 2) + Math.pow(this.quatern_d, 2)));
    this.qoffset_x = Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = Utils.getFloatAt(rawData, 276, this.littleEndian);
    if (this.qform_code < 1 && this.sform_code < 1) {
      this.affine[0][0] = this.pixDims[1];
      this.affine[1][1] = this.pixDims[2];
      this.affine[2][2] = this.pixDims[3];
    }
    if (this.qform_code > 0 && this.sform_code < this.qform_code) {
      const a = this.quatern_a;
      const b = this.quatern_b;
      const c = this.quatern_c;
      const d = this.quatern_d;
      this.qfac = this.pixDims[0] === 0 ? 1 : this.pixDims[0];
      this.quatern_R = [
        [a * a + b * b - c * c - d * d, 2 * b * c - 2 * a * d, 2 * b * d + 2 * a * c],
        [2 * b * c + 2 * a * d, a * a + c * c - b * b - d * d, 2 * c * d - 2 * a * b],
        [2 * b * d - 2 * a * c, 2 * c * d + 2 * a * b, a * a + d * d - c * c - b * b]
      ];
      for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 3; ctrIn += 1) {
          this.affine[ctrOut][ctrIn] = this.quatern_R[ctrOut][ctrIn] * this.pixDims[ctrIn + 1];
          if (ctrIn === 2) {
            this.affine[ctrOut][ctrIn] *= this.qfac;
          }
        }
      }
      this.affine[0][3] = this.qoffset_x;
      this.affine[1][3] = this.qoffset_y;
      this.affine[2][3] = this.qoffset_z;
    } else if (this.sform_code > 0) {
      for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
          index = 280 + (ctrOut * 4 + ctrIn) * 4;
          this.affine[ctrOut][ctrIn] = Utils.getFloatAt(rawData, index, this.littleEndian);
        }
      }
    }
    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;
    this.intent_name = Utils.getStringAt(rawData, 328, 344);
    this.magic = Utils.getStringAt(rawData, 344, 348);
    this.isHDR = this.magic === String.fromCharCode.apply(null, _NIFTI1.MAGIC_NUMBER2);
    if (rawData.byteLength > _NIFTI1.MAGIC_COOKIE) {
      this.extensionFlag[0] = Utils.getByteAt(rawData, 348);
      this.extensionFlag[1] = Utils.getByteAt(rawData, 348 + 1);
      this.extensionFlag[2] = Utils.getByteAt(rawData, 348 + 2);
      this.extensionFlag[3] = Utils.getByteAt(rawData, 348 + 3);
      let isExtensionCapable = true;
      if (!this.isHDR && this.vox_offset <= 352)
        isExtensionCapable = false;
      if (rawData.byteLength <= 352 + 16)
        isExtensionCapable = false;
      if (isExtensionCapable && this.extensionFlag[0]) {
        this.extensions = Utils.getExtensionsAt(rawData, this.getExtensionLocation(), this.littleEndian, this.vox_offset);
        this.extensionSize = this.extensions[0].esize;
        this.extensionCode = this.extensions[0].ecode;
      }
    }
  }
  /**
   * Returns a formatted string of header fields.
   * @returns {string}
   */
  toFormattedString() {
    var fmt = Utils.formatNumber, string = "";
    string += "Dim Info = " + this.dim_info + "\n";
    string += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + "\n";
    string += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + "\n";
    string += "Intent Code = " + this.intent_code + "\n";
    string += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n";
    string += "Bits Per Voxel = " + this.numBitsPerVoxel + "\n";
    string += "Slice Start = " + this.slice_start + "\n";
    string += "Voxel Dimensions (1-8): " + fmt(this.pixDims[0]) + ", " + fmt(this.pixDims[1]) + ", " + fmt(this.pixDims[2]) + ", " + fmt(this.pixDims[3]) + ", " + fmt(this.pixDims[4]) + ", " + fmt(this.pixDims[5]) + ", " + fmt(this.pixDims[6]) + ", " + fmt(this.pixDims[7]) + "\n";
    string += "Image Offset = " + this.vox_offset + "\n";
    string += "Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n";
    string += "Slice End = " + this.slice_end + "\n";
    string += "Slice Code = " + this.slice_code + "\n";
    string += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(_NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(_NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n";
    string += "Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n";
    string += "Slice Duration = " + this.slice_duration + "\n";
    string += "Time Axis Shift = " + this.toffset + "\n";
    string += 'Description: "' + this.description + '"\n';
    string += 'Auxiliary File: "' + this.aux_file + '"\n';
    string += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n";
    string += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n";
    string += "Quaternion Parameters:  b = " + fmt(this.quatern_b) + "  c = " + fmt(this.quatern_c) + "  d = " + fmt(this.quatern_d) + "\n";
    string += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + "\n";
    string += "S-Form Parameters X: " + fmt(this.affine[0][0]) + ", " + fmt(this.affine[0][1]) + ", " + fmt(this.affine[0][2]) + ", " + fmt(this.affine[0][3]) + "\n";
    string += "S-Form Parameters Y: " + fmt(this.affine[1][0]) + ", " + fmt(this.affine[1][1]) + ", " + fmt(this.affine[1][2]) + ", " + fmt(this.affine[1][3]) + "\n";
    string += "S-Form Parameters Z: " + fmt(this.affine[2][0]) + ", " + fmt(this.affine[2][1]) + ", " + fmt(this.affine[2][2]) + ", " + fmt(this.affine[2][3]) + "\n";
    string += 'Intent Name: "' + this.intent_name + '"\n';
    if (this.extensionFlag[0]) {
      string += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n";
    }
    return string;
  }
  /**
   * Returns the qform matrix.
   * @returns {Array.<Array.<number>>}
   */
  getQformMat() {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
  }
  /**
   * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {number} qb
   * @param {number} qc
   * @param {number} qd
   * @param {number} qx
   * @param {number} qy
   * @param {number} qz
   * @param {number} dx
   * @param {number} dy
   * @param {number} dz
   * @param {number} qfac
   * @returns {Array.<Array.<number>>}
   */
  convertNiftiQFormToNiftiSForm(qb, qc, qd, qx, qy, qz, dx, dy, dz, qfac) {
    var R = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ], a, b = qb, c = qc, d = qd, xd, yd, zd;
    R[3][0] = R[3][1] = R[3][2] = 0;
    R[3][3] = 1;
    a = 1 - (b * b + c * c + d * d);
    if (a < 1e-7) {
      a = 1 / Math.sqrt(b * b + c * c + d * d);
      b *= a;
      c *= a;
      d *= a;
      a = 0;
    } else {
      a = Math.sqrt(a);
    }
    xd = dx > 0 ? dx : 1;
    yd = dy > 0 ? dy : 1;
    zd = dz > 0 ? dz : 1;
    if (qfac < 0) {
      zd = -zd;
    }
    R[0][0] = (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2 * (b * c - a * d) * yd;
    R[0][2] = 2 * (b * d + a * c) * zd;
    R[1][0] = 2 * (b * c + a * d) * xd;
    R[1][1] = (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2 * (c * d - a * b) * zd;
    R[2][0] = 2 * (b * d - a * c) * xd;
    R[2][1] = 2 * (c * d + a * b) * yd;
    R[2][2] = (a * a + d * d - c * c - b * b) * zd;
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;
    return R;
  }
  /**
   * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {Array.<Array.<number>>} R
   * @returns {string}
   */
  convertNiftiSFormToNEMA(R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest, M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;
    Q = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    P = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];
    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];
    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0) {
      return null;
    }
    xi /= val;
    yi /= val;
    zi /= val;
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0) {
      return null;
    }
    xj /= val;
    yj /= val;
    zj /= val;
    val = xi * xj + yi * yj + zi * zj;
    if (Math.abs(val) > 1e-4) {
      xj -= val * xi;
      yj -= val * yi;
      zj -= val * zi;
      val = Math.sqrt(xj * xj + yj * yj + zj * zj);
      if (val === 0) {
        return null;
      }
      xj /= val;
      yj /= val;
      zj /= val;
    }
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0) {
      xk = yi * zj - zi * yj;
      yk = zi * xj - zj * xi;
      zk = xi * yj - yi * xj;
    } else {
      xk /= val;
      yk /= val;
      zk /= val;
    }
    val = xi * xk + yi * yk + zi * zk;
    if (Math.abs(val) > 1e-4) {
      xk -= val * xi;
      yk -= val * yi;
      zk -= val * zi;
      val = Math.sqrt(xk * xk + yk * yk + zk * zk);
      if (val === 0) {
        return null;
      }
      xk /= val;
      yk /= val;
      zk /= val;
    }
    val = xj * xk + yj * yk + zj * zk;
    if (Math.abs(val) > 1e-4) {
      xk -= val * xj;
      yk -= val * yj;
      zk -= val * zj;
      val = Math.sqrt(xk * xk + yk * yk + zk * zk);
      if (val === 0) {
        return null;
      }
      xk /= val;
      yk /= val;
      zk /= val;
    }
    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;
    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0) {
      return null;
    }
    vbest = -666;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;
    for (i = 1; i <= 3; i += 1) {
      for (j = 1; j <= 3; j += 1) {
        if (i !== j) {
          for (k = 1; k <= 3; k += 1) {
            if (!(i === k || j === k)) {
              P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0;
              for (p = -1; p <= 1; p += 2) {
                for (q = -1; q <= 1; q += 2) {
                  for (r = -1; r <= 1; r += 2) {
                    P[0][i - 1] = p;
                    P[1][j - 1] = q;
                    P[2][k - 1] = r;
                    detP = this.nifti_mat33_determ(P);
                    if (detP * detQ > 0) {
                      M = this.nifti_mat33_mul(P, Q);
                      val = M[0][0] + M[1][1] + M[2][2];
                      if (val > vbest) {
                        vbest = val;
                        ibest = i;
                        jbest = j;
                        kbest = k;
                        pbest = p;
                        qbest = q;
                        rbest = r;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    iChar = jChar = kChar = iSense = jSense = kSense = "";
    switch (ibest * pbest) {
      case 1:
        iChar = "X";
        iSense = "+";
        break;
      case -1:
        iChar = "X";
        iSense = "-";
        break;
      case 2:
        iChar = "Y";
        iSense = "+";
        break;
      case -2:
        iChar = "Y";
        iSense = "-";
        break;
      case 3:
        iChar = "Z";
        iSense = "+";
        break;
      case -3:
        iChar = "Z";
        iSense = "-";
        break;
    }
    switch (jbest * qbest) {
      case 1:
        jChar = "X";
        jSense = "+";
        break;
      case -1:
        jChar = "X";
        jSense = "-";
        break;
      case 2:
        jChar = "Y";
        jSense = "+";
        break;
      case -2:
        jChar = "Y";
        jSense = "-";
        break;
      case 3:
        jChar = "Z";
        jSense = "+";
        break;
      case -3:
        jChar = "Z";
        jSense = "-";
        break;
    }
    switch (kbest * rbest) {
      case 1:
        kChar = "X";
        kSense = "+";
        break;
      case -1:
        kChar = "X";
        kSense = "-";
        break;
      case 2:
        kChar = "Y";
        kSense = "+";
        break;
      case -2:
        kChar = "Y";
        kSense = "-";
        break;
      case 3:
        kChar = "Z";
        kSense = "+";
        break;
      case -3:
        kChar = "Z";
        kSense = "-";
        break;
    }
    return iChar + jChar + kChar + iSense + jSense + kSense;
  }
  /**
   * Returns the byte index of the extension.
   * @returns {number}
   */
  getExtensionLocation() {
    return _NIFTI1.MAGIC_COOKIE + 4;
  }
  /**
   * Returns the extension size.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionSize(data) {
    return Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
  }
  /**
   * Returns the extension code.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionCode(data) {
    return Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
  }
  /**
   * Adds an extension
   * @param {NIFTIEXTENSION} extension
   * @param {number} index
   */
  addExtension(extension, index = -1) {
    if (index == -1) {
      this.extensions.push(extension);
    } else {
      this.extensions.splice(index, 0, extension);
    }
    this.vox_offset += extension.esize;
  }
  /**
   * Removes an extension
   * @param {number} index
   */
  removeExtension(index) {
    let extension = this.extensions[index];
    if (extension) {
      this.vox_offset -= extension.esize;
    }
    this.extensions.splice(index, 1);
  }
  /**
   * Returns header as ArrayBuffer.
   * @param {boolean} includeExtensions - should extension bytes be included
   * @returns {ArrayBuffer}
   */
  toArrayBuffer(includeExtensions = false) {
    const SHORT_SIZE = 2;
    const FLOAT32_SIZE = 4;
    let byteSize = 348 + 4;
    if (includeExtensions) {
      for (let extension of this.extensions) {
        byteSize += extension.esize;
      }
    }
    let byteArray = new Uint8Array(byteSize);
    let view = new DataView(byteArray.buffer);
    view.setInt32(0, 348, this.littleEndian);
    view.setUint8(39, this.dim_info);
    for (let i = 0; i < 8; i++) {
      view.setUint16(40 + SHORT_SIZE * i, this.dims[i], this.littleEndian);
    }
    view.setFloat32(56, this.intent_p1, this.littleEndian);
    view.setFloat32(60, this.intent_p2, this.littleEndian);
    view.setFloat32(64, this.intent_p3, this.littleEndian);
    view.setInt16(68, this.intent_code, this.littleEndian);
    view.setInt16(70, this.datatypeCode, this.littleEndian);
    view.setInt16(72, this.numBitsPerVoxel, this.littleEndian);
    view.setInt16(74, this.slice_start, this.littleEndian);
    for (let i = 0; i < 8; i++) {
      view.setFloat32(76 + FLOAT32_SIZE * i, this.pixDims[i], this.littleEndian);
    }
    view.setFloat32(108, this.vox_offset, this.littleEndian);
    view.setFloat32(112, this.scl_slope, this.littleEndian);
    view.setFloat32(116, this.scl_inter, this.littleEndian);
    view.setInt16(120, this.slice_end, this.littleEndian);
    view.setUint8(122, this.slice_code);
    view.setUint8(123, this.xyzt_units);
    view.setFloat32(124, this.cal_max, this.littleEndian);
    view.setFloat32(128, this.cal_min, this.littleEndian);
    view.setFloat32(132, this.slice_duration, this.littleEndian);
    view.setFloat32(136, this.toffset, this.littleEndian);
    byteArray.set(new TextEncoder().encode(this.description), 148);
    byteArray.set(new TextEncoder().encode(this.aux_file), 228);
    view.setInt16(252, this.qform_code, this.littleEndian);
    view.setInt16(254, this.sform_code, this.littleEndian);
    view.setFloat32(256, this.quatern_b, this.littleEndian);
    view.setFloat32(260, this.quatern_c, this.littleEndian);
    view.setFloat32(264, this.quatern_d, this.littleEndian);
    view.setFloat32(268, this.qoffset_x, this.littleEndian);
    view.setFloat32(272, this.qoffset_y, this.littleEndian);
    view.setFloat32(276, this.qoffset_z, this.littleEndian);
    const flattened = this.affine.flat();
    for (let i = 0; i < 12; i++) {
      view.setFloat32(280 + FLOAT32_SIZE * i, flattened[i], this.littleEndian);
    }
    byteArray.set(new TextEncoder().encode(this.intent_name), 328);
    byteArray.set(new TextEncoder().encode(this.magic), 344);
    if (includeExtensions) {
      byteArray.set(Uint8Array.from([1, 0, 0, 0]), 348);
      let extensionByteIndex = this.getExtensionLocation();
      for (const extension of this.extensions) {
        view.setInt32(extensionByteIndex, extension.esize, extension.littleEndian);
        view.setInt32(extensionByteIndex + 4, extension.ecode, extension.littleEndian);
        byteArray.set(new Uint8Array(extension.edata), extensionByteIndex + 8);
        extensionByteIndex += extension.esize;
      }
    } else {
      byteArray.set(new Uint8Array(4).fill(0), 348);
    }
    return byteArray.buffer;
  }
};
/*** Static Pseudo-constants ***/
// datatype codes
__publicField(_NIFTI1, "TYPE_NONE", 0);
__publicField(_NIFTI1, "TYPE_BINARY", 1);
__publicField(_NIFTI1, "TYPE_UINT8", 2);
__publicField(_NIFTI1, "TYPE_INT16", 4);
__publicField(_NIFTI1, "TYPE_INT32", 8);
__publicField(_NIFTI1, "TYPE_FLOAT32", 16);
__publicField(_NIFTI1, "TYPE_COMPLEX64", 32);
__publicField(_NIFTI1, "TYPE_FLOAT64", 64);
__publicField(_NIFTI1, "TYPE_RGB24", 128);
__publicField(_NIFTI1, "TYPE_INT8", 256);
__publicField(_NIFTI1, "TYPE_UINT16", 512);
__publicField(_NIFTI1, "TYPE_UINT32", 768);
__publicField(_NIFTI1, "TYPE_INT64", 1024);
__publicField(_NIFTI1, "TYPE_UINT64", 1280);
__publicField(_NIFTI1, "TYPE_FLOAT128", 1536);
__publicField(_NIFTI1, "TYPE_COMPLEX128", 1792);
__publicField(_NIFTI1, "TYPE_COMPLEX256", 2048);
// transform codes
__publicField(_NIFTI1, "XFORM_UNKNOWN", 0);
__publicField(_NIFTI1, "XFORM_SCANNER_ANAT", 1);
__publicField(_NIFTI1, "XFORM_ALIGNED_ANAT", 2);
__publicField(_NIFTI1, "XFORM_TALAIRACH", 3);
__publicField(_NIFTI1, "XFORM_MNI_152", 4);
// unit codes
__publicField(_NIFTI1, "SPATIAL_UNITS_MASK", 7);
__publicField(_NIFTI1, "TEMPORAL_UNITS_MASK", 56);
__publicField(_NIFTI1, "UNITS_UNKNOWN", 0);
__publicField(_NIFTI1, "UNITS_METER", 1);
__publicField(_NIFTI1, "UNITS_MM", 2);
__publicField(_NIFTI1, "UNITS_MICRON", 3);
__publicField(_NIFTI1, "UNITS_SEC", 8);
__publicField(_NIFTI1, "UNITS_MSEC", 16);
__publicField(_NIFTI1, "UNITS_USEC", 24);
__publicField(_NIFTI1, "UNITS_HZ", 32);
__publicField(_NIFTI1, "UNITS_PPM", 40);
__publicField(_NIFTI1, "UNITS_RADS", 48);
// nifti1 codes
__publicField(_NIFTI1, "MAGIC_COOKIE", 348);
__publicField(_NIFTI1, "STANDARD_HEADER_SIZE", 348);
__publicField(_NIFTI1, "MAGIC_NUMBER_LOCATION", 344);
__publicField(_NIFTI1, "MAGIC_NUMBER", [110, 43, 49]);
// n+1 (.nii)
__publicField(_NIFTI1, "MAGIC_NUMBER2", [110, 105, 49]);
// ni1 (.hdr/.img)
__publicField(_NIFTI1, "EXTENSION_HEADER_SIZE", 8);
var NIFTI1 = _NIFTI1;

// ../../node_modules/nifti-reader-js/dist/nifti2.js
var _NIFTI2 = class _NIFTI2 {
  constructor() {
    __publicField(this, "littleEndian", false);
    __publicField(this, "dim_info", 0);
    __publicField(this, "dims", []);
    __publicField(this, "intent_p1", 0);
    __publicField(this, "intent_p2", 0);
    __publicField(this, "intent_p3", 0);
    __publicField(this, "intent_code", 0);
    __publicField(this, "datatypeCode", 0);
    __publicField(this, "numBitsPerVoxel", 0);
    __publicField(this, "slice_start", 0);
    __publicField(this, "slice_end", 0);
    __publicField(this, "slice_code", 0);
    __publicField(this, "pixDims", []);
    __publicField(this, "vox_offset", 0);
    __publicField(this, "scl_slope", 1);
    __publicField(this, "scl_inter", 0);
    __publicField(this, "xyzt_units", 0);
    __publicField(this, "cal_max", 0);
    __publicField(this, "cal_min", 0);
    __publicField(this, "slice_duration", 0);
    __publicField(this, "toffset", 0);
    __publicField(this, "description", "");
    __publicField(this, "aux_file", "");
    __publicField(this, "intent_name", "");
    __publicField(this, "qform_code", 0);
    __publicField(this, "sform_code", 0);
    __publicField(this, "quatern_b", 0);
    __publicField(this, "quatern_c", 0);
    __publicField(this, "quatern_d", 0);
    __publicField(this, "qoffset_x", 0);
    __publicField(this, "qoffset_y", 0);
    __publicField(this, "qoffset_z", 0);
    __publicField(this, "affine", [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]);
    __publicField(this, "magic", "0");
    __publicField(this, "extensionFlag", [0, 0, 0, 0]);
    __publicField(this, "extensions", []);
    __publicField(this, "extensionSize", 0);
    __publicField(this, "extensionCode", 0);
    /**
     * Returns the byte index of the extension.
     * @returns {number}
     */
    __publicField(this, "getExtensionLocation", function() {
      return _NIFTI2.MAGIC_COOKIE + 4;
    });
    /**
     * Returns the extension size.
     * @param {DataView} data
     * @returns {number}
     */
    __publicField(this, "getExtensionSize", NIFTI1.prototype.getExtensionSize);
    /**
     * Returns the extension code.
     * @param {DataView} data
     * @returns {number}
     */
    __publicField(this, "getExtensionCode", NIFTI1.prototype.getExtensionCode);
    /**
     * Adds an extension
     * @param {NIFTIEXTENSION} extension
     * @param {number} index
     */
    __publicField(this, "addExtension", NIFTI1.prototype.addExtension);
    /**
     * Removes an extension
     * @param {number} index
     */
    __publicField(this, "removeExtension", NIFTI1.prototype.removeExtension);
    /**
     * Returns a human-readable string of datatype.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getDatatypeCodeString", NIFTI1.prototype.getDatatypeCodeString);
    /**
     * Returns a human-readable string of transform type.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getTransformCodeString", NIFTI1.prototype.getTransformCodeString);
    /**
     * Returns a human-readable string of spatial and temporal units.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getUnitsCodeString", NIFTI1.prototype.getUnitsCodeString);
    /**
     * Returns the qform matrix.
     * @returns {Array.<Array.<number>>}
     */
    __publicField(this, "getQformMat", NIFTI1.prototype.getQformMat);
    /**
     * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
     * @param {number} qb
     * @param {number} qc
     * @param {number} qd
     * @param {number} qx
     * @param {number} qy
     * @param {number} qz
     * @param {number} dx
     * @param {number} dy
     * @param {number} dz
     * @param {number} qfac
     * @returns {Array.<Array.<number>>}
     */
    __publicField(this, "convertNiftiQFormToNiftiSForm", NIFTI1.prototype.convertNiftiQFormToNiftiSForm);
    /**
     * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
     * @param {Array.<Array.<number>>} R
     * @returns {string}
     */
    __publicField(this, "convertNiftiSFormToNEMA", NIFTI1.prototype.convertNiftiSFormToNEMA);
    __publicField(this, "nifti_mat33_mul", NIFTI1.prototype.nifti_mat33_mul);
    __publicField(this, "nifti_mat33_determ", NIFTI1.prototype.nifti_mat33_determ);
  }
  // ni2\0
  /*** Prototype Methods ***/
  /**
   * Reads the header data.
   * @param {ArrayBuffer} data
   */
  readHeader(data) {
    var rawData = new DataView(data), magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian), ctr, ctrOut, ctrIn, index, array;
    if (magicCookieVal !== _NIFTI2.MAGIC_COOKIE) {
      this.littleEndian = true;
      magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian);
    }
    if (magicCookieVal !== _NIFTI2.MAGIC_COOKIE) {
      throw new Error("This does not appear to be a NIFTI file!");
    }
    this.magic = Utils.getStringAt(rawData, 4, 12);
    this.datatypeCode = Utils.getShortAt(rawData, 12, this.littleEndian);
    this.numBitsPerVoxel = Utils.getShortAt(rawData, 14, this.littleEndian);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 16 + ctr * 8;
      this.dims[ctr] = Utils.getInt64At(rawData, index, this.littleEndian);
    }
    this.intent_p1 = Utils.getDoubleAt(rawData, 80, this.littleEndian);
    this.intent_p2 = Utils.getDoubleAt(rawData, 88, this.littleEndian);
    this.intent_p3 = Utils.getDoubleAt(rawData, 96, this.littleEndian);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 104 + ctr * 8;
      this.pixDims[ctr] = Utils.getDoubleAt(rawData, index, this.littleEndian);
    }
    this.vox_offset = Utils.getInt64At(rawData, 168, this.littleEndian);
    this.scl_slope = Utils.getDoubleAt(rawData, 176, this.littleEndian);
    this.scl_inter = Utils.getDoubleAt(rawData, 184, this.littleEndian);
    this.cal_max = Utils.getDoubleAt(rawData, 192, this.littleEndian);
    this.cal_min = Utils.getDoubleAt(rawData, 200, this.littleEndian);
    this.slice_duration = Utils.getDoubleAt(rawData, 208, this.littleEndian);
    this.toffset = Utils.getDoubleAt(rawData, 216, this.littleEndian);
    this.slice_start = Utils.getInt64At(rawData, 224, this.littleEndian);
    this.slice_end = Utils.getInt64At(rawData, 232, this.littleEndian);
    this.description = Utils.getStringAt(rawData, 240, 240 + 80);
    this.aux_file = Utils.getStringAt(rawData, 320, 320 + 24);
    this.qform_code = Utils.getIntAt(rawData, 344, this.littleEndian);
    this.sform_code = Utils.getIntAt(rawData, 348, this.littleEndian);
    this.quatern_b = Utils.getDoubleAt(rawData, 352, this.littleEndian);
    this.quatern_c = Utils.getDoubleAt(rawData, 360, this.littleEndian);
    this.quatern_d = Utils.getDoubleAt(rawData, 368, this.littleEndian);
    this.qoffset_x = Utils.getDoubleAt(rawData, 376, this.littleEndian);
    this.qoffset_y = Utils.getDoubleAt(rawData, 384, this.littleEndian);
    this.qoffset_z = Utils.getDoubleAt(rawData, 392, this.littleEndian);
    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
      for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
        index = 400 + (ctrOut * 4 + ctrIn) * 8;
        this.affine[ctrOut][ctrIn] = Utils.getDoubleAt(rawData, index, this.littleEndian);
      }
    }
    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;
    this.slice_code = Utils.getIntAt(rawData, 496, this.littleEndian);
    this.xyzt_units = Utils.getIntAt(rawData, 500, this.littleEndian);
    this.intent_code = Utils.getIntAt(rawData, 504, this.littleEndian);
    this.intent_name = Utils.getStringAt(rawData, 508, 508 + 16);
    this.dim_info = Utils.getByteAt(rawData, 524);
    if (rawData.byteLength > _NIFTI2.MAGIC_COOKIE) {
      this.extensionFlag[0] = Utils.getByteAt(rawData, 540);
      this.extensionFlag[1] = Utils.getByteAt(rawData, 540 + 1);
      this.extensionFlag[2] = Utils.getByteAt(rawData, 540 + 2);
      this.extensionFlag[3] = Utils.getByteAt(rawData, 540 + 3);
      if (this.extensionFlag[0]) {
        this.extensions = Utils.getExtensionsAt(rawData, this.getExtensionLocation(), this.littleEndian, this.vox_offset);
        this.extensionSize = this.extensions[0].esize;
        this.extensionCode = this.extensions[0].ecode;
      }
    }
  }
  /**
   * Returns a formatted string of header fields.
   * @returns {string}
   */
  toFormattedString() {
    var fmt = Utils.formatNumber, string = "";
    string += "Datatype = " + +this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n";
    string += "Bits Per Voxel =  = " + this.numBitsPerVoxel + "\n";
    string += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + "\n";
    string += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + "\n";
    string += "Voxel Dimensions (1-8): " + fmt(this.pixDims[0]) + ", " + fmt(this.pixDims[1]) + ", " + fmt(this.pixDims[2]) + ", " + fmt(this.pixDims[3]) + ", " + fmt(this.pixDims[4]) + ", " + fmt(this.pixDims[5]) + ", " + fmt(this.pixDims[6]) + ", " + fmt(this.pixDims[7]) + "\n";
    string += "Image Offset = " + this.vox_offset + "\n";
    string += "Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n";
    string += "Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n";
    string += "Slice Duration = " + this.slice_duration + "\n";
    string += "Time Axis Shift = " + this.toffset + "\n";
    string += "Slice Start = " + this.slice_start + "\n";
    string += "Slice End = " + this.slice_end + "\n";
    string += 'Description: "' + this.description + '"\n';
    string += 'Auxiliary File: "' + this.aux_file + '"\n';
    string += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n";
    string += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n";
    string += "Quaternion Parameters:  b = " + fmt(this.quatern_b) + "  c = " + fmt(this.quatern_c) + "  d = " + fmt(this.quatern_d) + "\n";
    string += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + "\n";
    string += "S-Form Parameters X: " + fmt(this.affine[0][0]) + ", " + fmt(this.affine[0][1]) + ", " + fmt(this.affine[0][2]) + ", " + fmt(this.affine[0][3]) + "\n";
    string += "S-Form Parameters Y: " + fmt(this.affine[1][0]) + ", " + fmt(this.affine[1][1]) + ", " + fmt(this.affine[1][2]) + ", " + fmt(this.affine[1][3]) + "\n";
    string += "S-Form Parameters Z: " + fmt(this.affine[2][0]) + ", " + fmt(this.affine[2][1]) + ", " + fmt(this.affine[2][2]) + ", " + fmt(this.affine[2][3]) + "\n";
    string += "Slice Code = " + this.slice_code + "\n";
    string += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n";
    string += "Intent Code = " + this.intent_code + "\n";
    string += 'Intent Name: "' + this.intent_name + '"\n';
    string += "Dim Info = " + this.dim_info + "\n";
    return string;
  }
  /**
   * Returns header as ArrayBuffer.
   * @param {boolean} includeExtensions - should extension bytes be included
   * @returns {ArrayBuffer}
   */
  toArrayBuffer(includeExtensions = false) {
    const INT64_SIZE = 8;
    const DOUBLE_SIZE = 8;
    let byteSize = 540 + 4;
    if (includeExtensions) {
      for (let extension of this.extensions) {
        byteSize += extension.esize;
      }
    }
    let byteArray = new Uint8Array(byteSize);
    let view = new DataView(byteArray.buffer);
    view.setInt32(0, 540, this.littleEndian);
    byteArray.set(new TextEncoder().encode(this.magic), 4);
    view.setInt16(12, this.datatypeCode, this.littleEndian);
    view.setInt16(14, this.numBitsPerVoxel, this.littleEndian);
    for (let i = 0; i < 8; i++) {
      view.setBigInt64(16 + INT64_SIZE * i, BigInt(this.dims[i]), this.littleEndian);
    }
    view.setFloat64(80, this.intent_p1, this.littleEndian);
    view.setFloat64(88, this.intent_p2, this.littleEndian);
    view.setFloat64(96, this.intent_p3, this.littleEndian);
    for (let i = 0; i < 8; i++) {
      view.setFloat64(104 + DOUBLE_SIZE * i, this.pixDims[i], this.littleEndian);
    }
    view.setBigInt64(168, BigInt(this.vox_offset), this.littleEndian);
    view.setFloat64(176, this.scl_slope, this.littleEndian);
    view.setFloat64(184, this.scl_inter, this.littleEndian);
    view.setFloat64(192, this.cal_max, this.littleEndian);
    view.setFloat64(200, this.cal_min, this.littleEndian);
    view.setFloat64(208, this.slice_duration, this.littleEndian);
    view.setFloat64(216, this.toffset, this.littleEndian);
    view.setBigInt64(224, BigInt(this.slice_start), this.littleEndian);
    view.setBigInt64(232, BigInt(this.slice_end), this.littleEndian);
    byteArray.set(new TextEncoder().encode(this.description), 240);
    byteArray.set(new TextEncoder().encode(this.aux_file), 320);
    view.setInt32(344, this.qform_code, this.littleEndian);
    view.setInt32(348, this.sform_code, this.littleEndian);
    view.setFloat64(352, this.quatern_b, this.littleEndian);
    view.setFloat64(360, this.quatern_c, this.littleEndian);
    view.setFloat64(368, this.quatern_d, this.littleEndian);
    view.setFloat64(376, this.qoffset_x, this.littleEndian);
    view.setFloat64(384, this.qoffset_y, this.littleEndian);
    view.setFloat64(392, this.qoffset_z, this.littleEndian);
    const flattened = this.affine.flat();
    for (let i = 0; i < 12; i++) {
      view.setFloat64(400 + DOUBLE_SIZE * i, flattened[i], this.littleEndian);
    }
    view.setInt32(496, this.slice_code, this.littleEndian);
    view.setInt32(500, this.xyzt_units, this.littleEndian);
    view.setInt32(504, this.intent_code, this.littleEndian);
    byteArray.set(new TextEncoder().encode(this.intent_name), 508);
    view.setUint8(524, this.dim_info);
    if (includeExtensions) {
      byteArray.set(Uint8Array.from([1, 0, 0, 0]), 540);
      let extensionByteIndex = this.getExtensionLocation();
      for (const extension of this.extensions) {
        view.setInt32(extensionByteIndex, extension.esize, extension.littleEndian);
        view.setInt32(extensionByteIndex + 4, extension.ecode, extension.littleEndian);
        byteArray.set(new Uint8Array(extension.edata), extensionByteIndex + 8);
        extensionByteIndex += extension.esize;
      }
    } else {
      byteArray.set(new Uint8Array(4).fill(0), 540);
    }
    return byteArray.buffer;
  }
};
/*** Static Pseudo-constants ***/
__publicField(_NIFTI2, "MAGIC_COOKIE", 540);
__publicField(_NIFTI2, "MAGIC_NUMBER_LOCATION", 4);
__publicField(_NIFTI2, "MAGIC_NUMBER", [110, 43, 50, 0, 13, 10, 26, 10]);
// n+2\0
__publicField(_NIFTI2, "MAGIC_NUMBER2", [110, 105, 50, 0, 13, 10, 26, 10]);
var NIFTI2 = _NIFTI2;

// ../../node_modules/nifti-reader-js/dist/nifti.js
function isNIFTI1(data, isHdrImgPairOK = false) {
  var buf, mag1, mag2, mag3;
  if (data.byteLength < NIFTI1.STANDARD_HEADER_SIZE) {
    return false;
  }
  buf = new DataView(data);
  if (buf)
    mag1 = buf.getUint8(NIFTI1.MAGIC_NUMBER_LOCATION);
  mag2 = buf.getUint8(NIFTI1.MAGIC_NUMBER_LOCATION + 1);
  mag3 = buf.getUint8(NIFTI1.MAGIC_NUMBER_LOCATION + 2);
  if (isHdrImgPairOK && mag1 === NIFTI1.MAGIC_NUMBER2[0] && mag2 === NIFTI1.MAGIC_NUMBER2[1] && mag3 === NIFTI1.MAGIC_NUMBER2[2])
    return true;
  return !!(mag1 === NIFTI1.MAGIC_NUMBER[0] && mag2 === NIFTI1.MAGIC_NUMBER[1] && mag3 === NIFTI1.MAGIC_NUMBER[2]);
}
function isNIFTI2(data, isHdrImgPairOK = false) {
  var buf, mag1, mag2, mag3;
  if (data.byteLength < NIFTI1.STANDARD_HEADER_SIZE) {
    return false;
  }
  buf = new DataView(data);
  mag1 = buf.getUint8(NIFTI2.MAGIC_NUMBER_LOCATION);
  mag2 = buf.getUint8(NIFTI2.MAGIC_NUMBER_LOCATION + 1);
  mag3 = buf.getUint8(NIFTI2.MAGIC_NUMBER_LOCATION + 2);
  if (isHdrImgPairOK && mag1 === NIFTI2.MAGIC_NUMBER2[0] && mag2 === NIFTI2.MAGIC_NUMBER2[1] && mag3 === NIFTI2.MAGIC_NUMBER2[2])
    return true;
  return !!(mag1 === NIFTI2.MAGIC_NUMBER[0] && mag2 === NIFTI2.MAGIC_NUMBER[1] && mag3 === NIFTI2.MAGIC_NUMBER[2]);
}
function isCompressed(data) {
  var buf, magicCookie1, magicCookie2;
  if (data) {
    buf = new DataView(data);
    magicCookie1 = buf.getUint8(0);
    magicCookie2 = buf.getUint8(1);
    if (magicCookie1 === Utils.GUNZIP_MAGIC_COOKIE1) {
      return true;
    }
    if (magicCookie2 === Utils.GUNZIP_MAGIC_COOKIE2) {
      return true;
    }
  }
  return false;
}
function decompress(data) {
  return decompressSync(new Uint8Array(data)).buffer;
}
async function decompressAsync(data) {
  const uint8Data = new Uint8Array(data);
  const format = uint8Data[0] === 31 && uint8Data[1] === 139 && uint8Data[2] === 8 ? "gzip" : uint8Data[0] === 120 && (uint8Data[1] === 1 || uint8Data[1] === 94 || uint8Data[1] === 156 || uint8Data[1] === 218) ? "deflate" : "deflate-raw";
  const stream = new DecompressionStream(format);
  const writer = stream.writable.getWriter();
  writer.write(uint8Data).catch(console.error);
  const closePromise = writer.close().catch(console.error);
  const response = new Response(stream.readable);
  const result = await response.arrayBuffer();
  await closePromise;
  return result;
}
async function decompressHeaderAsync(data, minOutputBytes = Infinity) {
  const detectFormat = (data2) => {
    if (data2[0] === 31 && data2[1] === 139 && data2[2] === 8)
      return "gzip";
    if (data2[0] === 120 && [1, 94, 156, 218].includes(data2[1]))
      return "deflate";
    return "deflate-raw";
  };
  const uint8Data = new Uint8Array(data);
  const format = detectFormat(uint8Data);
  const stream = new DecompressionStream(format);
  const limitStream = new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk);
    },
    flush(controller) {
      controller.terminate();
    }
  });
  const { readable, writable } = stream;
  const writer = writable.getWriter();
  const limitedReader = readable.pipeThrough(limitStream).getReader();
  writer.write(uint8Data).catch((err2) => {
    if (!(err2 instanceof Error && err2.name === "AbortError")) {
      console.error("Error during write:", err2);
    }
  });
  const chunks = [];
  let totalBytes = 0;
  try {
    while (totalBytes < minOutputBytes) {
      const { done, value } = await limitedReader.read();
      if (done)
        break;
      const remainingSpace = minOutputBytes - totalBytes;
      const chunk = value.subarray(0, Math.min(value.length, remainingSpace));
      chunks.push(chunk);
      totalBytes += chunk.length;
      if (totalBytes >= minOutputBytes) {
        await Promise.all([
          limitedReader.cancel().catch(() => {
          }),
          writer.abort().catch(() => {
          })
        ]);
        break;
      }
    }
  } catch (err2) {
    if (!(err2 instanceof Error && err2.name === "AbortError")) {
      console.error("Error during decompression:", err2);
    }
  } finally {
    await Promise.allSettled([
      limitedReader.cancel().catch(() => {
      }),
      writer.close().catch(() => {
      })
    ]);
  }
  return chunks.length === 1 ? chunks[0].buffer : chunks.reduce((acc, chunk) => {
    const combined = new Uint8Array(acc.byteLength + chunk.byteLength);
    combined.set(new Uint8Array(acc), 0);
    combined.set(chunk, acc.byteLength);
    return combined.buffer;
  }, new ArrayBuffer(0));
}
function readHeader(data, isHdrImgPairOK = false) {
  let header = null;
  if (isCompressed(data)) {
    data = decompress(data);
  }
  if (isNIFTI1(data, isHdrImgPairOK)) {
    header = new NIFTI1();
  } else if (isNIFTI2(data, isHdrImgPairOK)) {
    header = new NIFTI2();
  }
  if (header) {
    header.readHeader(data);
  } else {
    throw new Error("That file does not appear to be NIFTI!");
  }
  return header;
}
async function readHeaderAsync(data, isHdrImgPairOK = false) {
  if (!isCompressed(data)) {
    return readHeader(data, isHdrImgPairOK);
  }
  let header = null;
  let dat = await decompressHeaderAsync(data, 540);
  let isLitteEndian = true;
  let isVers1 = true;
  var rawData = new DataView(dat);
  const sigLittle = rawData.getInt32(0, true);
  const sigBig = rawData.getInt32(0, false);
  if (sigLittle === 348) {
  } else if (sigBig === 348) {
    isLitteEndian = false;
  } else if (sigLittle === 540) {
    isVers1 = false;
  } else if (sigBig === 540) {
    isVers1 = false;
    isLitteEndian = false;
  } else {
    throw new Error("That file does not appear to be NIFTI!");
  }
  let vox_offset = Math.round(rawData.getFloat32(108, isLitteEndian));
  if (NIFTI2) {
    vox_offset = Utils.getUint64At(rawData, 168, isLitteEndian);
  }
  if (vox_offset > dat.byteLength) {
    dat = await decompressHeaderAsync(data, vox_offset);
  }
  if (isVers1) {
    header = new NIFTI1();
  } else {
    header = new NIFTI2();
  }
  header.readHeader(dat);
  return header;
}
function readImage(header, data) {
  var imageOffset = header.vox_offset, timeDim = 1, statDim = 1;
  if (header.dims[4]) {
    timeDim = header.dims[4];
  }
  if (header.dims[5]) {
    statDim = header.dims[5];
  }
  var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
  return data.slice(imageOffset, imageOffset + imageSize);
}

// src/nvimage/utils.ts
var isPlatformLittleEndian = () => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true);
  return new Int16Array(buffer)[0] === 256;
};
var ImageType = /* @__PURE__ */ ((ImageType3) => {
  ImageType3[ImageType3["UNKNOWN"] = 0] = "UNKNOWN";
  ImageType3[ImageType3["NII"] = 1] = "NII";
  ImageType3[ImageType3["DCM"] = 2] = "DCM";
  ImageType3[ImageType3["DCM_MANIFEST"] = 3] = "DCM_MANIFEST";
  ImageType3[ImageType3["MIH"] = 4] = "MIH";
  ImageType3[ImageType3["MIF"] = 5] = "MIF";
  ImageType3[ImageType3["NHDR"] = 6] = "NHDR";
  ImageType3[ImageType3["NRRD"] = 7] = "NRRD";
  ImageType3[ImageType3["MHD"] = 8] = "MHD";
  ImageType3[ImageType3["MHA"] = 9] = "MHA";
  ImageType3[ImageType3["MGH"] = 10] = "MGH";
  ImageType3[ImageType3["MGZ"] = 11] = "MGZ";
  ImageType3[ImageType3["V"] = 12] = "V";
  ImageType3[ImageType3["V16"] = 13] = "V16";
  ImageType3[ImageType3["VMR"] = 14] = "VMR";
  ImageType3[ImageType3["HEAD"] = 15] = "HEAD";
  ImageType3[ImageType3["DCM_FOLDER"] = 16] = "DCM_FOLDER";
  ImageType3[ImageType3["SRC"] = 17] = "SRC";
  ImageType3[ImageType3["FIB"] = 18] = "FIB";
  ImageType3[ImageType3["BMP"] = 19] = "BMP";
  ImageType3[ImageType3["ZARR"] = 20] = "ZARR";
  ImageType3[ImageType3["NPY"] = 21] = "NPY";
  ImageType3[ImageType3["NPZ"] = 22] = "NPZ";
  return ImageType3;
})(ImageType || {});
var NVIMAGE_TYPE = Object.freeze({
  ...ImageType,
  parse: (ext) => {
    let imageType = 0 /* UNKNOWN */;
    switch (ext.toUpperCase()) {
      case "":
      case "DCM":
        imageType = 2 /* DCM */;
        break;
      case "TXT":
        imageType = 3 /* DCM_MANIFEST */;
        break;
      case "FZ":
      case "GQI":
      case "QSDR":
      case "FIB":
        imageType = 18 /* FIB */;
        break;
      case "NII":
        imageType = 1 /* NII */;
        break;
      case "MIH":
        imageType = 4 /* MIH */;
        break;
      case "MIF":
        imageType = 5 /* MIF */;
        break;
      case "NHDR":
        imageType = 6 /* NHDR */;
        break;
      case "NRRD":
        imageType = 7 /* NRRD */;
        break;
      case "MHD":
        imageType = 8 /* MHD */;
        break;
      case "MHA":
        imageType = 9 /* MHA */;
        break;
      case "MGH":
        imageType = 10 /* MGH */;
        break;
      case "MGZ":
        imageType = 11 /* MGZ */;
        break;
      case "NPY":
        imageType = 21 /* NPY */;
        break;
      case "NPZ":
        imageType = 22 /* NPZ */;
        break;
      case "SRC":
        imageType = 17 /* SRC */;
        break;
      case "V":
        imageType = 12 /* V */;
        break;
      case "V16":
        imageType = 13 /* V16 */;
        break;
      case "VMR":
        imageType = 14 /* VMR */;
        break;
      case "HEAD":
        imageType = 15 /* HEAD */;
        break;
      case "PNG":
      case "BMP":
      case "GIF":
      case "JPG":
      case "JPEG":
        imageType = 19 /* BMP */;
        break;
      case "ZARR":
        imageType = 20 /* ZARR */;
        break;
    }
    return imageType;
  }
});
var NVImageFromUrlOptions = (url, urlImageData = "", name = "", colormap = "gray", opacity = 1, cal_min = NaN, cal_max = NaN, trustCalMinMax = true, percentileFrac = 0.02, ignoreZeroVoxels = false, useQFormNotSForm = false, colormapNegative = "", frame4D = 0, imageType = NVIMAGE_TYPE.UNKNOWN, cal_minNeg = NaN, cal_maxNeg = NaN, colorbarVisible = true, alphaThreshold = false, colormapLabel = null) => {
  return {
    url,
    urlImageData,
    name,
    colormap,
    colorMap: colormap,
    opacity,
    cal_min,
    cal_max,
    trustCalMinMax,
    percentileFrac,
    ignoreZeroVoxels,
    useQFormNotSForm,
    colormapNegative,
    imageType,
    cal_minNeg,
    cal_maxNeg,
    colorbarVisible,
    frame4D,
    alphaThreshold,
    colormapLabel
  };
};
function str2Buffer(str6, maxLen = 80) {
  str6 = str6.replace(/[`$]/g, "");
  const bytes = [];
  const len4 = Math.min(maxLen, str6.length);
  for (let i = 0; i < len4; i++) {
    const char = str6.charCodeAt(i);
    bytes.push(char & 255);
  }
  return bytes;
}
function hdrToArrayBuffer(hdr, isDrawing8 = false, isInputEndian = false) {
  const SHORT_SIZE = 2;
  const FLOAT32_SIZE = 4;
  let isLittleEndian = true;
  if (isInputEndian) {
    isLittleEndian = hdr.littleEndian;
  }
  const byteArray = new Uint8Array(348);
  const view = new DataView(byteArray.buffer);
  view.setInt32(0, 348, isLittleEndian);
  view.setUint8(38, 114);
  view.setUint8(39, hdr.dim_info);
  for (let i = 0; i < 8; i++) {
    view.setUint16(40 + SHORT_SIZE * i, hdr.dims[i], isLittleEndian);
  }
  view.setFloat32(56, hdr.intent_p1, isLittleEndian);
  view.setFloat32(60, hdr.intent_p2, isLittleEndian);
  view.setFloat32(64, hdr.intent_p3, isLittleEndian);
  view.setInt16(68, hdr.intent_code, isLittleEndian);
  if (isDrawing8) {
    view.setInt16(70, 2, isLittleEndian);
    view.setInt16(72, 8, isLittleEndian);
  } else {
    view.setInt16(70, hdr.datatypeCode, isLittleEndian);
    view.setInt16(72, hdr.numBitsPerVoxel, isLittleEndian);
  }
  view.setInt16(74, hdr.slice_start, isLittleEndian);
  for (let i = 0; i < 8; i++) {
    view.setFloat32(76 + FLOAT32_SIZE * i, hdr.pixDims[i], isLittleEndian);
  }
  if (isDrawing8) {
    view.setFloat32(108, 352, isLittleEndian);
    view.setFloat32(112, 1, isLittleEndian);
    view.setFloat32(116, 0, isLittleEndian);
  } else {
    view.setFloat32(108, 352, isLittleEndian);
    view.setFloat32(112, hdr.scl_slope, isLittleEndian);
    view.setFloat32(116, hdr.scl_inter, isLittleEndian);
  }
  view.setInt16(120, hdr.slice_end, isLittleEndian);
  view.setUint8(122, hdr.slice_code);
  if (hdr.xyzt_units === 0) {
    view.setUint8(123, 10);
  } else {
    view.setUint8(123, hdr.xyzt_units);
  }
  if (isDrawing8) {
    view.setFloat32(124, 0, isLittleEndian);
    view.setFloat32(128, 0, isLittleEndian);
  } else {
    view.setFloat32(124, hdr.cal_max, isLittleEndian);
    view.setFloat32(128, hdr.cal_min, isLittleEndian);
  }
  view.setFloat32(132, hdr.slice_duration, isLittleEndian);
  view.setFloat32(136, hdr.toffset, isLittleEndian);
  byteArray.set(str2Buffer(hdr.description), 148);
  byteArray.set(str2Buffer(hdr.aux_file), 228);
  view.setInt16(252, hdr.qform_code, isLittleEndian);
  if (hdr.sform_code < 1 || hdr.sform_code < 1) {
    view.setInt16(254, 1, isLittleEndian);
  } else {
    view.setInt16(254, hdr.sform_code, isLittleEndian);
  }
  view.setFloat32(256, hdr.quatern_b, isLittleEndian);
  view.setFloat32(260, hdr.quatern_c, isLittleEndian);
  view.setFloat32(264, hdr.quatern_d, isLittleEndian);
  view.setFloat32(268, hdr.qoffset_x, isLittleEndian);
  view.setFloat32(272, hdr.qoffset_y, isLittleEndian);
  view.setFloat32(276, hdr.qoffset_z, isLittleEndian);
  const flattened = hdr.affine.flat();
  for (let i = 0; i < 12; i++) {
    view.setFloat32(280 + FLOAT32_SIZE * i, flattened[i], isLittleEndian);
  }
  view.setInt32(344, 3222382, true);
  return byteArray;
}
function getExtents(positions, forceOriginInVolume = true) {
  const nV = Math.round(positions.length / 3);
  const origin = vec3_exports.fromValues(0, 0, 0);
  const mn = vec3_exports.create();
  const mx = vec3_exports.create();
  let mxDx = 0;
  let nLoops = 1;
  if (forceOriginInVolume) {
    nLoops = 2;
  }
  for (let loop = 0; loop < nLoops; loop++) {
    mxDx = 0;
    for (let i = 0; i < nV; i++) {
      const v = vec3_exports.fromValues(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
      if (i === 0) {
        vec3_exports.copy(mn, v);
        vec3_exports.copy(mx, v);
      }
      vec3_exports.min(mn, mn, v);
      vec3_exports.max(mx, mx, v);
      vec3_exports.subtract(v, v, origin);
      const dx = vec3_exports.len(v);
      mxDx = Math.max(mxDx, dx);
    }
    if (loop + 1 >= nLoops) {
      break;
    }
    let ok = true;
    for (let j = 0; j < 3; ++j) {
      if (mn[j] > origin[j]) {
        ok = false;
      }
      if (mx[j] < origin[j]) {
        ok = false;
      }
    }
    if (ok) {
      break;
    }
    vec3_exports.lerp(origin, mn, mx, 0.5);
    log.debug("origin moved inside volume: ", origin);
  }
  const min4 = [mn[0], mn[1], mn[2]];
  const max5 = [mx[0], mx[1], mx[2]];
  const furthestVertexFromOrigin = mxDx;
  return { min: min4, max: max5, furthestVertexFromOrigin, origin };
}
function isAffineOK(mtx) {
  const iOK = [false, false, false, false];
  const jOK = [false, false, false, false];
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (isNaN(mtx[i][j])) {
        return false;
      }
    }
  }
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (mtx[i][j] === 0) {
        continue;
      }
      iOK[i] = true;
      jOK[j] = true;
    }
  }
  for (let i = 0; i < 3; i++) {
    if (!iOK[i]) {
      return false;
    }
    if (!jOK[i]) {
      return false;
    }
  }
  return true;
}
async function uncompressStream(stream) {
  const reader = stream.getReader();
  const { done, value } = await reader.read();
  if (done) {
    reader.releaseLock();
    return new ReadableStream({
      start(controller) {
        controller.close();
      }
    });
  }
  if (!value || value.length < 2) {
    reader.releaseLock();
    return new ReadableStream({
      start(controller) {
        if (value) {
          controller.enqueue(value);
        }
        controller.close();
      }
    });
  }
  const isGzip = value[0] === 31 && value[1] === 139;
  const uncompressedStream = new ReadableStream({
    async start(controller) {
      try {
        controller.enqueue(value);
        while (true) {
          const { done: done2, value: value2 } = await reader.read();
          if (done2) {
            controller.close();
            reader.releaseLock();
            break;
          }
          controller.enqueue(value2);
        }
      } catch (error) {
        controller.error(error);
        reader.releaseLock();
      }
    }
  });
  if (isGzip) {
    return uncompressedStream.pipeThrough(new DecompressionStream("gzip"));
  }
  return uncompressedStream;
}

// src/nvimage/index.ts
var NVImage = class _NVImage {
  /**
   *
   * @param dataBuffer - an array buffer of image data to load (there are also methods that abstract this more. See loadFromUrl, and loadFromFile)
   * @param name - a name for this image. Default is an empty string
   * @param colormap - a color map to use. default is gray
   * @param opacity - the opacity for this image. default is 1
   * @param pairedImgData - Allows loading formats where header and image are separate files (e.g. nifti.hdr, nifti.img)
   * @param cal_min - minimum intensity for color brightness/contrast
   * @param cal_max - maximum intensity for color brightness/contrast
   * @param trustCalMinMax - whether or not to trust cal_min and cal_max from the nifti header (trusting results in faster loading)
   * @param percentileFrac - the percentile to use for setting the robust range of the display values (smart intensity setting for images with large ranges)
   * @param ignoreZeroVoxels - whether or not to ignore zero voxels in setting the robust range of display values
   * @param useQFormNotSForm - give precedence to QForm (Quaternion) or SForm (Matrix)
   * @param colormapNegative - a color map to use for symmetrical negative intensities
   * @param frame4D - volume displayed, 0 indexed, must be less than nFrame4D
   *
   * FIXME the following params are documented but not included in the actual constructor
   * @param onColormapChange - callback for color map change
   * @param onOpacityChange -callback for color map change
   *
   * TODO the following parameters were not documented
   * @param imageType - TODO
   * @param cal_minNeg - TODO
   * @param cal_maxNeg - TODO
   * @param colorbarVisible - TODO
   * @param colormapLabel - TODO
   */
  constructor(dataBuffer = null, name = "", colormap = "gray", opacity = 1, pairedImgData = null, cal_min = NaN, cal_max = NaN, trustCalMinMax = true, percentileFrac = 0.02, ignoreZeroVoxels = false, useQFormNotSForm = false, colormapNegative = "", frame4D = 0, imageType = NVIMAGE_TYPE.UNKNOWN, cal_minNeg = NaN, cal_maxNeg = NaN, colorbarVisible = true, colormapLabel = null, colormapType = 0) {
    __publicField(this, "name");
    __publicField(this, "id");
    __publicField(this, "url");
    __publicField(this, "headers");
    __publicField(this, "_colormap");
    __publicField(this, "_opacity");
    __publicField(this, "percentileFrac");
    __publicField(this, "ignoreZeroVoxels");
    __publicField(this, "trustCalMinMax");
    __publicField(this, "colormapNegative");
    // TODO see niivue/loadDocument
    __publicField(this, "colormapLabel");
    __publicField(this, "colormapInvert");
    __publicField(this, "nFrame4D");
    __publicField(this, "frame4D");
    // indexed from 0!
    __publicField(this, "nTotalFrame4D");
    __publicField(this, "cal_minNeg");
    __publicField(this, "cal_maxNeg");
    __publicField(this, "colorbarVisible", true);
    __publicField(this, "modulationImage", null);
    __publicField(this, "modulateAlpha", 0);
    // if !=0, mod transparency with expon power |Alpha|
    // TODO this is some Daikon internal thing
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __publicField(this, "series", []);
    // for concatenating dicom images
    __publicField(this, "nVox3D");
    __publicField(this, "oblique_angle");
    __publicField(this, "maxShearDeg");
    __publicField(this, "useQFormNotSForm");
    __publicField(this, "colormapType");
    __publicField(this, "pixDims");
    __publicField(this, "matRAS");
    __publicField(this, "pixDimsRAS");
    __publicField(this, "obliqueRAS");
    __publicField(this, "dimsRAS");
    __publicField(this, "permRAS");
    __publicField(this, "img2RASstep");
    __publicField(this, "img2RASstart");
    __publicField(this, "toRAS");
    __publicField(this, "toRASvox");
    __publicField(this, "frac2mm");
    __publicField(this, "frac2mmOrtho");
    __publicField(this, "extentsMinOrtho");
    __publicField(this, "extentsMaxOrtho");
    __publicField(this, "mm2ortho");
    __publicField(this, "hdr", null);
    __publicField(this, "imageType");
    __publicField(this, "img");
    __publicField(this, "imaginary");
    // only for complex data
    __publicField(this, "v1");
    // only for FIB files
    __publicField(this, "fileObject");
    __publicField(this, "dims");
    __publicField(this, "onColormapChange", () => {
    });
    __publicField(this, "onOpacityChange", () => {
    });
    __publicField(this, "mm000");
    __publicField(this, "mm100");
    __publicField(this, "mm010");
    __publicField(this, "mm001");
    __publicField(this, "cal_min");
    __publicField(this, "cal_max");
    __publicField(this, "robust_min");
    __publicField(this, "robust_max");
    __publicField(this, "global_min");
    __publicField(this, "global_max");
    // TODO referenced by niivue/loadVolumes
    __publicField(this, "urlImgData");
    __publicField(this, "isManifest");
    __publicField(this, "limitFrames4D");
    this.init(
      dataBuffer,
      name,
      colormap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      useQFormNotSForm,
      colormapNegative,
      frame4D,
      imageType,
      cal_minNeg,
      cal_maxNeg,
      colorbarVisible,
      colormapLabel,
      colormapType
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  init(dataBuffer = null, name = "", colormap = "gray", opacity = 1, _pairedImgData = null, cal_min = NaN, cal_max = NaN, trustCalMinMax = true, percentileFrac = 0.02, ignoreZeroVoxels = false, useQFormNotSForm = false, colormapNegative = "", frame4D = 0, imageType = NVIMAGE_TYPE.UNKNOWN, cal_minNeg = NaN, cal_maxNeg = NaN, colorbarVisible = true, colormapLabel = null, colormapType = 0, imgRaw = null) {
    this.name = name;
    this.imageType = imageType;
    this.id = v4();
    this._colormap = colormap;
    this._opacity = opacity > 1 ? 1 : opacity;
    this.percentileFrac = percentileFrac;
    this.ignoreZeroVoxels = ignoreZeroVoxels;
    this.trustCalMinMax = trustCalMinMax;
    this.colormapNegative = colormapNegative;
    this.colormapLabel = colormapLabel;
    this.frame4D = frame4D;
    this.cal_minNeg = cal_minNeg;
    this.cal_maxNeg = cal_maxNeg;
    this.colorbarVisible = colorbarVisible;
    this.colormapType = colormapType;
    this.useQFormNotSForm = useQFormNotSForm;
    if (!dataBuffer) {
      return;
    }
    if (this.hdr && typeof this.hdr.magic === "number") {
      this.hdr.magic = "n+1";
    }
    this.nFrame4D = 1;
    if (this.hdr) {
      for (let i = 4; i < 7; i++) {
        if (this.hdr.dims[i] > 1) {
          this.nFrame4D *= this.hdr.dims[i];
        }
      }
    }
    this.frame4D = Math.min(this.frame4D, this.nFrame4D - 1);
    this.nTotalFrame4D = this.nFrame4D;
    if (!this.hdr || !imgRaw) {
      return;
    }
    this.nVox3D = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
    const bytesPerVol = this.nVox3D * (this.hdr.numBitsPerVoxel / 8);
    const nVol4D = imgRaw.byteLength / bytesPerVol;
    if (nVol4D !== this.nFrame4D) {
      if (nVol4D > 0 && nVol4D * bytesPerVol === imgRaw.byteLength) {
        log.debug("Loading the first " + nVol4D + " of " + this.nFrame4D + " volumes");
      } else {
        log.warn("This header does not match voxel data", this.hdr, imgRaw.byteLength);
      }
      this.nFrame4D = nVol4D;
    }
    if ((this.hdr.intent_code === 1007 /* NIFTI_INTENT_VECTOR */ || this.hdr.intent_code === 2003 /* NIFTI_INTENT_RGB_VECTOR */) && this.nFrame4D === 3 && this.hdr.datatypeCode === 16 /* DT_FLOAT32 */) {
      imgRaw = this.float32V1asRGBA(new Float32Array(imgRaw));
    }
    if (this.hdr.pixDims[1] === 0 || this.hdr.pixDims[2] === 0 || this.hdr.pixDims[3] === 0) {
      log.error("pixDims not plausible", this.hdr);
    }
    if (isNaN(this.hdr.scl_slope) || this.hdr.scl_slope === 0) {
      this.hdr.scl_slope = 1;
    }
    if (isNaN(this.hdr.scl_inter)) {
      this.hdr.scl_inter = 0;
    }
    let affineOK = isAffineOK(this.hdr.affine);
    if (useQFormNotSForm || !affineOK || this.hdr.qform_code > this.hdr.sform_code) {
      log.debug("spatial transform based on QForm");
      const b = this.hdr.quatern_b;
      const c = this.hdr.quatern_c;
      const d = this.hdr.quatern_d;
      const a = Math.sqrt(1 - (Math.pow(b, 2) + Math.pow(c, 2) + Math.pow(d, 2)));
      const qfac = this.hdr.pixDims[0] === 0 ? 1 : this.hdr.pixDims[0];
      const quatern_R = [
        [a * a + b * b - c * c - d * d, 2 * b * c - 2 * a * d, 2 * b * d + 2 * a * c],
        [2 * b * c + 2 * a * d, a * a + c * c - b * b - d * d, 2 * c * d - 2 * a * b],
        [2 * b * d - 2 * a * c, 2 * c * d + 2 * a * b, a * a + d * d - c * c - b * b]
      ];
      const affine = this.hdr.affine;
      for (let ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (let ctrIn = 0; ctrIn < 3; ctrIn += 1) {
          affine[ctrOut][ctrIn] = quatern_R[ctrOut][ctrIn] * this.hdr.pixDims[ctrIn + 1];
          if (ctrIn === 2) {
            affine[ctrOut][ctrIn] *= qfac;
          }
        }
      }
      affine[0][3] = this.hdr.qoffset_x;
      affine[1][3] = this.hdr.qoffset_y;
      affine[2][3] = this.hdr.qoffset_z;
      this.hdr.affine = affine;
    }
    affineOK = isAffineOK(this.hdr.affine);
    if (!affineOK) {
      log.debug("Defective NIfTI: spatial transform does not make sense");
      let x = this.hdr.pixDims[1];
      let y = this.hdr.pixDims[2];
      let z = this.hdr.pixDims[3];
      if (isNaN(x) || x === 0) {
        x = 1;
      }
      if (isNaN(y) || y === 0) {
        y = 1;
      }
      if (isNaN(z) || z === 0) {
        z = 1;
      }
      this.hdr.pixDims[1] = x;
      this.hdr.pixDims[2] = y;
      this.hdr.pixDims[3] = z;
      const affine = [
        [x, 0, 0, 0],
        [0, y, 0, 0],
        [0, 0, z, 0],
        [0, 0, 0, 1]
      ];
      this.hdr.affine = affine;
    }
    if (this.hdr.datatypeCode !== 128 /* DT_RGB24 */ && this.hdr.datatypeCode !== 2304 /* DT_RGBA32 */ && this.hdr.littleEndian !== isPlatformLittleEndian() && this.hdr.numBitsPerVoxel > 8) {
      if (this.hdr.numBitsPerVoxel === 16) {
        const u162 = new Uint16Array(imgRaw);
        for (let i = 0; i < u162.length; i++) {
          const val = u162[i];
          u162[i] = ((val & 255) << 8 | val >> 8 & 255) << 16 >> 16;
        }
      } else if (this.hdr.numBitsPerVoxel === 32) {
        const u32 = new Uint32Array(imgRaw);
        for (let i = 0; i < u32.length; i++) {
          const val = u32[i];
          u32[i] = (val & 255) << 24 | (val & 65280) << 8 | val >> 8 & 65280 | val >> 24 & 255;
        }
      } else if (this.hdr.numBitsPerVoxel === 64) {
        const numBytesPerVoxel = this.hdr.numBitsPerVoxel / 8;
        const u82 = new Uint8Array(imgRaw);
        for (let index = 0; index < u82.length; index += numBytesPerVoxel) {
          let offset = numBytesPerVoxel - 1;
          for (let x = 0; x < offset; x++) {
            const theByte = u82[index + x];
            u82[index + x] = u82[index + offset];
            u82[index + offset] = theByte;
            offset--;
          }
        }
      }
    }
    switch (this.hdr.datatypeCode) {
      case 2 /* DT_UINT8 */:
        this.img = new Uint8Array(imgRaw);
        break;
      case 4 /* DT_INT16 */:
        this.img = new Int16Array(imgRaw);
        break;
      case 16 /* DT_FLOAT32 */:
        this.img = new Float32Array(imgRaw);
        break;
      case 64 /* DT_FLOAT64 */:
        this.img = new Float64Array(imgRaw);
        break;
      case 128 /* DT_RGB24 */:
        this.img = new Uint8Array(imgRaw);
        break;
      case 512 /* DT_UINT16 */:
        this.img = new Uint16Array(imgRaw);
        break;
      case 2304 /* DT_RGBA32 */:
        this.img = new Uint8Array(imgRaw);
        break;
      case 256 /* DT_INT8 */: {
        const i8 = new Int8Array(imgRaw);
        const vx8 = i8.length;
        this.img = new Int16Array(vx8);
        for (let i = 0; i < vx8; i++) {
          this.img[i] = i8[i];
        }
        this.hdr.datatypeCode = 4 /* DT_INT16 */;
        this.hdr.numBitsPerVoxel = 16;
        break;
      }
      case 1 /* DT_BINARY */: {
        const nvox = this.hdr.dims[1] * this.hdr.dims[2] * Math.max(1, this.hdr.dims[3]) * Math.max(1, this.hdr.dims[4]);
        const img1 = new Uint8Array(imgRaw);
        this.img = new Uint8Array(nvox);
        const lut = new Uint8Array(8);
        for (let i = 0; i < 8; i++) {
          lut[i] = Math.pow(2, i);
        }
        let i1 = -1;
        for (let i = 0; i < nvox; i++) {
          const bit = i % 8;
          if (bit === 0) {
            i1++;
          }
          if ((img1[i1] & lut[bit]) !== 0) {
            this.img[i] = 1;
          }
        }
        this.hdr.datatypeCode = 2 /* DT_UINT8 */;
        this.hdr.numBitsPerVoxel = 8;
        break;
      }
      case 768 /* DT_UINT32 */: {
        const u32 = new Uint32Array(imgRaw);
        const vx32 = u32.length;
        this.img = new Float64Array(vx32);
        for (let i = 0; i < vx32 - 1; i++) {
          this.img[i] = u32[i];
        }
        this.hdr.datatypeCode = 64 /* DT_FLOAT64 */;
        break;
      }
      case 8 /* DT_INT32 */: {
        const i322 = new Int32Array(imgRaw);
        const vxi32 = i322.length;
        this.img = new Float64Array(vxi32);
        for (let i = 0; i < vxi32 - 1; i++) {
          this.img[i] = i322[i];
        }
        this.hdr.datatypeCode = 64 /* DT_FLOAT64 */;
        break;
      }
      case 1024 /* DT_INT64 */: {
        const i64 = new BigInt64Array(imgRaw);
        const vx = i64.length;
        this.img = new Float64Array(vx);
        for (let i = 0; i < vx - 1; i++) {
          this.img[i] = Number(i64[i]);
        }
        this.hdr.datatypeCode = 64 /* DT_FLOAT64 */;
        break;
      }
      case 32 /* DT_COMPLEX64 */: {
        const f32 = new Float32Array(imgRaw);
        const nvx = Math.floor(f32.length / 2);
        this.imaginary = new Float32Array(nvx);
        this.img = new Float32Array(nvx);
        let r = 0;
        for (let i = 0; i < nvx - 1; i++) {
          this.img[i] = f32[r];
          this.imaginary[i] = f32[r + 1];
          r += 2;
        }
        this.hdr.datatypeCode = 16 /* DT_FLOAT32 */;
        break;
      }
      default:
        throw new Error("datatype " + this.hdr.datatypeCode + " not supported");
    }
    this.calculateRAS();
    if (!isNaN(cal_min)) {
      this.hdr.cal_min = cal_min;
    }
    if (!isNaN(cal_max)) {
      this.hdr.cal_max = cal_max;
    }
    this.calMinMax();
  }
  static async new(dataBuffer = null, name = "", colormap = "gray", opacity = 1, pairedImgData = null, cal_min = NaN, cal_max = NaN, trustCalMinMax = true, percentileFrac = 0.02, ignoreZeroVoxels = false, useQFormNotSForm = false, colormapNegative = "", frame4D = 0, imageType = NVIMAGE_TYPE.UNKNOWN, cal_minNeg = NaN, cal_maxNeg = NaN, colorbarVisible = true, colormapLabel = null, colormapType = 0) {
    const newImg = new _NVImage();
    const re = /(?:\.([^.]+))?$/;
    let ext = re.exec(name)[1] || "";
    ext = ext.toUpperCase();
    if (ext === "GZ") {
      ext = re.exec(name.slice(0, -3))[1];
      ext = ext.toUpperCase();
    }
    let imgRaw = null;
    if (imageType === NVIMAGE_TYPE.UNKNOWN) {
      imageType = NVIMAGE_TYPE.parse(ext);
    }
    if (dataBuffer instanceof ArrayBuffer && dataBuffer.byteLength >= 2 && imageType === NVIMAGE_TYPE.DCM) {
      const u8s = new Uint8Array(dataBuffer);
      const isNifti1 = u8s[0] === 92 && u8s[1] === 1 || u8s[1] === 92 && u8s[0] === 1;
      if (isNifti1) {
        imageType = NVIMAGE_TYPE.NII;
      }
    }
    newImg.imageType = imageType;
    switch (imageType) {
      case NVIMAGE_TYPE.DCM_FOLDER:
      case NVIMAGE_TYPE.DCM_MANIFEST:
      case NVIMAGE_TYPE.DCM:
        return;
      case NVIMAGE_TYPE.FIB:
        ;
        [imgRaw, newImg.v1] = await newImg.readFIB(dataBuffer);
        break;
      case NVIMAGE_TYPE.MIH:
      case NVIMAGE_TYPE.MIF:
        imgRaw = await newImg.readMIF(dataBuffer, pairedImgData);
        break;
      case NVIMAGE_TYPE.NHDR:
      case NVIMAGE_TYPE.NRRD:
        imgRaw = await newImg.readNRRD(dataBuffer, pairedImgData);
        break;
      case NVIMAGE_TYPE.MHD:
      case NVIMAGE_TYPE.MHA:
        imgRaw = await newImg.readMHA(dataBuffer, pairedImgData);
        break;
      case NVIMAGE_TYPE.MGH:
      case NVIMAGE_TYPE.MGZ:
        imgRaw = await newImg.readMGH(dataBuffer);
        break;
      case NVIMAGE_TYPE.SRC:
        imgRaw = await newImg.readSRC(dataBuffer);
        break;
      case NVIMAGE_TYPE.V:
        imgRaw = newImg.readECAT(dataBuffer);
        break;
      case NVIMAGE_TYPE.V16:
        imgRaw = newImg.readV16(dataBuffer);
        break;
      case NVIMAGE_TYPE.VMR:
        imgRaw = newImg.readVMR(dataBuffer);
        break;
      case NVIMAGE_TYPE.HEAD:
        imgRaw = await newImg.readHEAD(dataBuffer, pairedImgData);
        break;
      case NVIMAGE_TYPE.BMP:
        imgRaw = await newImg.readBMP(dataBuffer);
        break;
      case NVIMAGE_TYPE.NPY:
        imgRaw = await newImg.readNPY(dataBuffer);
        break;
      case NVIMAGE_TYPE.NPZ:
        imgRaw = await newImg.readNPZ(dataBuffer);
        break;
      case NVIMAGE_TYPE.ZARR:
        throw new Error("Image type ZARR not (yet) supported");
      case NVIMAGE_TYPE.NII:
        if (isCompressed(dataBuffer)) {
          dataBuffer = await decompressAsync(dataBuffer);
        }
        newImg.hdr = await readHeaderAsync(dataBuffer);
        if (newImg.hdr !== null) {
          if (newImg.hdr.cal_min === 0 && newImg.hdr.cal_max === 255) {
            newImg.hdr.cal_max = 0;
          }
          if (isCompressed(dataBuffer)) {
            imgRaw = readImage(newImg.hdr, await decompressAsync(dataBuffer));
          } else {
            imgRaw = readImage(newImg.hdr, dataBuffer);
          }
        }
        break;
      default:
        throw new Error("Image type not supported");
    }
    newImg.init(
      dataBuffer,
      name,
      colormap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      useQFormNotSForm,
      colormapNegative,
      frame4D,
      imageType,
      cal_minNeg,
      cal_maxNeg,
      colorbarVisible,
      colormapLabel,
      colormapType,
      imgRaw
    );
    return newImg;
  }
  // not included in public docs
  // detect difference between voxel grid and world space
  // https://github.com/afni/afni/blob/25e77d564f2c67ff480fa99a7b8e48ec2d9a89fc/src/thd_coords.c#L717
  computeObliqueAngle(mtx44) {
    const mtx = mat4_exports.clone(mtx44);
    mat4_exports.transpose(mtx, mtx44);
    const dxtmp = Math.sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1] + mtx[2] * mtx[2]);
    const xmax = Math.max(Math.max(Math.abs(mtx[0]), Math.abs(mtx[1])), Math.abs(mtx[2])) / dxtmp;
    const dytmp = Math.sqrt(mtx[4] * mtx[4] + mtx[5] * mtx[5] + mtx[6] * mtx[6]);
    const ymax = Math.max(Math.max(Math.abs(mtx[4]), Math.abs(mtx[5])), Math.abs(mtx[6])) / dytmp;
    const dztmp = Math.sqrt(mtx[8] * mtx[8] + mtx[9] * mtx[9] + mtx[10] * mtx[10]);
    const zmax = Math.max(Math.max(Math.abs(mtx[8]), Math.abs(mtx[9])), Math.abs(mtx[10])) / dztmp;
    const fig_merit = Math.min(Math.min(xmax, ymax), zmax);
    let oblique_angle = Math.abs(Math.acos(fig_merit) * 180 / 3.141592653);
    if (oblique_angle > 0.01) {
      log.warn("Warning voxels not aligned with world space: " + oblique_angle + " degrees from plumb.\n");
    } else {
      oblique_angle = 0;
    }
    return oblique_angle;
  }
  float32V1asRGBA(inImg) {
    if (inImg.length !== this.nVox3D * 3) {
      log.warn("float32V1asRGBA() expects " + this.nVox3D * 3 + "voxels, got ", +inImg.length);
    }
    const f32 = inImg.slice();
    this.hdr.datatypeCode = 2304 /* DT_RGBA32 */;
    this.nFrame4D = 1;
    for (let i = 4; i < 7; i++) {
      this.hdr.dims[i] = 1;
    }
    this.hdr.dims[0] = 3;
    const imgRaw = new Uint8Array(this.nVox3D * 4);
    let mx = 1;
    for (let i = 0; i < this.nVox3D * 3; i++) {
      if (isNaN(f32[i])) {
        continue;
      }
      mx = Math.max(mx, Math.abs(f32[i]));
    }
    const slope = 255 / mx;
    const nVox3D2 = this.nVox3D * 2;
    let j = 0;
    for (let i = 0; i < this.nVox3D; i++) {
      const x = f32[i];
      const y = f32[i + this.nVox3D];
      const z = f32[i + nVox3D2];
      imgRaw[j] = Math.abs(x * slope);
      imgRaw[j + 1] = Math.abs(y * slope);
      imgRaw[j + 2] = Math.abs(z * slope);
      const xNeg = Number(x > 0) * 1;
      const yNeg = Number(y > 0) * 2;
      const zNeg = Number(z > 0) * 4;
      let alpha = 248 + xNeg + yNeg + zNeg;
      if (Math.abs(x) + Math.abs(y) + Math.abs(z) < 0.1) {
        alpha = 0;
      }
      ;
      imgRaw[j + 3] = alpha;
      j += 4;
    }
    return imgRaw;
  }
  loadImgV1(isFlipX = false, isFlipY = false, isFlipZ = false) {
    let v1 = this.v1;
    if (!v1 && this.nFrame4D === 3 && this.img.constructor === Float32Array) {
      v1 = this.img.slice();
    }
    if (!v1) {
      log.warn("Image does not have V1 data");
      return false;
    }
    if (isFlipX) {
      for (let i = 0; i < this.nVox3D; i++) {
        v1[i] = -v1[i];
      }
    }
    if (isFlipY) {
      for (let i = this.nVox3D; i < 2 * this.nVox3D; i++) {
        v1[i] = -v1[i];
      }
    }
    if (isFlipZ) {
      for (let i = 2 * this.nVox3D; i < 3 * this.nVox3D; i++) {
        v1[i] = -v1[i];
      }
    }
    this.img = this.float32V1asRGBA(v1);
    return true;
  }
  // not included in public docs
  // detect difference between voxel grid and world space
  calculateOblique() {
    if (!this.matRAS) {
      throw new Error("matRAS not defined");
    }
    if (this.pixDimsRAS === void 0) {
      throw new Error("pixDimsRAS not defined");
    }
    if (!this.dimsRAS) {
      throw new Error("dimsRAS not defined");
    }
    this.oblique_angle = this.computeObliqueAngle(this.matRAS);
    const LPI = this.vox2mm([0, 0, 0], this.matRAS);
    const X1mm = this.vox2mm([1 / this.pixDimsRAS[1], 0, 0], this.matRAS);
    const Y1mm = this.vox2mm([0, 1 / this.pixDimsRAS[2], 0], this.matRAS);
    const Z1mm = this.vox2mm([0, 0, 1 / this.pixDimsRAS[3]], this.matRAS);
    vec3_exports.subtract(X1mm, X1mm, LPI);
    vec3_exports.subtract(Y1mm, Y1mm, LPI);
    vec3_exports.subtract(Z1mm, Z1mm, LPI);
    const oblique = mat4_exports.fromValues(
      X1mm[0],
      X1mm[1],
      X1mm[2],
      0,
      Y1mm[0],
      Y1mm[1],
      Y1mm[2],
      0,
      Z1mm[0],
      Z1mm[1],
      Z1mm[2],
      0,
      0,
      0,
      0,
      1
    );
    this.obliqueRAS = mat4_exports.clone(oblique);
    const XY = Math.abs(90 - vec3_exports.angle(X1mm, Y1mm) * (180 / Math.PI));
    const XZ = Math.abs(90 - vec3_exports.angle(X1mm, Z1mm) * (180 / Math.PI));
    const YZ = Math.abs(90 - vec3_exports.angle(Y1mm, Z1mm) * (180 / Math.PI));
    this.maxShearDeg = Math.max(Math.max(XY, XZ), YZ);
    if (this.maxShearDeg > 0.1) {
      log.warn("Warning: voxels are rhomboidal, maximum shear is %f degrees.", this.maxShearDeg);
    }
    const dim = vec4_exports.fromValues(this.dimsRAS[1], this.dimsRAS[2], this.dimsRAS[3], 1);
    const sform = mat4_exports.clone(this.matRAS);
    mat4_exports.transpose(sform, sform);
    const shim = vec4_exports.fromValues(-0.5, -0.5, -0.5, 0);
    mat4_exports.translate(sform, sform, vec3_exports.fromValues(shim[0], shim[1], shim[2]));
    sform[0] *= dim[0];
    sform[1] *= dim[0];
    sform[2] *= dim[0];
    sform[4] *= dim[1];
    sform[5] *= dim[1];
    sform[6] *= dim[1];
    sform[8] *= dim[2];
    sform[9] *= dim[2];
    sform[10] *= dim[2];
    this.frac2mm = mat4_exports.clone(sform);
    const pixdimX = this.pixDimsRAS[1];
    const pixdimY = this.pixDimsRAS[2];
    const pixdimZ = this.pixDimsRAS[3];
    const oform = mat4_exports.clone(sform);
    oform[0] = pixdimX * dim[0];
    oform[1] = 0;
    oform[2] = 0;
    oform[4] = 0;
    oform[5] = pixdimY * dim[1];
    oform[6] = 0;
    oform[8] = 0;
    oform[9] = 0;
    oform[10] = pixdimZ * dim[2];
    const originVoxel = this.mm2vox([0, 0, 0], true);
    oform[12] = (-originVoxel[0] - 0.5) * pixdimX;
    oform[13] = (-originVoxel[1] - 0.5) * pixdimY;
    oform[14] = (-originVoxel[2] - 0.5) * pixdimZ;
    this.frac2mmOrtho = mat4_exports.clone(oform);
    this.extentsMinOrtho = [oform[12], oform[13], oform[14]];
    this.extentsMaxOrtho = [oform[0] + oform[12], oform[5] + oform[13], oform[10] + oform[14]];
    this.mm2ortho = mat4_exports.create();
    mat4_exports.invert(this.mm2ortho, oblique);
  }
  // not included in public docs
  // convert AFNI head/brik space to NIfTI format
  // https://github.com/afni/afni/blob/d6997e71f2b625ac1199460576d48f3136dac62c/src/thd_niftiwrite.c#L315
  THD_daxes_to_NIFTI(xyzDelta, xyzOrigin, orientSpecific) {
    const hdr = this.hdr;
    if (hdr === null) {
      throw new Error("HDR is not set");
    }
    hdr.sform_code = 2;
    const ORIENT_xyz = "xxyyzzg";
    let nif_x_axnum = -1;
    let nif_y_axnum = -1;
    let nif_z_axnum = -1;
    const axcode = ["x", "y", "z"];
    axcode[0] = ORIENT_xyz[orientSpecific[0]];
    axcode[1] = ORIENT_xyz[orientSpecific[1]];
    axcode[2] = ORIENT_xyz[orientSpecific[2]];
    const axstep = xyzDelta.slice(0, 3);
    const axstart = xyzOrigin.slice(0, 3);
    for (let ii = 0; ii < 3; ii++) {
      if (axcode[ii] === "x") {
        nif_x_axnum = ii;
      } else if (axcode[ii] === "y") {
        nif_y_axnum = ii;
      } else {
        nif_z_axnum = ii;
      }
    }
    if (nif_x_axnum < 0 || nif_y_axnum < 0 || nif_z_axnum < 0) {
      return;
    }
    if (nif_x_axnum === nif_y_axnum || nif_x_axnum === nif_z_axnum || nif_y_axnum === nif_z_axnum) {
      return;
    }
    hdr.pixDims[1] = Math.abs(axstep[0]);
    hdr.pixDims[2] = Math.abs(axstep[1]);
    hdr.pixDims[3] = Math.abs(axstep[2]);
    hdr.affine = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];
    hdr.affine[0][nif_x_axnum] = -axstep[nif_x_axnum];
    hdr.affine[1][nif_y_axnum] = -axstep[nif_y_axnum];
    hdr.affine[2][nif_z_axnum] = axstep[nif_z_axnum];
    hdr.affine[0][3] = -axstart[nif_x_axnum];
    hdr.affine[1][3] = -axstart[nif_y_axnum];
    hdr.affine[2][3] = axstart[nif_z_axnum];
  }
  // not included in public docs
  // determine spacing voxel centers (rows, columns, slices)
  SetPixDimFromSForm() {
    if (!this.hdr) {
      throw new Error("hdr not defined");
    }
    const m = this.hdr.affine;
    const mat = mat4_exports.fromValues(
      m[0][0],
      m[0][1],
      m[0][2],
      m[0][3],
      m[1][0],
      m[1][1],
      m[1][2],
      m[1][3],
      m[2][0],
      m[2][1],
      m[2][2],
      m[2][3],
      m[3][0],
      m[3][1],
      m[3][2],
      m[3][3]
    );
    const mm000 = this.vox2mm([0, 0, 0], mat);
    const mm100 = this.vox2mm([1, 0, 0], mat);
    vec3_exports.subtract(mm100, mm100, mm000);
    const mm010 = this.vox2mm([0, 1, 0], mat);
    vec3_exports.subtract(mm010, mm010, mm000);
    const mm001 = this.vox2mm([0, 0, 1], mat);
    vec3_exports.subtract(mm001, mm001, mm000);
    this.hdr.pixDims[1] = vec3_exports.length(mm100);
    this.hdr.pixDims[2] = vec3_exports.length(mm010);
    this.hdr.pixDims[3] = vec3_exports.length(mm001);
  }
  // not included in public docs
  // read DICOM format image and treat it like a NIfTI
  // -----------------
  // readDICOM(buf: ArrayBuffer | ArrayBuffer[]): ArrayBuffer {
  //   this.series = new daikon.Series()
  //   // parse DICOM file
  //   if (Array.isArray(buf)) {
  //     for (let i = 0; i < buf.length; i++) {
  //       const dataview = new DataView(buf[i])
  //       const image = daikon.Series.parseImage(dataview)
  //       if (image === null) {
  //         log.error(daikon.Series.parserError)
  //       } else if (image.hasPixelData()) {
  //         // if it's part of the same series, add it
  //         if (this.series.images.length === 0 || image.getSeriesId() === this.series.images[0].getSeriesId()) {
  //           this.series.addImage(image)
  //         }
  //       } // if hasPixelData
  //     } // for i
  //   } else {
  //     // not a dicom folder drop
  //     const image = daikon.Series.parseImage(new DataView(buf))
  //     if (image === null) {
  //       log.error(daikon.Series.parserError)
  //     } else if (image.hasPixelData()) {
  //       // if it's part of the same series, add it
  //       if (this.series.images.length === 0 || image.getSeriesId() === this.series.images[0].getSeriesId()) {
  //         this.series.addImage(image)
  //       }
  //     }
  //   }
  //   // order the image files, determines number of frames, etc.
  //   this.series.buildSeries()
  //   // output some header info
  //   this.hdr = new nifti.NIFTI1()
  //   const hdr = this.hdr
  //   hdr.scl_inter = 0
  //   hdr.scl_slope = 1
  //   if (this.series.images[0].getDataScaleIntercept()) {
  //     hdr.scl_inter = this.series.images[0].getDataScaleIntercept()
  //   }
  //   if (this.series.images[0].getDataScaleSlope()) {
  //     hdr.scl_slope = this.series.images[0].getDataScaleSlope()
  //   }
  //   hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0]
  //   hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0]
  //   hdr.dims[1] = this.series.images[0].getCols()
  //   hdr.dims[2] = this.series.images[0].getRows()
  //   hdr.dims[3] = this.series.images[0].getNumberOfFrames()
  //   if (this.series.images.length > 1) {
  //     if (hdr.dims[3] > 1) {
  //       log.debug('To Do: multiple slices per file and multiple files (XA30 DWI)')
  //     }
  //     hdr.dims[3] = this.series.images.length
  //   }
  //   const rc = this.series.images[0].getPixelSpacing() // TODO: order?
  //   hdr.pixDims[1] = rc[0]
  //   hdr.pixDims[2] = rc[1]
  //   if (this.series.images.length > 1) {
  //     // Multiple slices. The depth of a pixel is the physical distance between offsets. This is not the same as slice
  //     // spacing for tilted slices (skew).
  //     const p0 = vec3.fromValues(...(this.series.images[0].getImagePosition() as [number, number, number]))
  //     const p1 = vec3.fromValues(...(this.series.images[1].getImagePosition() as [number, number, number]))
  //     const n = vec3.fromValues(0, 0, 0)
  //     vec3.subtract(n, p0, p1)
  //     hdr.pixDims[3] = vec3.length(n)
  //   } else {
  //     // Single slice. Use the slice thickness as pixel depth.
  //     hdr.pixDims[3] = this.series.images[0].getSliceThickness()
  //   }
  //   hdr.pixDims[4] = this.series.images[0].getTR() / 1000.0 // msec -> sec
  //   const dt = this.series.images[0].getDataType() // 2=int,3=uint,4=float,
  //   const bpv = this.series.images[0].getBitsAllocated()
  //   hdr.numBitsPerVoxel = bpv
  //   this.hdr.littleEndian = this.series.images[0].littleEndian
  //   if (bpv === 8 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT8
  //   } else if (bpv === 8 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT8
  //   } else if (bpv === 16 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT16
  //   } else if (bpv === 16 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT16
  //   } else if (bpv === 32 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT32
  //   } else if (bpv === 32 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT32
  //   } else if (bpv === 32 && dt === 4) {
  //     hdr.datatypeCode = NiiDataType.DT_FLOAT32
  //   } else if (bpv === 64 && dt === 4) {
  //     hdr.datatypeCode = NiiDataType.DT_FLOAT64
  //   } else if (bpv === 1) {
  //     hdr.datatypeCode = NiiDataType.DT_BINARY
  //   } else {
  //     log.warn('Unsupported DICOM format: ' + dt + ' ' + bpv)
  //   }
  //   const voxelDimensions = hdr.pixDims.slice(1, 4)
  //   const m = getBestTransform(
  //     this.series.images[0].getImageDirections(),
  //     voxelDimensions,
  //     this.series.images[0].getImagePosition()
  //   )
  //   if (m) {
  //     hdr.sform_code = 1
  //     hdr.affine = [
  //       [m[0][0], m[0][1], m[0][2], m[0][3]],
  //       [m[1][0], m[1][1], m[1][2], m[1][3]],
  //       [m[2][0], m[2][1], m[2][2], m[2][3]],
  //       [0, 0, 0, 1]
  //     ]
  //   }
  //   let data
  //   let length = this.series.validatePixelDataLength(this.series.images[0])
  //   const buffer = new Uint8Array(new ArrayBuffer(length * this.series.images.length))
  //   // implementation copied from:
  //   // https://github.com/rii-mango/Daikon/blob/bbe08bad9758dfbdf31ca22fb79048c7bad85706/src/series.js#L496
  //   for (let i = 0; i < this.series.images.length; i++) {
  //     if (this.series.isMosaic) {
  //       data = this.series.getMosaicData(this.series.images[i], this.series.images[i].getPixelDataBytes())
  //     } else {
  //       data = this.series.images[i].getPixelDataBytes()
  //     }
  //     length = this.series.validatePixelDataLength(this.series.images[i])
  //     this.series.images[i].clearPixelData()
  //     buffer.set(new Uint8Array(data, 0, length), length * i)
  //   } // for images.length
  //   return buffer.buffer
  // } // readDICOM()
  // -----------------------
  // not included in public docs
  // read ECAT7 format image
  // https://github.com/openneuropet/PET2BIDS/tree/28aae3fab22309047d36d867c624cd629c921ca6/ecat_validation/ecat_info
  readECAT(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const reader = new DataView(buffer);
    const signature = reader.getInt32(0, false);
    const filetype = reader.getInt16(50, false);
    if (signature !== 1296127058 || filetype < 1 || filetype > 14) {
      throw new Error("Not a valid ECAT file");
    }
    let pos = 512;
    let vols = 0;
    const frame_duration = [];
    let rawImg = new Float32Array();
    while (true) {
      const hdr0 = reader.getInt32(pos, false);
      const hdr3 = reader.getInt32(pos + 12, false);
      if (hdr0 + hdr3 !== 31) {
        break;
      }
      let lpos = pos + 20;
      let r = 0;
      let voloffset = 0;
      while (r < 31) {
        voloffset = reader.getInt32(lpos, false);
        lpos += 16;
        if (voloffset === 0) {
          break;
        }
        r++;
        let ipos = voloffset * 512;
        const spos = ipos - 512;
        const data_type = reader.getUint16(spos, false);
        hdr.dims[1] = reader.getUint16(spos + 4, false);
        hdr.dims[2] = reader.getUint16(spos + 6, false);
        hdr.dims[3] = reader.getUint16(spos + 8, false);
        const scale_factor = reader.getFloat32(spos + 26, false);
        hdr.pixDims[1] = reader.getFloat32(spos + 34, false) * 10;
        hdr.pixDims[2] = reader.getFloat32(spos + 38, false) * 10;
        hdr.pixDims[3] = reader.getFloat32(spos + 42, false) * 10;
        hdr.pixDims[4] = reader.getUint32(spos + 46, false) / 1e3;
        frame_duration.push(hdr.pixDims[4]);
        const nvox3D = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
        const newImg = new Float32Array(nvox3D);
        if (data_type === 1) {
          for (let i = 0; i < nvox3D; i++) {
            newImg[i] = reader.getUint8(ipos) * scale_factor;
            ipos++;
          }
        } else if (data_type === 6) {
          for (let i = 0; i < nvox3D; i++) {
            newImg[i] = reader.getUint16(ipos, false) * scale_factor;
            ipos += 2;
          }
        } else if (data_type === 7) {
          for (let i = 0; i < nvox3D; i++) {
            newImg[i] = reader.getUint32(ipos, false) * scale_factor;
            ipos += 4;
          }
        } else {
          log.warn("Unknown ECAT data type " + data_type);
        }
        const prevImg = rawImg.slice(0);
        rawImg = new Float32Array(prevImg.length + newImg.length);
        rawImg.set(prevImg);
        rawImg.set(newImg, prevImg.length);
        vols++;
      }
      if (voloffset === 0) {
        break;
      }
      pos += 512;
    }
    hdr.dims[4] = vols;
    hdr.pixDims[4] = frame_duration[0];
    if (vols > 1) {
      hdr.dims[0] = 4;
      let isFDvaries = false;
      for (let i = 0; i < vols; i++) {
        if (frame_duration[i] !== frame_duration[0]) {
          isFDvaries = true;
        }
      }
      if (isFDvaries) {
        log.warn("Frame durations vary");
      }
    }
    hdr.sform_code = 1;
    hdr.affine = [
      [-hdr.pixDims[1], 0, 0, (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
      [0, -hdr.pixDims[2], 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
      [0, 0, -hdr.pixDims[3], (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
      [0, 0, 0, 1]
    ];
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = 16 /* DT_FLOAT32 */;
    return rawImg;
  }
  // readECAT()
  readV16(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const reader = new DataView(buffer);
    hdr.dims[1] = reader.getUint16(0, true);
    hdr.dims[2] = reader.getUint16(2, true);
    hdr.dims[3] = reader.getUint16(4, true);
    const nBytes = 2 * hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    if (nBytes + 6 !== buffer.byteLength) {
      log.warn("This does not look like a valid BrainVoyager V16 file");
    }
    hdr.numBitsPerVoxel = 16;
    hdr.datatypeCode = 512 /* DT_UINT16 */;
    log.warn("Warning: V16 files have no spatial transforms");
    hdr.affine = [
      [0, 0, -hdr.pixDims[1], (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
      [-hdr.pixDims[2], 0, 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
      [0, -hdr.pixDims[3], 0, (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
      [0, 0, 0, 1]
    ];
    hdr.littleEndian = true;
    return buffer.slice(6);
  }
  // readV16()
  async readNPY(buffer) {
    function getTypeSize(dtype2) {
      const typeMap = {
        "|b1": 1,
        // Boolean
        "<i1": 1,
        // Int8
        "<u1": 1,
        // UInt8
        "<i2": 2,
        // Int16
        "<u2": 2,
        // UInt16
        "<i4": 4,
        // Int32
        "<u4": 4,
        // UInt32
        "<f4": 4,
        // Float32
        "<f8": 8
        // Float64
      };
      return typeMap[dtype2] ?? 1;
    }
    function getDataTypeCode(dtype2) {
      const typeMap = {
        "|b1": 2,
        // DT_BINARY
        "<i1": 256,
        // DT_INT8
        "<u1": 2,
        // DT_UINT8
        "<i2": 4,
        // DT_INT16
        "<u2": 512,
        // DT_UINT16
        "<i4": 8,
        // DT_INT32
        "<u4": 768,
        // DT_UINT32
        "<f4": 16,
        // DT_FLOAT32
        "<f8": 64
        // DT_FLOAT64
      };
      return typeMap[dtype2] ?? 16;
    }
    const dv = new DataView(buffer);
    const magicBytes = [dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3), dv.getUint8(4), dv.getUint8(5)];
    const expectedMagic = [147, 78, 85, 77, 80, 89];
    if (!magicBytes.every((byte, i) => byte === expectedMagic[i])) {
      throw new Error("Not a valid NPY file: Magic number mismatch");
    }
    const _version = dv.getUint8(6);
    const _minorVersion = dv.getUint8(7);
    const headerLen = dv.getUint16(8, true);
    const headerText = new TextDecoder("utf-8").decode(buffer.slice(10, 10 + headerLen));
    const shapeMatch = headerText.match(/'shape': \((.*?)\)/);
    if (!shapeMatch) {
      throw new Error("Invalid NPY header: Shape not found");
    }
    const shape = shapeMatch[1].split(",").map((s) => s.trim()).filter((s) => s !== "").map(Number);
    const dtypeMatch = headerText.match(/'descr': '([^']+)'/);
    if (!dtypeMatch) {
      throw new Error("Invalid NPY header: Data type not found");
    }
    const dtype = dtypeMatch[1];
    const numElements = shape.reduce((a, b) => a * b, 1);
    const dataStart = 10 + headerLen;
    const dataBuffer = buffer.slice(dataStart, dataStart + numElements * getTypeSize(dtype));
    const width = shape.length > 0 ? shape[shape.length - 1] : 1;
    const height = shape.length > 1 ? shape[shape.length - 2] : 1;
    const slices = shape.length > 2 ? shape[shape.length - 3] : 1;
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims = [3, width, height, slices, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    hdr.affine = [
      [hdr.pixDims[1], 0, 0, -(hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
      [0, -hdr.pixDims[2], 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
      [0, 0, -hdr.pixDims[3], (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
      [0, 0, 0, 1]
    ];
    hdr.numBitsPerVoxel = getTypeSize(dtype) * 8;
    hdr.datatypeCode = getDataTypeCode(dtype);
    return dataBuffer;
  }
  async readNPZ(buffer) {
    const zip = new Zip(buffer);
    for (let i = 0; i < zip.entries.length; i++) {
      const entry = zip.entries[i];
      if (entry.fileName.toLowerCase().endsWith(".npy")) {
        const data = await entry.extract();
        return await this.readNPY(data.buffer);
      }
    }
  }
  async imageDataFromArrayBuffer(buffer) {
    return new Promise((resolve, reject) => {
      const blob = new Blob([buffer]);
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.src = url;
      img.onload = () => {
        URL.revokeObjectURL(url);
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get 2D context"));
          return;
        }
        ctx.drawImage(img, 0, 0);
        resolve(ctx.getImageData(0, 0, img.width, img.height));
      };
      img.onerror = (err2) => {
        URL.revokeObjectURL(url);
        reject(err2);
      };
    });
  }
  async readBMP(buffer) {
    const imageData = await this.imageDataFromArrayBuffer(buffer);
    const { width, height, data } = imageData;
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims = [3, width, height, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    hdr.affine = [
      [hdr.pixDims[1], 0, 0, -(hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
      [0, -hdr.pixDims[2], 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
      [0, 0, -hdr.pixDims[3], (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
      [0, 0, 0, 1]
    ];
    hdr.numBitsPerVoxel = 8;
    hdr.datatypeCode = 2304 /* DT_RGBA32 */;
    let isGrayscale = true;
    for (let i = 0; i < data.length; i += 4) {
      if (data[i] !== data[i + 1] || data[i] !== data[i + 2]) {
        isGrayscale = false;
        break;
      }
    }
    if (isGrayscale) {
      hdr.datatypeCode = 2 /* DT_UINT8 */;
      const grayscaleData = new Uint8Array(width * height);
      for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        grayscaleData[j] = data[i];
      }
      return grayscaleData.buffer;
    }
    return data.buffer;
  }
  // not included in public docs
  // read brainvoyager format VMR image
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/343-developer-guide-2-6-the-format-of-vmr-files
  readVMR(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const reader = new DataView(buffer);
    const version2 = reader.getUint16(0, true);
    if (version2 !== 4) {
      log.warn("Not a valid version 4 VMR image");
    }
    hdr.dims[1] = reader.getUint16(2, true);
    hdr.dims[2] = reader.getUint16(4, true);
    hdr.dims[3] = reader.getUint16(6, true);
    const nBytes = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    if (version2 >= 4) {
      let pos = 8 + nBytes;
      const nSpatialTransforms = reader.getUint32(pos + 88, true);
      pos = pos + 92;
      if (nSpatialTransforms > 0) {
        const len4 = buffer.byteLength;
        for (let i = 0; i < nSpatialTransforms; i++) {
          while (pos < len4 && reader.getUint8(pos) !== 0) {
            pos++;
          }
          pos++;
          pos += 4;
          while (pos < len4 && reader.getUint8(pos) !== 0) {
            pos++;
          }
          pos++;
          const nValues = reader.getUint32(pos, true);
          pos += 4;
          for (let j = 0; j < nValues; j++) {
            pos += 4;
          }
        }
      }
      hdr.pixDims[1] = reader.getFloat32(pos + 2, true);
      hdr.pixDims[2] = reader.getFloat32(pos + 6, true);
      hdr.pixDims[3] = reader.getFloat32(pos + 10, true);
    }
    log.warn("Warning: VMR spatial transform not implemented");
    hdr.affine = [
      [0, 0, -hdr.pixDims[1], (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
      [-hdr.pixDims[2], 0, 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
      [0, -hdr.pixDims[3], 0, (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
      [0, 0, 0, 1]
    ];
    log.debug(hdr);
    hdr.numBitsPerVoxel = 8;
    hdr.datatypeCode = 2 /* DT_UINT8 */;
    return buffer.slice(8, 8 + nBytes);
  }
  // readVMR()
  // not included in public docs
  // read FreeSurfer MGH format image
  async readMGH(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.littleEndian = false;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    let raw = buffer;
    let reader = new DataView(raw);
    if (reader.getUint8(0) === 31 && reader.getUint8(1) === 139) {
      raw = await NVUtilities.decompressToBuffer(new Uint8Array(buffer));
      reader = new DataView(raw);
    }
    const version2 = reader.getInt32(0, false);
    const width = reader.getInt32(4, false);
    const height = reader.getInt32(8, false);
    const depth = reader.getInt32(12, false);
    const nframes = reader.getInt32(16, false);
    const mtype = reader.getInt32(20, false);
    const spacingX = reader.getFloat32(30, false);
    const spacingY = reader.getFloat32(34, false);
    const spacingZ = reader.getFloat32(38, false);
    const xr = reader.getFloat32(42, false);
    const xa = reader.getFloat32(46, false);
    const xs = reader.getFloat32(50, false);
    const yr = reader.getFloat32(54, false);
    const ya = reader.getFloat32(58, false);
    const ys = reader.getFloat32(62, false);
    const zr = reader.getFloat32(66, false);
    const za = reader.getFloat32(70, false);
    const zs = reader.getFloat32(74, false);
    const cr = reader.getFloat32(78, false);
    const ca = reader.getFloat32(82, false);
    const cs = reader.getFloat32(86, false);
    if (version2 !== 1 || mtype < 0 || mtype > 4) {
      log.warn("Not a valid MGH file");
    }
    if (mtype === 0) {
      hdr.numBitsPerVoxel = 8;
      hdr.datatypeCode = 2 /* DT_UINT8 */;
    } else if (mtype === 4) {
      hdr.numBitsPerVoxel = 16;
      hdr.datatypeCode = 4 /* DT_INT16 */;
    } else if (mtype === 1) {
      hdr.numBitsPerVoxel = 32;
      hdr.datatypeCode = 8 /* DT_INT32 */;
    } else if (mtype === 3) {
      hdr.numBitsPerVoxel = 32;
      hdr.datatypeCode = 16 /* DT_FLOAT32 */;
    }
    hdr.dims[1] = width;
    hdr.dims[2] = height;
    hdr.dims[3] = depth;
    hdr.dims[4] = nframes;
    if (nframes > 1) {
      hdr.dims[0] = 4;
    }
    hdr.pixDims[1] = spacingX;
    hdr.pixDims[2] = spacingY;
    hdr.pixDims[3] = spacingZ;
    hdr.vox_offset = 284;
    hdr.sform_code = 1;
    const rot44 = mat4_exports.fromValues(
      xr * hdr.pixDims[1],
      yr * hdr.pixDims[2],
      zr * hdr.pixDims[3],
      0,
      xa * hdr.pixDims[1],
      ya * hdr.pixDims[2],
      za * hdr.pixDims[3],
      0,
      xs * hdr.pixDims[1],
      ys * hdr.pixDims[2],
      zs * hdr.pixDims[3],
      0,
      0,
      0,
      0,
      1
    );
    const Pcrs = [hdr.dims[1] / 2, hdr.dims[2] / 2, hdr.dims[3] / 2, 1];
    const PxyzOffset = [0, 0, 0, 0];
    for (let i = 0; i < 3; i++) {
      PxyzOffset[i] = 0;
      for (let j = 0; j < 3; j++) {
        PxyzOffset[i] = PxyzOffset[i] + rot44[j + i * 4] * Pcrs[j];
      }
    }
    hdr.affine = [
      [rot44[0], rot44[1], rot44[2], cr - PxyzOffset[0]],
      [rot44[4], rot44[5], rot44[6], ca - PxyzOffset[1]],
      [rot44[8], rot44[9], rot44[10], cs - PxyzOffset[2]],
      [0, 0, 0, 1]
    ];
    const nBytes = hdr.dims[1] * hdr.dims[2] * hdr.dims[3] * hdr.dims[4] * (hdr.numBitsPerVoxel / 8);
    return raw.slice(hdr.vox_offset, hdr.vox_offset + nBytes);
  }
  // readMGH()
  // not included in public docs
  // read DSI-Studio FIB format image
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async readFIB(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.littleEndian = false;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const mat = await NVUtilities.readMatV4(buffer, true);
    if (!("dimension" in mat) || !("dti_fa" in mat)) {
      throw new Error("Not a valid DSIstudio FIB file");
    }
    const hasV1 = "index0" in mat && "index1" in mat && "index2" in mat && "odf_vertices" in mat;
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = 16 /* DT_FLOAT32 */;
    hdr.dims[1] = mat.dimension[0];
    hdr.dims[2] = mat.dimension[1];
    hdr.dims[3] = mat.dimension[2];
    hdr.dims[4] = 1;
    hdr.pixDims[1] = mat.voxel_size[0];
    hdr.pixDims[2] = mat.voxel_size[1];
    hdr.pixDims[3] = mat.voxel_size[2];
    hdr.sform_code = 1;
    const xmm = (hdr.dims[1] - 1) * 0.5 * hdr.pixDims[1];
    const ymm = (hdr.dims[2] - 1) * 0.5 * hdr.pixDims[2];
    const zmm = (hdr.dims[3] - 1) * 0.5 * hdr.pixDims[3];
    hdr.affine = [
      [hdr.pixDims[1], 0, 0, -xmm],
      [0, -hdr.pixDims[2], 0, ymm],
      [0, 0, hdr.pixDims[2], -zmm],
      [0, 0, 0, 1]
    ];
    hdr.littleEndian = true;
    const nVox3D = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    const nBytes3D = nVox3D * Math.ceil(hdr.numBitsPerVoxel / 8);
    const nBytes = nBytes3D * hdr.dims[4];
    const buff8v1 = new Uint8Array(new ArrayBuffer(nVox3D * 4 * 3));
    if (hasV1) {
      const nvox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
      const dir0 = new Float32Array(nvox);
      const dir1 = new Float32Array(nvox);
      const dir2 = new Float32Array(nvox);
      const idxs = mat.index0;
      const dirs = mat.odf_vertices;
      for (let i = 0; i < nvox; i++) {
        const idx = idxs[i] * 3;
        dir0[i] = dirs[idx + 0];
        dir1[i] = dirs[idx + 1];
        dir2[i] = -dirs[idx + 2];
      }
      buff8v1.set(new Uint8Array(dir0.buffer, dir0.byteOffset, dir0.byteLength), 0 * nBytes3D);
      buff8v1.set(new Uint8Array(dir1.buffer, dir1.byteOffset, dir1.byteLength), 1 * nBytes3D);
      buff8v1.set(new Uint8Array(dir2.buffer, dir2.byteOffset, dir2.byteLength), 2 * nBytes3D);
    }
    if ("report" in mat) {
      hdr.description = new TextDecoder().decode(mat.report.subarray(0, Math.min(79, mat.report.byteLength)));
    }
    const buff8 = new Uint8Array(new ArrayBuffer(nBytes));
    const arrFA = Float32Array.from(mat.dti_fa);
    if ("mask" in mat) {
      console.log(mat);
      let slope = 1;
      if ("dti_fa_slope" in mat) {
        slope = mat.dti_fa_slope[0];
      }
      let inter = 1;
      if ("dti_fa_inter" in mat) {
        inter = mat.dti_fa_inter[0];
      }
      const nvox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
      const mask = mat.mask;
      const f32 = new Float32Array(nvox);
      let j = 0;
      for (let i = 0; i < nvox; i++) {
        if (mask[i] !== 0) {
          f32[i] = arrFA[j] * slope + inter;
          j++;
        }
      }
      return [f32.buffer, new Float32Array(buff8v1.buffer)];
    }
    const imgFA = new Uint8Array(arrFA.buffer, arrFA.byteOffset, arrFA.byteLength);
    buff8.set(imgFA, 0);
    return [buff8.buffer, new Float32Array(buff8v1.buffer)];
  }
  // readFIB()
  // not included in public docs
  // read DSI-Studio SRC format image
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async readSRC(buffer) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.littleEndian = false;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const mat = await NVUtilities.readMatV4(buffer);
    if (!("dimension" in mat) || !("image0" in mat)) {
      throw new Error("Not a valid DSIstudio SRC file");
    }
    let n = 0;
    let len4 = 0;
    for (const [key, value] of Object.entries(mat)) {
      if (!key.startsWith("image")) {
        continue;
      }
      if (n === 0) {
        len4 = value.length;
      } else if (len4 !== value.length) {
        len4 = -1;
      }
      if (value.constructor !== Uint16Array) {
        throw new Error("DSIstudio SRC files always use Uint16 datatype");
      }
      n++;
    }
    if (len4 < 1 || n < 1) {
      throw new Error("SRC file not valid DSI Studio data. The image(s) should have the same length");
    }
    hdr.numBitsPerVoxel = 16;
    hdr.datatypeCode = 512 /* DT_UINT16 */;
    hdr.dims[1] = mat.dimension[0];
    hdr.dims[2] = mat.dimension[1];
    hdr.dims[3] = mat.dimension[2];
    hdr.dims[4] = n;
    if (hdr.dims[4] > 1) {
      hdr.dims[0] = 4;
    }
    hdr.pixDims[1] = mat.voxel_size[0];
    hdr.pixDims[2] = mat.voxel_size[1];
    hdr.pixDims[3] = mat.voxel_size[2];
    hdr.sform_code = 1;
    const xmm = (hdr.dims[1] - 1) * 0.5 * hdr.pixDims[1];
    const ymm = (hdr.dims[2] - 1) * 0.5 * hdr.pixDims[2];
    const zmm = (hdr.dims[3] - 1) * 0.5 * hdr.pixDims[3];
    hdr.affine = [
      [hdr.pixDims[1], 0, 0, -xmm],
      [0, -hdr.pixDims[2], 0, ymm],
      [0, 0, hdr.pixDims[2], -zmm],
      [0, 0, 0, 1]
    ];
    hdr.littleEndian = true;
    const nBytes3D = hdr.dims[1] * hdr.dims[2] * hdr.dims[3] * (hdr.numBitsPerVoxel / 8);
    const nBytes = nBytes3D * hdr.dims[4];
    const buff8 = new Uint8Array(new ArrayBuffer(nBytes));
    let offset = 0;
    for (let i = 0; i < n; i++) {
      const arr = mat[`image${i}`];
      const img8 = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      buff8.set(img8, offset);
      offset += nBytes3D;
    }
    if ("report" in mat) {
      hdr.description = new TextDecoder().decode(mat.report.subarray(0, Math.min(79, mat.report.byteLength)));
    }
    return buff8.buffer;
  }
  // readSRC()
  // not included in public docs
  // read AFNI head/brik format image
  async readHEAD(dataBuffer, pairedImgData) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.dims[0] = 3;
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    let orientSpecific = [0, 0, 0];
    let xyzOrigin = [0, 0, 0];
    let xyzDelta = [1, 1, 1];
    const txt = new TextDecoder().decode(dataBuffer);
    const lines = txt.split(/\r?\n/);
    const mod = (dataBuffer.byteLength + 8) % 16;
    const len4 = dataBuffer.byteLength + (16 - mod);
    log.debug(dataBuffer.byteLength, "len", len4);
    const extBuffer = new Uint8Array(len4);
    extBuffer.fill(0);
    extBuffer.set(new Uint8Array(dataBuffer));
    const newExtension = new NIFTIEXTENSION(len4 + 8, 42, extBuffer, true);
    hdr.addExtension(newExtension);
    hdr.extensionCode = 42;
    hdr.extensionFlag[0] = 1;
    hdr.extensionSize = len4 + 8;
    const nlines = lines.length;
    let i = 0;
    let hasIJK_TO_DICOM_REAL = false;
    while (i < nlines) {
      let line = lines[i];
      i++;
      if (!line.startsWith("type")) {
        continue;
      }
      const isInt = line.includes("integer-attribute");
      const isFloat = line.includes("float-attribute");
      line = lines[i];
      i++;
      if (!line.startsWith("name")) {
        continue;
      }
      let items = line.split("= ");
      const key = items[1];
      line = lines[i];
      i++;
      items = line.split("= ");
      let count = parseInt(items[1]);
      if (count < 1) {
        continue;
      }
      line = lines[i];
      i++;
      items = line.trim().split(/\s+/);
      if (isFloat || isInt) {
        while (items.length < count) {
          line = lines[i];
          i++;
          const items2 = line.trim().split(/\s+/);
          items.push(...items2);
        }
        for (let j = 0; j < count; j++) {
          items[j] = parseFloat(items[j]);
        }
      }
      switch (key) {
        case "BYTEORDER_STRING":
          if (items[0].includes("LSB_FIRST")) {
            hdr.littleEndian = true;
          } else if (items[0].includes("MSB_FIRST")) {
            hdr.littleEndian = false;
          }
          break;
        case "BRICK_TYPES":
          {
            hdr.dims[4] = count;
            const datatype = parseInt(items[0]);
            if (datatype === 0) {
              hdr.numBitsPerVoxel = 8;
              hdr.datatypeCode = 2 /* DT_UINT8 */;
            } else if (datatype === 1) {
              hdr.numBitsPerVoxel = 16;
              hdr.datatypeCode = 4 /* DT_INT16 */;
            } else if (datatype === 3) {
              hdr.numBitsPerVoxel = 32;
              hdr.datatypeCode = 16 /* DT_FLOAT32 */;
            } else {
              log.warn("Unknown BRICK_TYPES ", datatype);
            }
          }
          break;
        case "IJK_TO_DICOM_REAL":
          if (count < 12) {
            break;
          }
          hasIJK_TO_DICOM_REAL = true;
          hdr.sform_code = 2;
          hdr.affine = [
            [-items[0], -items[1], -items[2], -items[3]],
            [-items[4], -items[5], -items[6], -items[7]],
            // TODO don't re-use items for numeric values
            [items[8], items[9], items[10], items[11]],
            [0, 0, 0, 1]
          ];
          break;
        case "DATASET_DIMENSIONS":
          count = Math.max(count, 3);
          for (let j = 0; j < count; j++) {
            hdr.dims[j + 1] = items[j];
          }
          break;
        case "ORIENT_SPECIFIC":
          orientSpecific = items;
          break;
        case "ORIGIN":
          xyzOrigin = items;
          break;
        case "DELTA":
          xyzDelta = items;
          break;
        case "TAXIS_FLOATS":
          hdr.pixDims[4] = items[0];
          break;
        default:
          log.warn("Unknown:", key);
      }
    }
    if (!hasIJK_TO_DICOM_REAL) {
      this.THD_daxes_to_NIFTI(xyzDelta, xyzOrigin, orientSpecific);
    } else {
      this.SetPixDimFromSForm();
    }
    const nBytes = hdr.numBitsPerVoxel / 8 * hdr.dims[1] * hdr.dims[2] * hdr.dims[3] * hdr.dims[4];
    if (!pairedImgData) {
      throw new Error("pairedImgData not set");
    }
    if (pairedImgData.byteLength < nBytes) {
      return await NVUtilities.decompressToBuffer(new Uint8Array(pairedImgData));
    }
    return pairedImgData.slice(0);
  }
  // not included in public docs
  // read ITK MHA format image
  // https://itk.org/Wiki/ITK/MetaIO/Documentation#Reading_a_Brick-of-Bytes_.28an_N-Dimensional_volume_in_a_single_file.29
  async readMHA(buffer, pairedImgData) {
    const len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be VTK: bytes = " + buffer.byteLength);
    }
    const bytes = new Uint8Array(buffer);
    let pos = 0;
    function eol(c) {
      return c === 10 || c === 13;
    }
    function readStr() {
      while (pos < len4 && eol(bytes[pos])) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && !eol(bytes[pos])) {
        pos++;
      }
      if (pos - startPos < 2) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos));
    }
    let line = readStr();
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    hdr.dims = [1, 1, 1, 1, 1, 1, 1, 1];
    hdr.littleEndian = true;
    let isGz = false;
    let isDetached = false;
    const mat33 = mat3_exports.fromValues(NaN, 0, 0, 0, 1, 0, 0, 0, 1);
    const offset = vec3_exports.fromValues(0, 0, 0);
    while (line !== "") {
      let items = line.split(" ");
      if (items.length > 2) {
        items = items.slice(2);
      }
      if (line.startsWith("BinaryDataByteOrderMSB") && items[0].includes("False")) {
        hdr.littleEndian = true;
      }
      if (line.startsWith("BinaryDataByteOrderMSB") && items[0].includes("True")) {
        hdr.littleEndian = false;
      }
      if (line.startsWith("CompressedData") && items[0].includes("True")) {
        isGz = true;
      }
      if (line.startsWith("TransformMatrix")) {
        for (let d = 0; d < 9; d++) {
          mat33[d] = parseFloat(items[d]);
        }
      }
      if (line.startsWith("Offset")) {
        for (let d = 0; d < Math.min(items.length, 3); d++) {
          offset[d] = parseFloat(items[d]);
        }
      }
      if (line.startsWith("ElementSpacing")) {
        for (let d = 0; d < items.length; d++) {
          hdr.pixDims[d + 1] = parseFloat(items[d]);
        }
      }
      if (line.startsWith("DimSize")) {
        hdr.dims[0] = items.length;
        for (let d = 0; d < items.length; d++) {
          hdr.dims[d + 1] = parseInt(items[d]);
        }
      }
      if (line.startsWith("ElementType")) {
        switch (items[0]) {
          case "MET_UCHAR":
            hdr.numBitsPerVoxel = 8;
            hdr.datatypeCode = 2 /* DT_UINT8 */;
            break;
          case "MET_CHAR":
            hdr.numBitsPerVoxel = 8;
            hdr.datatypeCode = 256 /* DT_INT8 */;
            break;
          case "MET_SHORT":
            hdr.numBitsPerVoxel = 16;
            hdr.datatypeCode = 4 /* DT_INT16 */;
            break;
          case "MET_USHORT":
            hdr.numBitsPerVoxel = 16;
            hdr.datatypeCode = 512 /* DT_UINT16 */;
            break;
          case "MET_INT":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = 8 /* DT_INT32 */;
            break;
          case "MET_UINT":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = 768 /* DT_UINT32 */;
            break;
          case "MET_FLOAT":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = 16 /* DT_FLOAT32 */;
            break;
          case "MET_DOUBLE":
            hdr.numBitsPerVoxel = 64;
            hdr.datatypeCode = 64 /* DT_FLOAT64 */;
            break;
          default:
            throw new Error("Unsupported MHA data type: " + items[0]);
        }
      }
      if (line.startsWith("ObjectType") && !items[0].includes("Image")) {
        log.warn("Only able to read ObjectType = Image, not " + line);
      }
      if (line.startsWith("ElementDataFile")) {
        if (items[0] !== "LOCAL") {
          isDetached = true;
        }
        break;
      }
      line = readStr();
    }
    const mmMat = mat3_exports.fromValues(hdr.pixDims[1], 0, 0, 0, hdr.pixDims[2], 0, 0, 0, hdr.pixDims[3]);
    mat3_exports.multiply(mat33, mat33, mmMat);
    hdr.affine = [
      [-mat33[0], -mat33[3], -mat33[6], -offset[0]],
      [-mat33[1], -mat33[4], -mat33[7], -offset[1]],
      [mat33[2], mat33[5], mat33[8], offset[2]],
      [0, 0, 0, 1]
    ];
    while (bytes[pos] === 10) {
      pos++;
    }
    hdr.vox_offset = pos;
    if (isDetached && pairedImgData) {
      if (isGz) {
        return await NVUtilities.decompressToBuffer(new Uint8Array(pairedImgData.slice(0)));
      }
      return pairedImgData.slice(0);
    }
    if (isGz) {
      return await NVUtilities.decompressToBuffer(new Uint8Array(buffer.slice(hdr.vox_offset)));
    }
    return buffer.slice(hdr.vox_offset);
  }
  // readMHA()
  // not included in public docs
  // read mrtrix MIF format image
  // https://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html#mrtrix-image-formats
  async readMIF(buffer, pairedImgData) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    hdr.dims = [1, 1, 1, 1, 1, 1, 1, 1];
    let len4 = buffer.byteLength;
    if (len4 < 20) {
      throw new Error("File too small to be MIF: bytes = " + len4);
    }
    const bytes = new Uint8Array(buffer);
    if (bytes[0] === 31 && bytes[1] === 139) {
      log.debug("MIF with GZ decompression");
      buffer = await NVUtilities.decompressToBuffer(new Uint8Array(buffer));
      len4 = buffer.byteLength;
    }
    let pos = 0;
    function readStr() {
      while (pos < len4 && bytes[pos] === 10) {
        pos++;
      }
      const startPos = pos;
      while (pos < len4 && bytes[pos] !== 10) {
        pos++;
      }
      pos++;
      if (pos - startPos < 1) {
        return "";
      }
      return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
    }
    let line = readStr();
    if (!line.startsWith("mrtrix image")) {
      throw new Error("Not a valid MIF file");
    }
    const layout = [];
    let isBit = false;
    let nTransform = 0;
    let TR = 0;
    let isDetached = false;
    line = readStr();
    while (pos < len4 && !line.startsWith("END")) {
      let items = line.split(":");
      line = readStr();
      if (items.length < 2) {
        break;
      }
      const tag = items[0];
      items = items[1].split(",");
      for (let i = 0; i < items.length; i++) {
        items[i] = items[i].trim();
      }
      switch (tag) {
        case "dim":
          hdr.dims[0] = items.length;
          for (let i = 0; i < items.length; i++) {
            hdr.dims[i + 1] = parseInt(items[i]);
          }
          break;
        case "vox":
          for (let i = 0; i < items.length; i++) {
            hdr.pixDims[i + 1] = parseFloat(items[i]);
            if (isNaN(hdr.pixDims[i + 1])) {
              hdr.pixDims[i + 1] = 0;
            }
          }
          break;
        case "layout":
          for (let i = 0; i < items.length; i++) {
            layout.push(parseInt(items[i]));
          }
          break;
        case "datatype":
          {
            const dt = items[0];
            if (dt.startsWith("Bit")) {
              isBit = true;
              hdr.datatypeCode = 2 /* DT_UINT8 */;
            } else if (dt.startsWith("Int8")) {
              hdr.datatypeCode = 256 /* DT_INT8 */;
            } else if (dt.startsWith("UInt8")) {
              hdr.datatypeCode = 2 /* DT_UINT8 */;
            } else if (dt.startsWith("Int16")) {
              hdr.datatypeCode = 4 /* DT_INT16 */;
            } else if (dt.startsWith("UInt16")) {
              hdr.datatypeCode = 512 /* DT_UINT16 */;
            } else if (dt.startsWith("Int32")) {
              hdr.datatypeCode = 8 /* DT_INT32 */;
            } else if (dt.startsWith("UInt32")) {
              hdr.datatypeCode = 768 /* DT_UINT32 */;
            } else if (dt.startsWith("Float32")) {
              hdr.datatypeCode = 16 /* DT_FLOAT32 */;
            } else if (dt.startsWith("Float64")) {
              hdr.datatypeCode = 64 /* DT_FLOAT64 */;
            } else {
              log.warn("Unsupported datatype " + dt);
            }
            if (dt.includes("8")) {
              hdr.numBitsPerVoxel = 8;
            } else if (dt.includes("16")) {
              hdr.numBitsPerVoxel = 16;
            } else if (dt.includes("32")) {
              hdr.numBitsPerVoxel = 32;
            } else if (dt.includes("64")) {
              hdr.numBitsPerVoxel = 64;
            }
            hdr.littleEndian = true;
            if (dt.endsWith("LE")) {
              hdr.littleEndian = true;
            }
            if (dt.endsWith("BE")) {
              hdr.littleEndian = false;
            }
          }
          break;
        case "transform":
          if (nTransform > 2 || items.length !== 4) {
            break;
          }
          hdr.affine[nTransform][0] = parseFloat(items[0]);
          hdr.affine[nTransform][1] = parseFloat(items[1]);
          hdr.affine[nTransform][2] = parseFloat(items[2]);
          hdr.affine[nTransform][3] = parseFloat(items[3]);
          nTransform++;
          break;
        case "comments":
          hdr.description = items[0].substring(0, Math.min(79, items[0].length));
          break;
        /* case 'command_history':
          if (items[0].startsWith('dwi2tensor')) {
            isTensor = true
          }
          break */
        case "RepetitionTime":
          TR = parseFloat(items[0]);
          break;
        case "file":
          isDetached = !items[0].startsWith(". ");
          if (!isDetached) {
            items = items[0].split(" ");
            hdr.vox_offset = parseInt(items[1]);
          }
          break;
      }
    }
    const ndim = hdr.dims[0];
    if (ndim > 5) {
      log.warn("reader only designed for a maximum of 5 dimensions (XYZTD)");
    }
    let nvox = 1;
    for (let i = 0; i < ndim; i++) {
      nvox *= Math.max(hdr.dims[i + 1], 1);
    }
    for (let i = 0; i < 3; i++) {
      for (let j2 = 0; j2 < 3; j2++) {
        hdr.affine[i][j2] *= hdr.pixDims[j2 + 1];
      }
    }
    log.debug("mif affine:" + hdr.affine[0]);
    if (TR > 0) {
      hdr.pixDims[4] = TR;
    }
    if (isDetached && !pairedImgData) {
      log.warn("MIH header provided without paired image data");
    }
    let rawImg;
    if (pairedImgData && isDetached) {
      rawImg = pairedImgData.slice(0);
    } else if (isBit) {
      hdr.numBitsPerVoxel = 8;
      const img8 = new Uint8Array(nvox);
      const buffer1 = buffer.slice(hdr.vox_offset, hdr.vox_offset + Math.ceil(nvox / 8));
      const img1 = new Uint8Array(buffer1);
      let j2 = 0;
      for (let i = 0; i < nvox; i++) {
        const bit = i % 8;
        img8[i] = img1[j2] >> 7 - bit & 1;
        if (bit === 7) {
          j2++;
        }
      }
      rawImg = img8.buffer;
    } else {
      rawImg = buffer.slice(hdr.vox_offset, hdr.vox_offset + nvox * (hdr.numBitsPerVoxel / 8));
    }
    if (layout.length !== hdr.dims[0]) {
      log.warn("dims does not match layout");
    }
    let stride = 1;
    const instride = [1, 1, 1, 1, 1];
    const inflip = [false, false, false, false, false];
    for (let i = 0; i < layout.length; i++) {
      for (let j2 = 0; j2 < layout.length; j2++) {
        const a = Math.abs(layout[j2]);
        if (a !== i) {
          continue;
        }
        instride[j2] = stride;
        if (layout[j2] < 0 || Object.is(layout[j2], -0)) {
          inflip[j2] = true;
        }
        stride *= hdr.dims[j2 + 1];
      }
    }
    let xlut = NVUtilities.range(0, hdr.dims[1] - 1, 1);
    if (inflip[0]) {
      xlut = NVUtilities.range(hdr.dims[1] - 1, 0, -1);
    }
    for (let i = 0; i < hdr.dims[1]; i++) {
      xlut[i] *= instride[0];
    }
    let ylut = NVUtilities.range(0, hdr.dims[2] - 1, 1);
    if (inflip[1]) {
      ylut = NVUtilities.range(hdr.dims[2] - 1, 0, -1);
    }
    for (let i = 0; i < hdr.dims[2]; i++) {
      ylut[i] *= instride[1];
    }
    let zlut = NVUtilities.range(0, hdr.dims[3] - 1, 1);
    if (inflip[2]) {
      zlut = NVUtilities.range(hdr.dims[3] - 1, 0, -1);
    }
    for (let i = 0; i < hdr.dims[3]; i++) {
      zlut[i] *= instride[2];
    }
    let tlut = NVUtilities.range(0, hdr.dims[4] - 1, 1);
    if (inflip[3]) {
      tlut = NVUtilities.range(hdr.dims[4] - 1, 0, -1);
    }
    for (let i = 0; i < hdr.dims[4]; i++) {
      tlut[i] *= instride[3];
    }
    let dlut = NVUtilities.range(0, hdr.dims[5] - 1, 1);
    if (inflip[4]) {
      dlut = NVUtilities.range(hdr.dims[5] - 1, 0, -1);
    }
    for (let i = 0; i < hdr.dims[5]; i++) {
      dlut[i] *= instride[4];
    }
    let j = 0;
    let inVs;
    let outVs;
    switch (hdr.datatypeCode) {
      case 256 /* DT_INT8 */:
        inVs = new Int8Array(rawImg);
        outVs = new Int8Array(nvox);
        break;
      case 2 /* DT_UINT8 */:
        inVs = new Uint8Array(rawImg);
        outVs = new Uint8Array(nvox);
        break;
      case 4 /* DT_INT16 */:
        inVs = new Int16Array(rawImg);
        outVs = new Int16Array(nvox);
        break;
      case 512 /* DT_UINT16 */:
        inVs = new Uint16Array(rawImg);
        outVs = new Uint16Array(nvox);
        break;
      case 8 /* DT_INT32 */:
        inVs = new Int32Array(rawImg);
        outVs = new Int32Array(nvox);
        break;
      case 768 /* DT_UINT32 */:
        inVs = new Uint32Array(rawImg);
        outVs = new Uint32Array(nvox);
        break;
      case 16 /* DT_FLOAT32 */:
        inVs = new Float32Array(rawImg);
        outVs = new Float32Array(nvox);
        break;
      case 64 /* DT_FLOAT64 */:
        inVs = new Float64Array(rawImg);
        outVs = new Float64Array(nvox);
        break;
      default:
        throw new Error("unknown datatypeCode");
    }
    for (let d = 0; d < hdr.dims[5]; d++) {
      for (let t = 0; t < hdr.dims[4]; t++) {
        for (let z = 0; z < hdr.dims[3]; z++) {
          for (let y = 0; y < hdr.dims[2]; y++) {
            for (let x = 0; x < hdr.dims[1]; x++) {
              outVs[j] = inVs[xlut[x] + ylut[y] + zlut[z] + tlut[t] + dlut[d]];
              j++;
            }
          }
        }
      }
    }
    return outVs;
  }
  // readMIF()
  // not included in public docs
  // read NRRD format image
  // http://teem.sourceforge.net/nrrd/format.html
  async readNRRD(dataBuffer, pairedImgData) {
    this.hdr = new NIFTI1();
    const hdr = this.hdr;
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const len4 = dataBuffer.byteLength;
    let txt = null;
    const bytes = new Uint8Array(dataBuffer);
    for (let i = 1; i < len4; i++) {
      if (bytes[i - 1] === 10 && bytes[i] === 10) {
        const v = dataBuffer.slice(0, i - 1);
        txt = new TextDecoder().decode(v);
        hdr.vox_offset = i + 1;
        break;
      }
    }
    if (txt === null) {
      throw new Error("could not extract txt");
    }
    const lines = txt.split("\n");
    if (!lines[0].startsWith("NRRD")) {
      alert("Invalid NRRD image");
    }
    const n = lines.length;
    let isGz = false;
    let isMicron = false;
    let isDetached = false;
    const mat33 = mat3_exports.fromValues(NaN, 0, 0, 0, 1, 0, 0, 0, 1);
    const offset = vec3_exports.fromValues(0, 0, 0);
    let rot33 = mat3_exports.create();
    for (let i = 1; i < n; i++) {
      let str6 = lines[i];
      if (str6[0] === "#") {
        continue;
      }
      str6 = str6.toLowerCase();
      const items = str6.split(":");
      if (items.length < 2) {
        continue;
      }
      const key = items[0].trim();
      let value = items[1].trim();
      value = value.replaceAll(")", " ");
      value = value.replaceAll("(", " ");
      value = value.trim();
      switch (key) {
        case "data file":
          isDetached = true;
          break;
        case "encoding":
          if (value.includes("raw")) {
            isGz = false;
          } else if (value.includes("gz")) {
            isGz = true;
          } else {
            alert("Unsupported NRRD encoding");
          }
          break;
        case "type":
          switch (value) {
            case "uchar":
            case "unsigned char":
            case "uint8":
            case "uint8_t":
              hdr.numBitsPerVoxel = 8;
              hdr.datatypeCode = 2 /* DT_UINT8 */;
              break;
            case "signed char":
            case "int8":
            case "int8_t":
              hdr.numBitsPerVoxel = 8;
              hdr.datatypeCode = 256 /* DT_INT8 */;
              break;
            case "short":
            case "short int":
            case "signed short":
            case "signed short int":
            case "int16":
            case "int16_t":
              hdr.numBitsPerVoxel = 16;
              hdr.datatypeCode = 4 /* DT_INT16 */;
              break;
            case "ushort":
            case "unsigned short":
            case "unsigned short int":
            case "uint16":
            case "uint16_t":
              hdr.numBitsPerVoxel = 16;
              hdr.datatypeCode = 512 /* DT_UINT16 */;
              break;
            case "int":
            case "signed int":
            case "int32":
            case "int32_t":
              hdr.numBitsPerVoxel = 32;
              hdr.datatypeCode = 8 /* DT_INT32 */;
              break;
            case "uint":
            case "unsigned int":
            case "uint32":
            case "uint32_t":
              hdr.numBitsPerVoxel = 32;
              hdr.datatypeCode = 768 /* DT_UINT32 */;
              break;
            case "float":
              hdr.numBitsPerVoxel = 32;
              hdr.datatypeCode = 16 /* DT_FLOAT32 */;
              break;
            case "double":
              hdr.numBitsPerVoxel = 64;
              hdr.datatypeCode = 64 /* DT_FLOAT64 */;
              break;
            default:
              throw new Error("Unsupported NRRD data type: " + value);
          }
          break;
        case "spacings":
          {
            const values = value.split(/[ ,]+/);
            for (let d = 0; d < values.length; d++) {
              hdr.pixDims[d + 1] = parseFloat(values[d]);
            }
          }
          break;
        case "sizes":
          {
            const dims = value.split(/[ ,]+/);
            hdr.dims[0] = dims.length;
            for (let d = 0; d < dims.length; d++) {
              hdr.dims[d + 1] = parseInt(dims[d]);
            }
          }
          break;
        case "endian":
          if (value.includes("little")) {
            hdr.littleEndian = true;
          } else if (value.includes("big")) {
            hdr.littleEndian = false;
          }
          break;
        case "space directions":
          {
            const vs = value.split(/[ ,]+/);
            if (vs.length !== 9) {
              break;
            }
            for (let d = 0; d < 9; d++) {
              mat33[d] = parseFloat(vs[d]);
            }
          }
          break;
        case "space origin":
          {
            const ts = value.split(/[ ,]+/);
            if (ts.length !== 3) {
              break;
            }
            offset[0] = parseFloat(ts[0]);
            offset[1] = parseFloat(ts[1]);
            offset[2] = parseFloat(ts[2]);
          }
          break;
        case "space units":
          if (value.includes("microns")) {
            isMicron = true;
          }
          break;
        case "space":
          if (value.includes("right-anterior-superior") || value.includes("ras")) {
            rot33 = mat3_exports.fromValues(
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1
            );
          } else if (value.includes("left-anterior-superior") || value.includes("las")) {
            rot33 = mat3_exports.fromValues(
              -1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1
            );
          } else if (value.includes("left-posterior-superior") || value.includes("lps")) {
            rot33 = mat3_exports.fromValues(
              -1,
              0,
              0,
              0,
              -1,
              0,
              0,
              0,
              1
            );
          } else {
            log.warn("Unsupported NRRD space value:", value);
          }
          break;
        default:
          log.warn("Unknown:", key);
      }
    }
    if (!isNaN(mat33[0])) {
      this.hdr.sform_code = 2;
      if (isMicron) {
        mat4_exports.multiplyScalar(mat33, mat33, 1e-3);
        offset[0] *= 1e-3;
        offset[1] *= 1e-3;
        offset[2] *= 1e-3;
      }
      if (rot33[0] < 0) {
        offset[0] = -offset[0];
      }
      if (rot33[4] < 0) {
        offset[1] = -offset[1];
      }
      if (rot33[8] < 0) {
        offset[2] = -offset[2];
      }
      mat3_exports.multiply(mat33, rot33, mat33);
      const mat = mat4_exports.fromValues(
        mat33[0],
        mat33[3],
        mat33[6],
        offset[0],
        mat33[1],
        mat33[4],
        mat33[7],
        offset[1],
        mat33[2],
        mat33[5],
        mat33[8],
        offset[2],
        0,
        0,
        0,
        1
      );
      const mm000 = this.vox2mm([0, 0, 0], mat);
      const mm100 = this.vox2mm([1, 0, 0], mat);
      vec3_exports.subtract(mm100, mm100, mm000);
      const mm010 = this.vox2mm([0, 1, 0], mat);
      vec3_exports.subtract(mm010, mm010, mm000);
      const mm001 = this.vox2mm([0, 0, 1], mat);
      vec3_exports.subtract(mm001, mm001, mm000);
      hdr.pixDims[1] = vec3_exports.length(mm100);
      hdr.pixDims[2] = vec3_exports.length(mm010);
      hdr.pixDims[3] = vec3_exports.length(mm001);
      hdr.affine = [
        [mat[0], mat[1], mat[2], mat[3]],
        [mat[4], mat[5], mat[6], mat[7]],
        [mat[8], mat[9], mat[10], mat[11]],
        [0, 0, 0, 1]
      ];
    }
    if (isDetached && pairedImgData) {
      return pairedImgData.slice(0);
    }
    if (isDetached) {
      log.warn("Missing data: NRRD header describes detached data file but only one URL provided");
    }
    if (isGz) {
      return await NVUtilities.decompressToBuffer(new Uint8Array(dataBuffer.slice(hdr.vox_offset)));
    } else {
      return dataBuffer.slice(hdr.vox_offset);
    }
  }
  // readNRRD()
  // not included in public docs
  // Transform to orient NIfTI image to Left->Right,Posterior->Anterior,Inferior->Superior (48 possible permutations)
  calculateRAS() {
    if (!this.hdr) {
      throw new Error("hdr not set");
    }
    const a = this.hdr.affine;
    const header = this.hdr;
    const absR = mat3_exports.fromValues(
      Math.abs(a[0][0]),
      Math.abs(a[0][1]),
      Math.abs(a[0][2]),
      Math.abs(a[1][0]),
      Math.abs(a[1][1]),
      Math.abs(a[1][2]),
      Math.abs(a[2][0]),
      Math.abs(a[2][1]),
      Math.abs(a[2][2])
    );
    const ixyz = [1, 1, 1];
    if (absR[3] > absR[0]) {
      ixyz[0] = 2;
    }
    if (absR[6] > absR[0] && absR[6] > absR[3]) {
      ixyz[0] = 3;
    }
    ixyz[1] = 1;
    if (ixyz[0] === 1) {
      if (absR[4] > absR[7]) {
        ixyz[1] = 2;
      } else {
        ixyz[1] = 3;
      }
    } else if (ixyz[0] === 2) {
      if (absR[1] > absR[7]) {
        ixyz[1] = 1;
      } else {
        ixyz[1] = 3;
      }
    } else {
      if (absR[1] > absR[4]) {
        ixyz[1] = 1;
      } else {
        ixyz[1] = 2;
      }
    }
    ixyz[2] = 6 - ixyz[1] - ixyz[0];
    let perm = [1, 2, 3];
    perm[ixyz[0] - 1] = 1;
    perm[ixyz[1] - 1] = 2;
    perm[ixyz[2] - 1] = 3;
    let rotM = mat4_exports.fromValues(
      a[0][0],
      a[0][1],
      a[0][2],
      a[0][3],
      a[1][0],
      a[1][1],
      a[1][2],
      a[1][3],
      a[2][0],
      a[2][1],
      a[2][2],
      a[2][3],
      0,
      0,
      0,
      1
    );
    this.mm000 = this.vox2mm([-0.5, -0.5, -0.5], rotM);
    this.mm100 = this.vox2mm([header.dims[1] - 0.5, -0.5, -0.5], rotM);
    this.mm010 = this.vox2mm([-0.5, header.dims[2] - 0.5, -0.5], rotM);
    this.mm001 = this.vox2mm([-0.5, -0.5, header.dims[3] - 0.5], rotM);
    const R = mat4_exports.create();
    mat4_exports.copy(R, rotM);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        R[i * 4 + j] = rotM[i * 4 + perm[j] - 1];
      }
    }
    const flip = [0, 0, 0];
    if (R[0] < 0) {
      flip[0] = 1;
    }
    if (R[5] < 0) {
      flip[1] = 1;
    }
    if (R[10] < 0) {
      flip[2] = 1;
    }
    this.dimsRAS = [header.dims[0], header.dims[perm[0]], header.dims[perm[1]], header.dims[perm[2]]];
    this.pixDimsRAS = [header.pixDims[0], header.pixDims[perm[0]], header.pixDims[perm[1]], header.pixDims[perm[2]]];
    this.permRAS = perm.slice();
    for (let i = 0; i < 3; i++) {
      if (flip[i] === 1) {
        this.permRAS[i] = -this.permRAS[i];
      }
    }
    if (this.arrayEquals(perm, [1, 2, 3]) && this.arrayEquals(flip, [0, 0, 0])) {
      this.toRAS = mat4_exports.create();
      this.matRAS = mat4_exports.clone(rotM);
      this.calculateOblique();
      this.img2RASstep = [1, this.dimsRAS[1], this.dimsRAS[1] * this.dimsRAS[2]];
      this.img2RASstart = [0, 0, 0];
      return;
    }
    mat4_exports.identity(rotM);
    rotM[0 + 0 * 4] = 1 - flip[0] * 2;
    rotM[1 + 1 * 4] = 1 - flip[1] * 2;
    rotM[2 + 2 * 4] = 1 - flip[2] * 2;
    rotM[3 + 0 * 4] = (header.dims[perm[0]] - 1) * flip[0];
    rotM[3 + 1 * 4] = (header.dims[perm[1]] - 1) * flip[1];
    rotM[3 + 2 * 4] = (header.dims[perm[2]] - 1) * flip[2];
    const residualR = mat4_exports.create();
    mat4_exports.invert(residualR, rotM);
    mat4_exports.multiply(residualR, residualR, R);
    this.matRAS = mat4_exports.clone(residualR);
    rotM = mat4_exports.fromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
    rotM[perm[0] - 1 + 0 * 4] = -flip[0] * 2 + 1;
    rotM[perm[1] - 1 + 1 * 4] = -flip[1] * 2 + 1;
    rotM[perm[2] - 1 + 2 * 4] = -flip[2] * 2 + 1;
    rotM[3 + 0 * 4] = flip[0];
    rotM[3 + 1 * 4] = flip[1];
    rotM[3 + 2 * 4] = flip[2];
    this.toRAS = mat4_exports.clone(rotM);
    rotM[3] = 0;
    rotM[7] = 0;
    rotM[11] = 0;
    rotM[12] = 0;
    if (this.permRAS[0] === -1 || this.permRAS[1] === -1 || this.permRAS[2] === -1) {
      rotM[12] = header.dims[1] - 1;
    }
    rotM[13] = 0;
    if (this.permRAS[0] === -2 || this.permRAS[1] === -2 || this.permRAS[2] === -2) {
      rotM[13] = header.dims[2] - 1;
    }
    rotM[14] = 0;
    if (this.permRAS[0] === -3 || this.permRAS[1] === -3 || this.permRAS[2] === -3) {
      rotM[14] = header.dims[3] - 1;
    }
    this.toRASvox = mat4_exports.clone(rotM);
    log.debug(this.hdr.dims);
    log.debug(this.dimsRAS);
    const hdr = this.hdr;
    perm = this.permRAS;
    const aperm = [Math.abs(perm[0]), Math.abs(perm[1]), Math.abs(perm[2])];
    const outdim = [hdr.dims[aperm[0]], hdr.dims[aperm[1]], hdr.dims[aperm[2]]];
    const inStep = [1, hdr.dims[1], hdr.dims[1] * hdr.dims[2]];
    const outStep = [inStep[aperm[0] - 1], inStep[aperm[1] - 1], inStep[aperm[2] - 1]];
    const outStart = [0, 0, 0];
    for (let p = 0; p < 3; p++) {
      if (perm[p] < 0) {
        outStart[p] = outStep[p] * (outdim[p] - 1);
        outStep[p] = -outStep[p];
      }
    }
    this.img2RASstep = outStep;
    this.img2RASstart = outStart;
    this.calculateOblique();
  }
  // Reorient raw header data to RAS
  // assume single volume, use nVolumes to specify, set nVolumes = 0 for same as input
  async hdr2RAS(nVolumes = 1) {
    if (!this.permRAS) {
      throw new Error("permRAS undefined");
    }
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    const hdrBytes = hdrToArrayBuffer({ ...this.hdr, vox_offset: 352 }, false);
    const hdr = await readHeaderAsync(hdrBytes.buffer, true);
    if (nVolumes === 1) {
      hdr.dims[0] = 3;
      hdr.dims[4] = 1;
    } else if (nVolumes > 1) {
      hdr.dims[0] = 4;
      hdr.dims[4] = nVolumes;
    }
    const perm = this.permRAS.slice();
    if (perm[0] === 1 && perm[1] === 2 && perm[2] === 3) {
      return hdr;
    }
    hdr.qform_code = 0;
    for (let i = 1; i < 4; i++) {
      hdr.dims[i] = this.dimsRAS[i];
    }
    for (let i = 0; i < this.pixDimsRAS.length; i++) {
      hdr.pixDims[i] = this.pixDimsRAS[i];
    }
    let k = 0;
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        hdr.affine[i][j] = this.matRAS[k];
        k++;
      }
    }
    return hdr;
  }
  // Reorient raw image data to RAS
  // note that GPU-based orient shader is much faster
  // returns single 3D volume even for 4D input. Use nVolume to select volume (0 indexed)
  img2RAS(nVolume = 0) {
    if (!this.permRAS) {
      throw new Error("permRAS undefined");
    }
    if (!this.img) {
      throw new Error("img undefined");
    }
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    const perm = this.permRAS.slice();
    if (perm[0] === 1 && perm[1] === 2 && perm[2] === 3) {
      return this.img;
    }
    const hdr = this.hdr;
    const nVox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    let volSkip = nVolume * nVox;
    if (volSkip + nVox > this.img.length || volSkip < 0) {
      volSkip = 0;
      log.warn(`img2RAS nVolume (${nVolume}) out of bounds (${nVolume}+1)\xD7${nVox} > ${this.img.length}`);
    }
    const imgRAS = this.img.slice(0, nVox);
    const aperm = [Math.abs(perm[0]), Math.abs(perm[1]), Math.abs(perm[2])];
    const outdim = [hdr.dims[aperm[0]], hdr.dims[aperm[1]], hdr.dims[aperm[2]]];
    const inStep = [1, hdr.dims[1], hdr.dims[1] * hdr.dims[2]];
    const outStep = [inStep[aperm[0] - 1], inStep[aperm[1] - 1], inStep[aperm[2] - 1]];
    const outStart = [0, 0, 0];
    for (let p = 0; p < 3; p++) {
      if (perm[p] < 0) {
        outStart[p] = outStep[p] * (outdim[p] - 1);
        outStep[p] = -outStep[p];
      }
    }
    let j = 0;
    for (let z = 0; z < outdim[2]; z++) {
      const zi = outStart[2] + z * outStep[2];
      for (let y = 0; y < outdim[1]; y++) {
        const yi = outStart[1] + y * outStep[1];
        for (let x = 0; x < outdim[0]; x++) {
          const xi = outStart[0] + x * outStep[0];
          imgRAS[j] = this.img[xi + yi + zi + volSkip];
          j++;
        }
      }
    }
    return imgRAS;
  }
  // img2RAS()
  // not included in public docs
  // convert voxel location (row, column slice, indexed from 0) to world space
  vox2mm(XYZ, mtx) {
    const sform = mat4_exports.clone(mtx);
    mat4_exports.transpose(sform, sform);
    const pos = vec4_exports.fromValues(XYZ[0], XYZ[1], XYZ[2], 1);
    vec4_exports.transformMat4(pos, pos, sform);
    const pos3 = vec3_exports.fromValues(pos[0], pos[1], pos[2]);
    return pos3;
  }
  // vox2mm()
  // not included in public docs
  // convert world space to voxel location (row, column slice, indexed from 0)
  mm2vox(mm, frac = false) {
    if (!this.matRAS) {
      throw new Error("matRAS undefined");
    }
    const sform = mat4_exports.clone(this.matRAS);
    const out = mat4_exports.clone(sform);
    mat4_exports.transpose(out, sform);
    mat4_exports.invert(out, out);
    const pos = vec4_exports.fromValues(mm[0], mm[1], mm[2], 1);
    vec4_exports.transformMat4(pos, pos, out);
    const pos3 = vec3_exports.fromValues(pos[0], pos[1], pos[2]);
    if (frac) {
      return pos3;
    }
    return [Math.round(pos3[0]), Math.round(pos3[1]), Math.round(pos3[2])];
  }
  // vox2mm()
  // not included in public docs
  // returns boolean: are two arrays identical?
  // TODO this won't work for complex objects. Maybe use array-equal from NPM
  arrayEquals(a, b) {
    return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]);
  }
  // not included in public docs
  // base function for niivue.setColormap()
  // colormaps are continuously interpolated between 256 values (0..256)
  setColormap(cm) {
    this._colormap = cm;
    this.calMinMax();
    if (this.onColormapChange) {
      this.onColormapChange(this);
    }
  }
  // not included in public docs
  // base function for niivue.setColormap()
  // label colormaps are discretely sampled from an arbitrary number of colors
  setColormapLabel(cm) {
    this.colormapLabel = cmapper.makeLabelLut(cm);
  }
  async setColormapLabelFromUrl(url) {
    this.colormapLabel = await cmapper.makeLabelLutFromUrl(url);
  }
  get colormap() {
    return this._colormap;
  }
  get colorMap() {
    return this._colormap;
  }
  // TODO duplicate fields, see niivue/loadDocument
  set colormap(cm) {
    this.setColormap(cm);
  }
  set colorMap(cm) {
    this.setColormap(cm);
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(opacity) {
    this._opacity = opacity;
    if (this.onOpacityChange) {
      this.onOpacityChange(this);
    }
  }
  /**
   * set contrast/brightness to robust range (2%..98%)
   * @param vol - volume for estimate (use -1 to use estimate on all loaded volumes; use INFINITY for current volume)
   * @param isBorder - if true (default) only center of volume used for estimate
   * @sets volume brightness and returns array [pct2, pct98, mnScale, mxScale]
   * @see {@link https://niivue.github.io/niivue/features/timeseries2.html | live demo usage}
   */
  calMinMax(vol = Number.POSITIVE_INFINITY, isBorder = true) {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    if (!this.img) {
      throw new Error("img undefined");
    }
    let mn = Number.POSITIVE_INFINITY;
    let mx = Number.NEGATIVE_INFINITY;
    let nZero = 0;
    let nNan = 0;
    let nVox3D = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
    const nVol = Math.floor(this.img.length / nVox3D);
    if (vol >= nVol) {
      vol = this.frame4D;
    }
    vol = Math.min(vol, nVol - 1);
    const skipVox = vol * nVox3D;
    let img = [];
    if (!isBorder) {
      img = new this.img.constructor(nVox3D);
      for (let i = 0; i < nVox3D; i++) {
        img[i] = this.img[i + skipVox];
      }
    } else {
      const borderFrac = 0.25;
      const borders = [
        Math.floor(borderFrac * this.hdr.dims[1]),
        Math.floor(borderFrac * this.hdr.dims[2]),
        Math.floor(borderFrac * this.hdr.dims[3])
      ];
      const dims = [
        this.hdr.dims[1] - 2 * borders[0],
        this.hdr.dims[2] - 2 * borders[1],
        this.hdr.dims[3] - 2 * borders[2]
      ];
      const bordersHi = [dims[0] + borders[0], dims[1] + borders[1], dims[2] + borders[2]];
      nVox3D = dims[0] * dims[1] * dims[2];
      img = new this.img.constructor(nVox3D);
      let j = -1;
      let i = 0;
      for (let z = 0; z < this.hdr.dims[3]; z++) {
        for (let y = 0; y < this.hdr.dims[2]; y++) {
          for (let x = 0; x < this.hdr.dims[1]; x++) {
            j++;
            if (x < borders[0] || y < borders[1] || z < borders[2]) {
              continue;
            }
            if (x >= bordersHi[0] || y >= bordersHi[1] || z >= bordersHi[2]) {
              continue;
            }
            img[i] = this.img[j + skipVox];
            i++;
          }
        }
      }
    }
    const isFastCalc = img.constructor !== Float64Array && img.constructor !== Float32Array && this.ignoreZeroVoxels;
    if (isFastCalc) {
      for (let i = 0; i < nVox3D; i++) {
        mn = Math.min(img[i], mn);
        mx = Math.max(img[i], mx);
        if (img[i] === 0) {
          nZero++;
        }
      }
    } else {
      for (let i = 0; i < nVox3D; i++) {
        if (isNaN(img[i])) {
          nNan++;
          continue;
        }
        if (img[i] === 0) {
          nZero++;
          if (this.ignoreZeroVoxels) {
            continue;
          }
        }
        mn = Math.min(img[i], mn);
        mx = Math.max(img[i], mx);
      }
    }
    if (this.ignoreZeroVoxels && mn === mx && nZero > 0) {
      mn = 0;
    }
    const mnScale = this.intensityRaw2Scaled(mn);
    const mxScale = this.intensityRaw2Scaled(mx);
    const cmap = cmapper.colormapFromKey(this._colormap);
    let cmMin = 0;
    let cmMax = 0;
    if (cmap.min !== void 0) {
      cmMin = cmap.min;
    }
    if (cmap.max !== void 0) {
      cmMax = cmap.max;
    }
    if (cmMin === cmMax && this.trustCalMinMax && isFinite(this.hdr.cal_min) && isFinite(this.hdr.cal_max) && this.hdr.cal_max > this.hdr.cal_min) {
      this.cal_min = this.hdr.cal_min;
      this.cal_max = this.hdr.cal_max;
      this.robust_min = this.cal_min;
      this.robust_max = this.cal_max;
      this.global_min = mnScale;
      this.global_max = mxScale;
      return [this.hdr.cal_min, this.hdr.cal_max, this.hdr.cal_min, this.hdr.cal_max];
    }
    if (cmMin !== cmMax) {
      this.cal_min = cmMin;
      this.cal_max = cmMax;
      this.robust_min = this.cal_min;
      this.robust_max = this.cal_max;
      return [cmMin, cmMax, cmMin, cmMax];
    }
    const percentZero = 100 * nZero / (nVox3D - 0);
    let isOverrideIgnoreZeroVoxels = false;
    if (percentZero > 60 && !this.ignoreZeroVoxels) {
      log.warn(`${Math.round(percentZero)}% of voxels are zero: ignoring zeros for cal_max`);
      isOverrideIgnoreZeroVoxels = true;
      this.ignoreZeroVoxels = true;
    }
    if (!this.ignoreZeroVoxels) {
      nZero = 0;
    }
    nZero += nNan;
    const n2pct = Math.round((nVox3D - 0 - nZero) * this.percentileFrac);
    if (n2pct < 1 || mn === mx) {
      log.debug("no variability in image intensity?");
      this.cal_min = mnScale;
      this.cal_max = mxScale;
      this.robust_min = this.cal_min;
      this.robust_max = this.cal_max;
      this.global_min = mnScale;
      this.global_max = mxScale;
      return [mnScale, mxScale, mnScale, mxScale];
    }
    const nBins = 1001;
    const scl = (nBins - 1) / (mx - mn);
    const hist = new Array(nBins);
    for (let i = 0; i < nBins; i++) {
      hist[i] = 0;
    }
    if (isFastCalc) {
      for (let i = 0; i < nVox3D; i++) {
        hist[Math.round((img[i] - mn) * scl)]++;
      }
    } else if (this.ignoreZeroVoxels) {
      for (let i = 0; i < nVox3D; i++) {
        if (img[i] === 0) {
          continue;
        }
        if (isNaN(img[i])) {
          continue;
        }
        hist[Math.round((img[i] - mn) * scl)]++;
      }
    } else {
      for (let i = 0; i < nVox3D; i++) {
        if (isNaN(img[i])) {
          continue;
        }
        hist[Math.round((img[i] - mn) * scl)]++;
      }
    }
    let n = 0;
    let lo = 0;
    while (n < n2pct) {
      n += hist[lo];
      lo++;
    }
    lo--;
    n = 0;
    let hi = nBins;
    while (n < n2pct) {
      hi--;
      n += hist[hi];
    }
    if (lo === hi) {
      let ok = -1;
      while (ok !== 0) {
        if (lo > 0) {
          lo--;
          if (hist[lo] > 0) {
            ok = 0;
          }
        }
        if (ok !== 0 && hi < nBins - 1) {
          hi++;
          if (hist[hi] > 0) {
            ok = 0;
          }
        }
        if (lo === 0 && hi === nBins - 1) {
          ok = 0;
        }
      }
    }
    let pct2 = this.intensityRaw2Scaled(lo / scl + mn);
    let pct98 = this.intensityRaw2Scaled(hi / scl + mn);
    if (this.hdr.cal_min < this.hdr.cal_max && this.hdr.cal_min >= mnScale && this.hdr.cal_max <= mxScale) {
      pct2 = this.hdr.cal_min;
      pct98 = this.hdr.cal_max;
    }
    if (isOverrideIgnoreZeroVoxels) {
      pct2 = Math.min(pct2, 0);
    }
    this.cal_min = pct2;
    this.cal_max = pct98;
    this.robust_min = this.cal_min;
    this.robust_max = this.cal_max;
    this.global_min = mnScale;
    this.global_max = mxScale;
    return [pct2, pct98, mnScale, mxScale];
  }
  // calMinMax
  // not included in public docs
  // convert voxel intensity from stored value to scaled intensity
  intensityRaw2Scaled(raw) {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    if (this.hdr.scl_slope === 0) {
      this.hdr.scl_slope = 1;
    }
    return raw * this.hdr.scl_slope + this.hdr.scl_inter;
  }
  // convert voxel intensity from scaled intensity to stored value
  intensityScaled2Raw(scaled) {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    if (this.hdr.scl_slope === 0) {
      this.hdr.scl_slope = 1;
    }
    return (scaled - this.hdr.scl_inter) / this.hdr.scl_slope;
  }
  // not included in public docs
  // see niivue.saveImage() for wrapper of this function
  async saveToUint8Array(fnm, drawing8 = null) {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    if (!this.img) {
      throw new Error("img undefined");
    }
    const isDrawing8 = drawing8 !== null;
    const hdrBytes = hdrToArrayBuffer(this.hdr, isDrawing8);
    const opad = new Uint8Array(4);
    let img8 = new Uint8Array(this.img.buffer);
    if (isDrawing8) {
      img8 = new Uint8Array(drawing8.buffer);
    }
    const odata = new Uint8Array(hdrBytes.length + opad.length + img8.length);
    odata.set(hdrBytes);
    odata.set(opad, hdrBytes.length);
    odata.set(img8, hdrBytes.length + opad.length);
    let saveData = null;
    const compress = fnm.endsWith(".gz");
    if (compress) {
      saveData = new Uint8Array(await NVUtilities.compress(odata, "gzip"));
    } else {
      saveData = odata;
    }
    return saveData;
  }
  // not included in public docs
  // save image as NIfTI volume
  // if fnm is empty, data is returned
  async saveToDisk(fnm = "", drawing8 = null) {
    const saveData = await this.saveToUint8Array(fnm, drawing8);
    if (fnm === "") {
      log.debug("saveToDisk: empty file name, returning data as Uint8Array rather than triggering download");
      return saveData;
    }
    const blob = new Blob([saveData.buffer], {
      type: "application/octet-stream"
    });
    const blobUrl = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.setAttribute("href", blobUrl);
    link.setAttribute("download", fnm);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    return saveData;
  }
  // saveToDisk()
  static async fetchDicomData(url, headers = {}) {
    if (url === "") {
      throw Error("url must not be empty");
    }
    const absoluteUrlRE = /^(?:[a-z+]+:)?\/\//i;
    let manifestUrl = absoluteUrlRE.test(url) ? url : new URL(url, window.location.href);
    const extensionRE = /(?:.([^.]+))?$/;
    const extension = extensionRE.exec(manifestUrl.pathname);
    if (!extension) {
      manifestUrl = new URL("niivue-manifest.txt", url);
    }
    let response = await fetch(manifestUrl, { headers });
    if (!response.ok) {
      throw Error(response.statusText);
    }
    const text = await response.text();
    const lines = text.split("\n");
    const baseUrlRE = /(.*\/).*/;
    const folderUrl = baseUrlRE.exec(manifestUrl)[0];
    const dataBuffer = [];
    for (const line of lines) {
      const fileUrl = new URL(line, folderUrl);
      response = await fetch(fileUrl, { headers });
      if (!response.ok) {
        throw Error(response.statusText);
      }
      const contents = await response.arrayBuffer();
      dataBuffer.push({
        name: line,
        data: contents
      });
    }
    return dataBuffer;
  }
  static async readFirstDecompressedBytes(stream, minBytes) {
    const reader = stream.getReader();
    const gunzip = new Gunzip();
    const decompressedChunks = [];
    let totalDecompressed = 0;
    let doneReading = false;
    let resolveFn;
    let rejectFn;
    const promise = new Promise((resolve, reject) => {
      resolveFn = resolve;
      rejectFn = reject;
      return void 0;
    });
    function finalize() {
      const result = new Uint8Array(totalDecompressed);
      let offset = 0;
      for (const chunk of decompressedChunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      resolveFn(result);
    }
    gunzip.ondata = (chunk) => {
      decompressedChunks.push(chunk);
      totalDecompressed += chunk.length;
      if (totalDecompressed >= minBytes) {
        doneReading = true;
        reader.cancel().catch(() => {
        });
        finalize();
      }
    };
    (async () => {
      try {
        while (!doneReading) {
          const { done, value } = await reader.read();
          if (done) {
            doneReading = true;
            gunzip.push(new Uint8Array(), true);
            return;
          }
          gunzip.push(value, false);
        }
      } catch (err2) {
        rejectFn(err2);
      }
    })().catch(() => {
    });
    return promise;
  }
  static extractFilenameFromUrl(url) {
    const params = new URL(url).searchParams;
    const contentDisposition = params.get("response-content-disposition");
    if (contentDisposition) {
      const match = contentDisposition.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/);
      if (match) {
        return decodeURIComponent(match[1]);
      }
    }
    return url.split("/").pop().split("?")[0];
  }
  static async loadInitialVolumesGz(url = "", headers = {}, limitFrames4D = NaN) {
    if (isNaN(limitFrames4D)) {
      return null;
    }
    const response = await fetch(url, { headers, cache: "force-cache" });
    let hdrBytes = 352;
    let hdrU8s = await this.readFirstDecompressedBytes(response.body, hdrBytes);
    const hdrView = new DataView(hdrU8s.buffer, hdrU8s.byteOffset, hdrU8s.byteLength);
    const u162 = hdrView.getUint16(0, true);
    const isNIfTI1 = u162 === 348;
    const isNIfTI1be = u162 === 23553;
    if (!isNIfTI1 && !isNIfTI1be) {
      return null;
    }
    if (hdrU8s.length > 111) {
      hdrBytes = hdrView.getFloat32(108, isNIfTI1);
    }
    if (hdrBytes > hdrU8s.length) {
      hdrU8s = await this.readFirstDecompressedBytes(response.body, hdrBytes);
    }
    const isNifti1 = hdrU8s[0] === 92 && hdrU8s[1] === 1 || hdrU8s[1] === 92 && hdrU8s[0] === 1;
    if (!isNifti1) {
      return null;
    }
    const hdr = await readHeaderAsync(hdrU8s.buffer);
    if (!hdr) {
      throw new Error("Could not read NIfTI header");
    }
    const nBytesPerVoxel = hdr.numBitsPerVoxel / 8;
    const nVox3D = [1, 2, 3].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
    const nFrame4D = [4, 5, 6].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
    const volsToLoad = Math.max(Math.min(limitFrames4D, nFrame4D), 1);
    const bytesToLoad = hdr.vox_offset + volsToLoad * nVox3D * nBytesPerVoxel;
    if (volsToLoad === nFrame4D) {
      return null;
    }
    const responseImg = await fetch(url, { headers, cache: "force-cache" });
    const dataBytes = await this.readFirstDecompressedBytes(responseImg.body, bytesToLoad);
    return dataBytes.buffer.slice(0, bytesToLoad);
  }
  static async loadInitialVolumes(url = "", headers = {}, limitFrames4D = NaN) {
    if (isNaN(limitFrames4D)) {
      return null;
    }
    const response = await fetch(url, { headers, cache: "force-cache" });
    const reader = response.body.getReader();
    const { value, done } = await reader.read();
    let hdrU8s = value;
    if (done || !hdrU8s || hdrU8s.length < 2) {
      throw new Error("Not enough data to determine compression");
    }
    const hdrView = new DataView(hdrU8s.buffer, hdrU8s.byteOffset, hdrU8s.byteLength);
    const u162 = hdrView.getUint16(0, true);
    const isGz = u162 === 35615;
    if (isGz) {
      await reader.cancel();
      return this.loadInitialVolumesGz(url, headers, limitFrames4D);
    }
    const isNIfTI1 = u162 === 348;
    const isNIfTI1be = u162 === 23553;
    if (!isNIfTI1 && !isNIfTI1be) {
      await reader.cancel();
      return null;
    }
    let hdrBytes = 352;
    if (hdrU8s.length > 111) {
      hdrBytes = hdrView.getFloat32(108, isNIfTI1);
    }
    while (hdrU8s.length < hdrBytes) {
      let concatU8s = function(arr1, arr2) {
        const result = new Uint8Array(arr1.length + arr2.length);
        result.set(arr1, 0);
        result.set(arr2, arr1.length);
        return result;
      };
      const { value: value2, done: done2 } = await reader.read();
      if (done2 || !value2) {
        break;
      }
      hdrU8s = concatU8s(hdrU8s, value2);
    }
    const hdr = await readHeaderAsync(hdrU8s.buffer);
    if (!hdr) {
      throw new Error("Could not read NIfTI header");
    }
    const nBytesPerVoxel = hdr.numBitsPerVoxel / 8;
    const nVox3D = [1, 2, 3].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
    const nFrame4D = [4, 5, 6].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
    const volsToLoad = Math.max(Math.min(limitFrames4D, nFrame4D), 1);
    const bytesToLoad = hdr.vox_offset + volsToLoad * nVox3D * nBytesPerVoxel;
    const imgU8s = new Uint8Array(bytesToLoad);
    const hdrCopyLength = Math.min(hdrU8s.length, bytesToLoad);
    imgU8s.set(hdrU8s.subarray(0, hdrCopyLength), 0);
    let bytesRead = hdrCopyLength;
    while (bytesRead < bytesToLoad) {
      const { value: value2, done: done2 } = await reader.read();
      if (done2 || !value2) {
        await reader.cancel();
        return null;
      }
      const remaining = Math.min(value2.length, bytesToLoad - bytesRead);
      imgU8s.set(value2.subarray(0, remaining), bytesRead);
      bytesRead += remaining;
    }
    await reader.cancel();
    return imgU8s.buffer;
  }
  /**
   * factory function to load and return a new NVImage instance from a given URL
   * @returns  NVImage instance
   */
  static async loadFromUrl({
    url = "",
    urlImgData = "",
    headers = {},
    name = "",
    colormap = "gray",
    opacity = 1,
    cal_min = NaN,
    cal_max = NaN,
    trustCalMinMax = true,
    percentileFrac = 0.02,
    ignoreZeroVoxels = false,
    useQFormNotSForm = false,
    colormapNegative = "",
    frame4D = 0,
    isManifest = false,
    limitFrames4D = NaN,
    imageType = NVIMAGE_TYPE.UNKNOWN,
    colorbarVisible = true,
    buffer = new ArrayBuffer(0)
  } = {}) {
    if (url === "") {
      throw Error("url must not be empty");
    }
    let nvimage = null;
    let dataBuffer = null;
    if (url instanceof Uint8Array) {
      url = url.buffer;
    }
    if (buffer.byteLength > 0) {
      url = buffer;
    }
    if (url instanceof ArrayBuffer) {
      dataBuffer = url;
      if (name !== "") {
        url = name;
      } else {
        const bytes = new Uint8Array(dataBuffer);
        url = bytes[0] === 31 && bytes[1] === 139 ? "array.nii.gz" : "array.nii";
      }
    }
    function getPrimaryExtension(filename) {
      const match = filename.match(/\.([^.]+)(?:\.gz|\.bz2|\.xz)?$/);
      return match ? match[1] : "";
    }
    let ext = "";
    if (name === "") {
      ext = getPrimaryExtension(url);
    } else {
      ext = getPrimaryExtension(name);
    }
    if (imageType === NVIMAGE_TYPE.UNKNOWN) {
      imageType = NVIMAGE_TYPE.parse(ext);
    }
    if (imageType === NVIMAGE_TYPE.UNKNOWN && typeof url === "string") {
      const response = await fetch(url, {});
      if (response.redirected) {
        const rname = this.extractFilenameFromUrl(response.url);
        if (rname && rname.length > 0) {
          if (name === "") {
            name = rname;
            ext = getPrimaryExtension(name);
            imageType = NVIMAGE_TYPE.parse(ext);
          }
        }
      }
    }
    const isTestNIfTI = imageType === NVIMAGE_TYPE.DCM || NVIMAGE_TYPE.NII;
    if (!dataBuffer && isTestNIfTI) {
      dataBuffer = await this.loadInitialVolumes(url, headers, limitFrames4D);
    }
    if (!dataBuffer) {
      if (isManifest) {
        dataBuffer = await _NVImage.fetchDicomData(url, headers);
        imageType = NVIMAGE_TYPE.DCM_MANIFEST;
      } else {
        const response = await fetch(url, { headers });
        if (!response.ok) {
          throw Error(response.statusText);
        }
        if (!response.body) {
          throw new Error("No readable stream available");
        }
        const stream = await uncompressStream(response.body);
        const chunks = [];
        const reader = stream.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          chunks.push(value);
        }
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        dataBuffer = new ArrayBuffer(totalLength);
        const dataView = new Uint8Array(dataBuffer);
        let offset = 0;
        for (const chunk of chunks) {
          dataView.set(chunk, offset);
          offset += chunk.length;
        }
      }
    }
    if (ext.toUpperCase() === "HEAD") {
      if (urlImgData === "") {
        urlImgData = url.substring(0, url.lastIndexOf("HEAD")) + "BRIK";
      }
    }
    let pairedImgData = null;
    if (urlImgData) {
      try {
        let response = await fetch(urlImgData, { headers });
        if (response.status === 404 && urlImgData.includes("BRIK")) {
          response = await fetch(`${urlImgData}.gz`, { headers });
        }
        if (response.ok && response.body) {
          const stream = await uncompressStream(response.body);
          const chunks = [];
          const reader = stream.getReader();
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            chunks.push(value);
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          pairedImgData = new ArrayBuffer(totalLength);
          const dataView = new Uint8Array(pairedImgData);
          let offset = 0;
          for (const chunk of chunks) {
            dataView.set(chunk, offset);
            offset += chunk.length;
          }
        }
      } catch (error) {
        console.error("Error loading paired image data:", error);
      }
    }
    if (!dataBuffer) {
      throw new Error("Unable to load buffer properly from volume");
    }
    if (!name) {
      let urlParts;
      try {
        urlParts = new URL(url).pathname.split("/");
      } catch (e) {
        urlParts = url.split("/");
      }
      name = urlParts.slice(-1)[0];
      if (name.indexOf("?") > -1) {
        name = name.slice(0, name.indexOf("?"));
      }
    }
    nvimage = await this.new(
      dataBuffer,
      name,
      colormap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      useQFormNotSForm,
      colormapNegative,
      frame4D,
      imageType
    );
    nvimage.url = url;
    nvimage.colorbarVisible = colorbarVisible;
    return nvimage;
  }
  // not included in public docs
  // loading Nifti files
  static async readFileAsync(file, bytesToLoad = NaN) {
    let stream = file.stream();
    if (!isNaN(bytesToLoad)) {
      let bytesRead = 0;
      const limiter = new TransformStream({
        transform(chunk, controller) {
          if (bytesRead >= bytesToLoad) {
            controller.terminate();
            return;
          }
          const remainingBytes = bytesToLoad - bytesRead;
          if (chunk.length > remainingBytes) {
            controller.enqueue(chunk.slice(0, remainingBytes));
            controller.terminate();
          } else {
            controller.enqueue(chunk);
          }
          bytesRead += chunk.length;
        }
      });
      stream = stream.pipeThrough(limiter);
    }
    const uncompressedStream = await uncompressStream(stream);
    const chunks = [];
    const reader = uncompressedStream.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      chunks.push(value);
    }
    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const result = new ArrayBuffer(totalLength);
    const resultView = new Uint8Array(result);
    let offset = 0;
    for (const chunk of chunks) {
      resultView.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }
  /**
   * factory function to load and return a new NVImage instance from a file in the browser
   */
  static async loadFromFile({
    file,
    // file can be an array of file objects or a single file object
    name = "",
    colormap = "gray",
    opacity = 1,
    urlImgData = null,
    cal_min = NaN,
    cal_max = NaN,
    trustCalMinMax = true,
    percentileFrac = 0.02,
    ignoreZeroVoxels = false,
    useQFormNotSForm = false,
    colormapNegative = "",
    frame4D = 0,
    limitFrames4D = NaN,
    imageType = NVIMAGE_TYPE.UNKNOWN
  }) {
    let nvimage = null;
    let dataBuffer = [];
    try {
      if (Array.isArray(file)) {
        dataBuffer = await Promise.all(file.map((f) => this.readFileAsync(f)));
      } else {
        if (!isNaN(limitFrames4D)) {
          const headerBuffer = await this.readFileAsync(file, 512);
          const headerView = new Uint8Array(headerBuffer);
          const isNifti1 = headerView[0] === 92 && headerView[1] === 1 || headerView[1] === 92 && headerView[0] === 1;
          if (!isNifti1) {
            dataBuffer = await this.readFileAsync(file);
          } else {
            const hdr = await readHeaderAsync(headerBuffer);
            if (!hdr) {
              throw new Error("could not read nifti header");
            }
            const nBytesPerVoxel = hdr.numBitsPerVoxel / 8;
            const nVox3D = [1, 2, 3].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
            const nFrame4D = [4, 5, 6].reduce((acc, i) => acc * (hdr.dims[i] > 1 ? hdr.dims[i] : 1), 1);
            const volsToLoad = Math.max(Math.min(limitFrames4D, nFrame4D), 1);
            const bytesToLoad = hdr.vox_offset + volsToLoad * nVox3D * nBytesPerVoxel;
            dataBuffer = await this.readFileAsync(file, bytesToLoad);
          }
        } else {
          dataBuffer = await this.readFileAsync(file);
        }
        name = file.name;
      }
      let pairedImgData = null;
      if (urlImgData) {
        pairedImgData = await this.readFileAsync(urlImgData);
      }
      nvimage = await this.new(
        dataBuffer,
        name,
        colormap,
        opacity,
        pairedImgData,
        cal_min,
        cal_max,
        trustCalMinMax,
        percentileFrac,
        ignoreZeroVoxels,
        useQFormNotSForm,
        colormapNegative,
        frame4D,
        imageType
      );
      nvimage.fileObject = file;
    } catch (err2) {
      log.error(err2);
      throw new Error("could not build NVImage");
    }
    if (nvimage === null) {
      throw new Error("could not build NVImage");
    }
    return nvimage;
  }
  /**
   * factory function to load and return a new NVImage instance from a base64 encoded string
   *
   * @returns NVImage instance
   * @example
   * myImage = NVImage.loadFromBase64('SomeBase64String')
   */
  static createNiftiArray(dims = [256, 256, 256], pixDims = [1, 1, 1], affine = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], datatypeCode = 2, img = new Uint8Array()) {
    const hdr = this.createNiftiHeader(dims, pixDims, affine, datatypeCode);
    const hdrBytes = hdrToArrayBuffer(hdr, false);
    if (img.length < 1) {
      return hdrBytes;
    }
    const opad = new Uint8Array(4);
    const img8 = new Uint8Array(img.buffer);
    const odata = new Uint8Array(hdrBytes.length + opad.length + img8.length);
    odata.set(hdrBytes);
    odata.set(opad, hdrBytes.length);
    odata.set(img8, hdrBytes.length + opad.length);
    return odata;
  }
  // createNiftiFile()
  static createNiftiHeader(dims = [256, 256, 256], pixDims = [1, 1, 1], affine = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], datatypeCode = 2) {
    const hdr = new NIFTI1();
    hdr.littleEndian = true;
    hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
    hdr.dims[0] = Math.max(3, dims.length);
    for (let i = 0; i < dims.length; i++) {
      hdr.dims[i + 1] = dims[i];
    }
    hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    for (let i = 0; i < dims.length; i++) {
      hdr.pixDims[i + 1] = pixDims[i];
    }
    if (affine.length === 16) {
      let k = 0;
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          hdr.affine[i][j] = affine[k];
          k++;
        }
      }
    }
    let bpv = 8;
    if (datatypeCode === 256 || datatypeCode === 2) {
      bpv = 8;
    } else if (datatypeCode === 512 || datatypeCode === 4) {
      bpv = 16;
    } else if (datatypeCode === 16 || datatypeCode === 768 || datatypeCode === 8 || datatypeCode === 2304) {
      bpv = 32;
    } else if (datatypeCode === 64) {
      bpv = 64;
    } else {
      log.warn("Unsupported NIfTI datatypeCode: " + datatypeCode);
    }
    hdr.datatypeCode = datatypeCode;
    hdr.numBitsPerVoxel = bpv;
    hdr.scl_inter = 0;
    hdr.scl_slope = 0;
    hdr.sform_code = 2;
    hdr.magic = "n+1";
    hdr.vox_offset = 352;
    return hdr;
  }
  // loadFromHeader
  /**
   * read a 3D slab of voxels from a volume
   * @param voxStart - first row, column and slice (RAS order) for selection
   * @param voxEnd - final row, column and slice (RAS order) for selection
   * @param dataType - array data type. Options: 'same' (default), 'uint8', 'float32', 'scaled', 'normalized', 'windowed'
   * @returns the an array where ret[0] is the voxel values and ret[1] is dimension of selection
   * @see {@link https://niivue.github.io/niivue/features/slab_selection.html | live demo usage}
   */
  getVolumeData(voxStart = [-1, 0, 0], voxEnd = [0, 0, 0], dataType = "same") {
    let img = new Uint8Array();
    if (Math.min(...voxStart) < 0 || Math.min(...voxEnd) < 0) {
      return [img, [0, 0, 0]];
    }
    const dims = this.dimsRAS.slice(1, 4);
    for (let i2 = 0; i2 < 3; i2++) {
      voxStart[i2] = Math.min(voxStart[i2], dims[i2] - 1);
      voxEnd[i2] = Math.min(voxEnd[i2], dims[i2] - 1);
      if (voxEnd[i2] < voxStart[i2]) {
        const tmp = voxEnd[i2];
        voxEnd[i2] = voxStart[i2];
        voxStart[i2] = tmp;
      }
    }
    const slabDims = [voxEnd[0] - voxStart[0] + 1, voxEnd[1] - voxStart[1] + 1, voxEnd[2] - voxStart[2] + 1];
    const slabNVox = slabDims[0] * slabDims[1] * slabDims[2];
    let dt = this.hdr.datatypeCode;
    if (dataType === "uint8") {
      dt = 2 /* DT_UINT8 */;
    } else if (dataType === "float32" || dataType === "scaled" || dataType === "normalized" || dataType === "windowed") {
      dt = 16 /* DT_FLOAT32 */;
    }
    if (dt === 2 /* DT_UINT8 */) {
      img = new Uint8Array(slabNVox);
    } else if (dt === 4 /* DT_INT16 */) {
      img = new Int16Array(slabNVox);
    } else if (dt === 512 /* DT_UINT16 */) {
      img = new Uint16Array(slabNVox);
    } else if (dt === 16 /* DT_FLOAT32 */) {
      img = new Float32Array(slabNVox);
    } else if (dt === 64 /* DT_FLOAT64 */) {
      img = new Float64Array(slabNVox);
    } else {
      log.error("getVolumeData unsupported datatype");
      return [img, [0, 0, 0]];
    }
    const outStep = this.img2RASstep;
    const outStart = this.img2RASstart;
    let i = 0;
    for (let z = voxStart[2]; z <= voxEnd[2]; z++) {
      const zi = outStart[2] + z * outStep[2];
      for (let y = voxStart[1]; y <= voxEnd[1]; y++) {
        const yizi = zi + outStart[1] + y * outStep[1];
        for (let x = voxStart[0]; x <= voxEnd[0]; x++) {
          const xi = outStart[0] + x * outStep[0];
          img[i++] = this.img[xi + yizi];
        }
      }
    }
    if (dataType === "scaled" || dataType === "normalized" || dataType === "windowed") {
      for (let i2 = 0; i2 < img.length; i2++) {
        img[i2] = img[i2] * this.hdr.scl_slope + this.hdr.scl_inter;
      }
    }
    if (dataType === "normalized" || dataType === "windowed") {
      let mn = this.cal_min;
      let mx = this.cal_max;
      if (dataType === "normalized") {
        mn = this.global_min;
        mx = this.global_max;
      }
      const scale6 = 1 / (mx - mn);
      for (let i2 = 0; i2 < img.length; i2++) {
        img[i2] = (img[i2] - mn) * scale6;
        img[i2] = Math.max(Math.min(img[i2], 1), 0);
      }
    }
    return [img, slabDims];
  }
  // getVolumeData()
  /**
   * write a 3D slab of voxels from a volume
   * @param voxStart - first row, column and slice (RAS order) for selection
   * @param voxEnd - final row, column and slice (RAS order) for selection
   * @param img - array of voxel values to insert (RAS order)
   * @see {@link https://niivue.github.io/niivue/features/slab_selection.html | live demo usage}
   */
  setVolumeData(voxStart = [-1, 0, 0], voxEnd = [0, 0, 0], img = new Uint8Array()) {
    if (img.length < 1 || Math.min(...voxStart) < 0 || Math.min(...voxEnd) < 0) {
      return;
    }
    const dims = this.dimsRAS.slice(1, 4);
    for (let i2 = 0; i2 < 3; i2++) {
      voxStart[i2] = Math.min(voxStart[i2], dims[i2] - 1);
      voxEnd[i2] = Math.min(voxEnd[i2], dims[i2] - 1);
      if (voxEnd[i2] < voxStart[i2]) {
        const tmp = voxEnd[i2];
        voxEnd[i2] = voxStart[i2];
        voxStart[i2] = tmp;
      }
    }
    const slabDims = [voxEnd[0] - voxStart[0] + 1, voxEnd[1] - voxStart[1] + 1, voxEnd[2] - voxStart[2] + 1];
    const slabNVox = slabDims[0] * slabDims[1] * slabDims[2];
    if (img.length < slabNVox) {
      log.error("setVolumeData image does not have enough voxels");
      return;
    }
    const outStep = this.img2RASstep;
    const outStart = this.img2RASstart;
    let i = 0;
    for (let z = voxStart[2]; z <= voxEnd[2]; z++) {
      const zi = outStart[2] + z * outStep[2];
      for (let y = voxStart[1]; y <= voxEnd[1]; y++) {
        const yizi = zi + outStart[1] + y * outStep[1];
        for (let x = voxStart[0]; x <= voxEnd[0]; x++) {
          const xi = outStart[0] + x * outStep[0];
          this.img[xi + yizi] = img[i++];
        }
      }
    }
  }
  // setVolumeData()
  /**
   * factory function to load and return a new NVImage instance from a base64 encoded string
   *
   * @returns NVImage instance
   * @example
   * myImage = NVImage.loadFromBase64('SomeBase64String')
   */
  static async loadFromBase64({
    base64,
    name = "",
    colormap = "gray",
    opacity = 1,
    cal_min = NaN,
    cal_max = NaN,
    trustCalMinMax = true,
    percentileFrac = 0.02,
    ignoreZeroVoxels = false,
    useQFormNotSForm = false,
    colormapNegative = "",
    frame4D = 0,
    imageType = NVIMAGE_TYPE.UNKNOWN,
    cal_minNeg = NaN,
    cal_maxNeg = NaN,
    colorbarVisible = true,
    colormapLabel = null
  }) {
    function base64ToArrayBuffer(base642) {
      const binary_string = window.atob(base642);
      const len4 = binary_string.length;
      const bytes = new Uint8Array(len4);
      for (let i = 0; i < len4; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }
    let nvimage = null;
    try {
      const dataBuffer = base64ToArrayBuffer(base64);
      const pairedImgData = null;
      nvimage = await this.new(
        dataBuffer,
        name,
        colormap,
        opacity,
        pairedImgData,
        cal_min,
        cal_max,
        trustCalMinMax,
        percentileFrac,
        ignoreZeroVoxels,
        useQFormNotSForm,
        colormapNegative,
        frame4D,
        imageType,
        cal_minNeg,
        cal_maxNeg,
        colorbarVisible,
        colormapLabel
      );
    } catch (err2) {
      log.debug(err2);
    }
    if (nvimage === null) {
      throw new Error("could not load NVImage");
    }
    return nvimage;
  }
  /**
   * make a clone of a NVImage instance and return a new NVImage
   * @returns NVImage instance
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * clonedImage = myImage.clone()
   */
  clone() {
    const clonedImage = new _NVImage();
    clonedImage.id = v4();
    clonedImage.hdr = Object.assign({}, this.hdr);
    clonedImage.img = this.img.slice();
    clonedImage.calculateRAS();
    clonedImage.calMinMax();
    return clonedImage;
  }
  /**
   * fill a NVImage instance with zeros for the image data
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * clonedImageWithZeros = myImage.clone().zeroImage()
   */
  zeroImage() {
    this.img.fill(0);
  }
  /**
   * get nifti specific metadata about the image
   */
  getImageMetadata() {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    const id = this.id;
    const datatypeCode = this.hdr.datatypeCode;
    const dims = this.hdr.dims;
    const nx = dims[1];
    const ny = dims[2];
    const nz = dims[3];
    const nt = Math.max(1, dims[4]);
    const pixDims = this.hdr.pixDims;
    const dx = pixDims[1];
    const dy = pixDims[2];
    const dz = pixDims[3];
    const dt = pixDims[4];
    const bpv = Math.floor(this.hdr.numBitsPerVoxel / 8);
    return {
      id,
      datatypeCode,
      nx,
      ny,
      nz,
      nt,
      dx,
      dy,
      dz,
      dt,
      bpv
    };
  }
  /**
   * a factory function to make a zero filled image given a NVImage as a reference
   * @param nvImage - an existing NVImage as a reference
   * @param dataType - the output data type. Options: 'same', 'uint8'
   * @returns new NVImage filled with zeros for the image data
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * newZeroImage = NVImage.zerosLike(myImage)
   */
  static zerosLike(nvImage, dataType = "same") {
    const zeroClone = nvImage.clone();
    zeroClone.zeroImage();
    if (dataType === "uint8") {
      zeroClone.img = Uint8Array.from(zeroClone.img);
      zeroClone.hdr.datatypeCode = 2 /* DT_UINT8 */;
      zeroClone.hdr.numBitsPerVoxel = 8;
    }
    if (dataType === "float32") {
      zeroClone.img = Float32Array.from(zeroClone.img);
      zeroClone.hdr.datatypeCode = 16 /* DT_FLOAT32 */;
      zeroClone.hdr.numBitsPerVoxel = 32;
    }
    return zeroClone;
  }
  // not included in public docs
  // return voxel intensity at specific coordinates (xyz are zero indexed column row, slice)
  getValue(x, y, z, frame4D = 0, isReadImaginary = false) {
    if (!this.hdr) {
      throw new Error("hdr undefined");
    }
    if (!this.img) {
      throw new Error("img undefined");
    }
    const nx = this.hdr.dims[1];
    const ny = this.hdr.dims[2];
    const nz = this.hdr.dims[3];
    const perm = this.permRAS.slice();
    if (perm[0] !== 1 || perm[1] !== 2 || perm[2] !== 3) {
      const pos = vec4_exports.fromValues(x, y, z, 1);
      vec4_exports.transformMat4(pos, pos, this.toRASvox);
      x = pos[0];
      y = pos[1];
      z = pos[2];
    }
    let vx = x + y * nx + z * nx * ny;
    if (this.hdr.datatypeCode === 2304 /* DT_RGBA32 */) {
      vx *= 4;
      return Math.round(this.img[vx] * 0.21 + this.img[vx + 1] * 0.72 + this.img[vx + 2] * 0.07);
    }
    if (this.hdr.datatypeCode === 128 /* DT_RGB24 */) {
      vx *= 3;
      return Math.round(this.img[vx] * 0.21 + this.img[vx + 1] * 0.72 + this.img[vx + 2] * 0.07);
    }
    const vol = frame4D * nx * ny * nz;
    let i = this.img[vx + vol];
    if (isReadImaginary) {
      i = this.imaginary[vx + vol];
    }
    return this.hdr.scl_slope * i + this.hdr.scl_inter;
  }
  /**
   * @param id - id of 3D Object (is this the base volume or an overlay?)
   * @param gl - WebGL rendering context
   * @returns new 3D object in model space
   */
  toNiivueObject3D(id, gl) {
    const dimsRAS = this.dimsRAS;
    const matRAS = this.matRAS;
    const pixDimsRAS = this.pixDimsRAS;
    const L = -0.5;
    const P = -0.5;
    const I = -0.5;
    const R = dimsRAS[1] - 1 + 0.5;
    const A = dimsRAS[2] - 1 + 0.5;
    const S = dimsRAS[3] - 1 + 0.5;
    const LPI = this.vox2mm([L, P, I], matRAS);
    const LAI = this.vox2mm([L, A, I], matRAS);
    const LPS = this.vox2mm([L, P, S], matRAS);
    const LAS = this.vox2mm([L, A, S], matRAS);
    const RPI = this.vox2mm([R, P, I], matRAS);
    const RAI = this.vox2mm([R, A, I], matRAS);
    const RPS = this.vox2mm([R, P, S], matRAS);
    const RAS = this.vox2mm([R, A, S], matRAS);
    const posTex = [
      // spatial position (XYZ), texture coordinates UVW
      // Superior face
      ...LPS,
      ...[0, 0, 1],
      ...RPS,
      ...[1, 0, 1],
      ...RAS,
      ...[1, 1, 1],
      ...LAS,
      ...[0, 1, 1],
      // Inferior face
      ...LPI,
      ...[0, 0, 0],
      ...LAI,
      ...[0, 1, 0],
      ...RAI,
      ...[1, 1, 0],
      ...RPI,
      ...[1, 0, 0]
    ];
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    const indices = [
      // six faces of cube: each has 2 triangles (6 indices)
      0,
      3,
      2,
      2,
      1,
      0,
      // Top
      4,
      7,
      6,
      6,
      5,
      4,
      // Bottom
      5,
      6,
      2,
      2,
      3,
      5,
      // Front
      4,
      0,
      1,
      1,
      7,
      4,
      // Back
      7,
      1,
      2,
      2,
      6,
      7,
      // Right
      4,
      5,
      3,
      3,
      0,
      4
      // Left
    ];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    const posTexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posTexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posTex), gl.STATIC_DRAW);
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, posTexBuffer);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);
    gl.bindVertexArray(null);
    const obj3D = new NiivueObject3D(id, posTexBuffer, gl.TRIANGLES, indices.length, indexBuffer, vao);
    const extents = getExtents([...LPS, ...RPS, ...RAS, ...LAS, ...LPI, ...LAI, ...RAI, ...RPI]);
    obj3D.extentsMin = extents.min.slice();
    obj3D.extentsMax = extents.max.slice();
    obj3D.furthestVertexFromOrigin = extents.furthestVertexFromOrigin;
    obj3D.originNegate = vec3_exports.clone(extents.origin);
    vec3_exports.negate(obj3D.originNegate, obj3D.originNegate);
    obj3D.fieldOfViewDeObliqueMM = [dimsRAS[1] * pixDimsRAS[1], dimsRAS[2] * pixDimsRAS[2], dimsRAS[3] * pixDimsRAS[3]];
    return obj3D;
  }
  /**
   * Update options for image
   */
  applyOptionsUpdate(options) {
    this.hdr.cal_min = options.cal_min;
    this.hdr.cal_max = options.cal_max;
    Object.assign(this, options);
  }
  getImageOptions() {
    const options = NVImageFromUrlOptions(
      "",
      // url,
      "",
      // urlImageData
      this.name,
      // name
      this._colormap,
      // colormap
      this.opacity,
      // opacity
      this.hdr.cal_min,
      // cal_min
      this.hdr.cal_max,
      // cal_max
      this.trustCalMinMax,
      // trustCalMinMax,
      this.percentileFrac,
      // percentileFrac
      this.ignoreZeroVoxels,
      // ignoreZeroVoxels
      this.useQFormNotSForm,
      // useQFormNotSForm
      this.colormapNegative,
      // colormapNegative
      this.frame4D,
      this.imageType,
      // imageType
      this.colormapType
    );
    return options;
  }
  /**
   * Converts NVImage to NIfTI compliant byte array
   */
  toUint8Array(drawingBytes = null) {
    const isDrawing = drawingBytes !== null;
    const hdrBytes = hdrToArrayBuffer({ ...this.hdr, vox_offset: 352 }, isDrawing);
    let drawingBytesToBeConverted = drawingBytes;
    if (isDrawing) {
      const perm = this.permRAS;
      if (perm[0] !== 1 || perm[1] !== 2 || perm[2] !== 3) {
        const dims = this.hdr.dims;
        const layout = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          for (let j2 = 0; j2 < 3; j2++) {
            if (Math.abs(perm[i]) - 1 !== j2) {
              continue;
            }
            layout[j2] = i * Math.sign(perm[i]);
          }
        }
        let stride = 1;
        const instride = [1, 1, 1];
        const inflip = [false, false, false];
        for (let i = 0; i < layout.length; i++) {
          for (let j2 = 0; j2 < layout.length; j2++) {
            const a = Math.abs(layout[j2]);
            if (a !== i) {
              continue;
            }
            instride[j2] = stride;
            if (layout[j2] < 0 || Object.is(layout[j2], -0)) {
              inflip[j2] = true;
            }
            stride *= dims[j2 + 1];
          }
        }
        let xlut = NVUtilities.range(0, dims[1] - 1, 1);
        if (inflip[0]) {
          xlut = NVUtilities.range(dims[1] - 1, 0, -1);
        }
        for (let i = 0; i < dims[1]; i++) {
          xlut[i] *= instride[0];
        }
        let ylut = NVUtilities.range(0, dims[2] - 1, 1);
        if (inflip[1]) {
          ylut = NVUtilities.range(dims[2] - 1, 0, -1);
        }
        for (let i = 0; i < dims[2]; i++) {
          ylut[i] *= instride[1];
        }
        let zlut = NVUtilities.range(0, dims[3] - 1, 1);
        if (inflip[2]) {
          zlut = NVUtilities.range(dims[3] - 1, 0, -1);
        }
        for (let i = 0; i < dims[3]; i++) {
          zlut[i] *= instride[2];
        }
        const inVs = new Uint8Array(drawingBytes);
        const outVs = new Uint8Array(dims[1] * dims[2] * dims[3]);
        let j = 0;
        for (let z = 0; z < dims[3]; z++) {
          for (let y = 0; y < dims[2]; y++) {
            for (let x = 0; x < dims[1]; x++) {
              outVs[j] = inVs[xlut[x] + ylut[y] + zlut[z]];
              j++;
            }
          }
        }
        drawingBytesToBeConverted = outVs;
        log.debug("drawing bytes");
        log.debug(drawingBytesToBeConverted);
      }
    }
    const img8 = isDrawing ? drawingBytesToBeConverted : new Uint8Array(this.img.buffer);
    const opad = new Uint8Array(4);
    const odata = new Uint8Array(hdrBytes.length + opad.length + img8.length);
    odata.set(hdrBytes);
    odata.set(opad, hdrBytes.length);
    odata.set(img8, hdrBytes.length + opad.length);
    return odata;
  }
  // not included in public docs
  convertVox2Frac(vox) {
    const frac = vec3_exports.fromValues(
      (vox[0] + 0.5) / this.dimsRAS[1],
      (vox[1] + 0.5) / this.dimsRAS[2],
      (vox[2] + 0.5) / this.dimsRAS[3]
    );
    return frac;
  }
  // not included in public docs
  convertFrac2Vox(frac) {
    const vox = vec3_exports.fromValues(
      Math.round(frac[0] * this.dims[1] - 0.5),
      // dims === RAS
      Math.round(frac[1] * this.dims[2] - 0.5),
      // dims === RAS
      Math.round(frac[2] * this.dims[3] - 0.5)
      // dims === RAS
    );
    return vox;
  }
  // not included in public docs
  convertFrac2MM(frac, isForceSliceMM = false) {
    const pos = vec4_exports.fromValues(frac[0], frac[1], frac[2], 1);
    if (isForceSliceMM) {
      vec4_exports.transformMat4(pos, pos, this.frac2mm);
    } else {
      vec4_exports.transformMat4(pos, pos, this.frac2mmOrtho);
    }
    return pos;
  }
  // not included in public docs
  convertMM2Frac(mm, isForceSliceMM = false) {
    const mm4 = vec4_exports.fromValues(mm[0], mm[1], mm[2], 1);
    const d = this.dimsRAS;
    const frac = vec3_exports.fromValues(0, 0, 0);
    if (typeof d === "undefined") {
      return frac;
    }
    if (!isForceSliceMM) {
      const xform = mat4_exports.clone(this.frac2mmOrtho);
      mat4_exports.invert(xform, xform);
      vec4_exports.transformMat4(mm4, mm4, xform);
      frac[0] = mm4[0];
      frac[1] = mm4[1];
      frac[2] = mm4[2];
      return frac;
    }
    if (d[1] < 1 || d[2] < 1 || d[3] < 1) {
      return frac;
    }
    const sform = mat4_exports.clone(this.matRAS);
    mat4_exports.invert(sform, sform);
    mat4_exports.transpose(sform, sform);
    vec4_exports.transformMat4(mm4, mm4, sform);
    frac[0] = (mm4[0] + 0.5) / d[1];
    frac[1] = (mm4[1] + 0.5) / d[2];
    frac[2] = (mm4[2] + 0.5) / d[3];
    return frac;
  }
};

// src/nvdocument.ts
var SLICE_TYPE = /* @__PURE__ */ ((SLICE_TYPE2) => {
  SLICE_TYPE2[SLICE_TYPE2["AXIAL"] = 0] = "AXIAL";
  SLICE_TYPE2[SLICE_TYPE2["CORONAL"] = 1] = "CORONAL";
  SLICE_TYPE2[SLICE_TYPE2["SAGITTAL"] = 2] = "SAGITTAL";
  SLICE_TYPE2[SLICE_TYPE2["MULTIPLANAR"] = 3] = "MULTIPLANAR";
  SLICE_TYPE2[SLICE_TYPE2["RENDER"] = 4] = "RENDER";
  return SLICE_TYPE2;
})(SLICE_TYPE || {});
var SHOW_RENDER = /* @__PURE__ */ ((SHOW_RENDER2) => {
  SHOW_RENDER2[SHOW_RENDER2["NEVER"] = 0] = "NEVER";
  SHOW_RENDER2[SHOW_RENDER2["ALWAYS"] = 1] = "ALWAYS";
  SHOW_RENDER2[SHOW_RENDER2["AUTO"] = 2] = "AUTO";
  return SHOW_RENDER2;
})(SHOW_RENDER || {});
var MULTIPLANAR_TYPE = /* @__PURE__ */ ((MULTIPLANAR_TYPE2) => {
  MULTIPLANAR_TYPE2[MULTIPLANAR_TYPE2["AUTO"] = 0] = "AUTO";
  MULTIPLANAR_TYPE2[MULTIPLANAR_TYPE2["COLUMN"] = 1] = "COLUMN";
  MULTIPLANAR_TYPE2[MULTIPLANAR_TYPE2["GRID"] = 2] = "GRID";
  MULTIPLANAR_TYPE2[MULTIPLANAR_TYPE2["ROW"] = 3] = "ROW";
  return MULTIPLANAR_TYPE2;
})(MULTIPLANAR_TYPE || {});
var DRAG_MODE = /* @__PURE__ */ ((DRAG_MODE2) => {
  DRAG_MODE2[DRAG_MODE2["none"] = 0] = "none";
  DRAG_MODE2[DRAG_MODE2["contrast"] = 1] = "contrast";
  DRAG_MODE2[DRAG_MODE2["measurement"] = 2] = "measurement";
  DRAG_MODE2[DRAG_MODE2["pan"] = 3] = "pan";
  DRAG_MODE2[DRAG_MODE2["slicer3D"] = 4] = "slicer3D";
  DRAG_MODE2[DRAG_MODE2["callbackOnly"] = 5] = "callbackOnly";
  DRAG_MODE2[DRAG_MODE2["roiSelection"] = 6] = "roiSelection";
  return DRAG_MODE2;
})(DRAG_MODE || {});
var DRAG_MODE_SECONDARY = /* @__PURE__ */ ((DRAG_MODE_SECONDARY2) => {
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["none"] = 0] = "none";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["contrast"] = 1] = "contrast";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["measurement"] = 2] = "measurement";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["pan"] = 3] = "pan";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["slicer3D"] = 4] = "slicer3D";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["callbackOnly"] = 5] = "callbackOnly";
  DRAG_MODE_SECONDARY2[DRAG_MODE_SECONDARY2["roiSelection"] = 6] = "roiSelection";
  return DRAG_MODE_SECONDARY2;
})(DRAG_MODE_SECONDARY || {});
var DRAG_MODE_PRIMARY = /* @__PURE__ */ ((DRAG_MODE_PRIMARY2) => {
  DRAG_MODE_PRIMARY2[DRAG_MODE_PRIMARY2["crosshair"] = 0] = "crosshair";
  DRAG_MODE_PRIMARY2[DRAG_MODE_PRIMARY2["windowing"] = 1] = "windowing";
  return DRAG_MODE_PRIMARY2;
})(DRAG_MODE_PRIMARY || {});
var COLORMAP_TYPE = /* @__PURE__ */ ((COLORMAP_TYPE2) => {
  COLORMAP_TYPE2[COLORMAP_TYPE2["MIN_TO_MAX"] = 0] = "MIN_TO_MAX";
  COLORMAP_TYPE2[COLORMAP_TYPE2["ZERO_TO_MAX_TRANSPARENT_BELOW_MIN"] = 1] = "ZERO_TO_MAX_TRANSPARENT_BELOW_MIN";
  COLORMAP_TYPE2[COLORMAP_TYPE2["ZERO_TO_MAX_TRANSLUCENT_BELOW_MIN"] = 2] = "ZERO_TO_MAX_TRANSLUCENT_BELOW_MIN";
  return COLORMAP_TYPE2;
})(COLORMAP_TYPE || {});
var DEFAULT_OPTIONS = {
  textHeight: 0.06,
  colorbarHeight: 0.05,
  crosshairWidth: 1,
  crosshairWidthUnit: "voxels",
  crosshairGap: 0,
  rulerWidth: 4,
  show3Dcrosshair: false,
  backColor: [0, 0, 0, 1],
  crosshairColor: [1, 0, 0, 1],
  fontColor: [0.5, 0.5, 0.5, 1],
  selectionBoxColor: [1, 1, 1, 0.5],
  clipPlaneColor: [0.7, 0, 0.7, 0.5],
  clipThick: 2,
  clipVolumeLow: [0, 0, 0],
  clipVolumeHigh: [1, 1, 1],
  rulerColor: [1, 0, 0, 0.8],
  colorbarMargin: 0.05,
  trustCalMinMax: true,
  clipPlaneHotKey: "KeyC",
  viewModeHotKey: "KeyV",
  doubleTouchTimeout: 500,
  longTouchTimeout: 1e3,
  keyDebounceTime: 50,
  isNearestInterpolation: false,
  isResizeCanvas: true,
  atlasOutline: 0,
  isRuler: false,
  isColorbar: false,
  isOrientCube: false,
  tileMargin: 0,
  multiplanarPadPixels: 0,
  // @deprecated
  multiplanarForceRender: false,
  multiplanarEqualSize: false,
  multiplanarShowRender: 2 /* AUTO */,
  // auto is the same behaviour as multiplanarForceRender: false
  isRadiologicalConvention: false,
  meshThicknessOn2D: Infinity,
  dragMode: 1 /* contrast */,
  dragModePrimary: 0 /* crosshair */,
  yoke3Dto2DZoom: false,
  isDepthPickMesh: false,
  isCornerOrientationText: false,
  heroImageFraction: 0,
  heroSliceType: 4 /* RENDER */,
  sagittalNoseLeft: false,
  isSliceMM: false,
  isV1SliceShader: false,
  forceDevicePixelRatio: 0,
  logLevel: "info",
  loadingText: "loading ...",
  isForceMouseClickToVoxelCenters: false,
  dragAndDropEnabled: true,
  drawingEnabled: false,
  penValue: 1,
  floodFillNeighbors: 6,
  isFilledPen: false,
  thumbnail: "",
  maxDrawUndoBitmaps: 8,
  sliceType: 3 /* MULTIPLANAR */,
  meshXRay: 0,
  isAntiAlias: null,
  limitFrames4D: NaN,
  isAdditiveBlend: false,
  showLegend: true,
  legendBackgroundColor: [0.3, 0.3, 0.3, 0.5],
  legendTextColor: [1, 1, 1, 1],
  multiplanarLayout: 0 /* AUTO */,
  renderOverlayBlend: 1,
  sliceMosaicString: "",
  centerMosaic: false,
  penSize: 1,
  // in voxels, since all drawing is done using bitmap indices
  interactive: true,
  clickToSegment: false,
  clickToSegmentRadius: 3,
  // in mm
  clickToSegmentBright: true,
  clickToSegmentAutoIntensity: false,
  // new option, but keep clickToSegmentBright for backwards compatibility
  clickToSegmentIntensityMax: NaN,
  // NaN will use auto threshold (default flood fill behavior from before)
  clickToSegmentIntensityMin: NaN,
  // NaN will use auto threshold (default flood fill behavior from before)
  // 0 will use auto threshold (default flood fill behavior from before)
  // Take the voxel intensity at the click point and use this percentage +/- to threshold the flood fill operation.
  // If greater than 0, clickedVoxelIntensity +/- clickedVoxelIntensity * clickToSegmentPercent will be used
  // for the clickToSegmentIntensityMin and clickToSegmentIntensityMax values.
  clickToSegmentPercent: 0,
  clickToSegmentMaxDistanceMM: Number.POSITIVE_INFINITY,
  // default value is infinity for backwards compatibility with flood fill routine.
  clickToSegmentIs2D: false,
  selectionBoxLineThickness: 4,
  selectionBoxIsOutline: false,
  scrollRequiresFocus: false,
  // determines if the cavas need to be focused to scroll
  showMeasureUnits: true,
  // e.g. 20.2 vs 20.2 mm
  measureTextJustify: "center",
  // start, center, end
  measureTextColor: [1, 0, 0, 1],
  // red
  measureLineColor: [1, 0, 0, 1],
  // red
  measureTextHeight: 0.03,
  isAlphaClipDark: false,
  gradientOrder: 1,
  gradientOpacity: 0
};
var INITIAL_SCENE_DATA = {
  gamma: 1,
  azimuth: 110,
  elevation: 10,
  crosshairPos: vec3_exports.fromValues(0.5, 0.5, 0.5),
  clipPlane: [0, 0, 0, 0],
  clipPlaneDepthAziElev: [2, 0, 0],
  volScaleMultiplier: 1,
  pan2Dxyzmm: vec4_exports.fromValues(0, 0, 0, 1),
  clipThick: 2,
  clipVolumeLow: [0, 0, 0],
  clipVolumeHigh: [1, 1, 1]
};
var NVDocument = class _NVDocument {
  constructor() {
    __publicField(this, "data", {
      title: "Untitled document",
      imageOptionsArray: [],
      meshOptionsArray: [],
      opts: { ...DEFAULT_OPTIONS },
      previewImageDataURL: "",
      labels: [],
      encodedImageBlobs: [],
      encodedDrawingBlob: ""
    });
    __publicField(this, "scene");
    __publicField(this, "volumes", []);
    __publicField(this, "meshDataObjects");
    __publicField(this, "meshes", []);
    __publicField(this, "drawBitmap", null);
    __publicField(this, "imageOptionsMap", /* @__PURE__ */ new Map());
    __publicField(this, "meshOptionsMap", /* @__PURE__ */ new Map());
    this.scene = {
      onAzimuthElevationChange: () => {
      },
      onZoom3DChange: () => {
      },
      sceneData: {
        ...INITIAL_SCENE_DATA,
        pan2Dxyzmm: vec4_exports.fromValues(0, 0, 0, 1),
        crosshairPos: vec3_exports.fromValues(0.5, 0.5, 0.5)
      },
      get renderAzimuth() {
        return this.sceneData.azimuth;
      },
      set renderAzimuth(azimuth) {
        this.sceneData.azimuth = azimuth;
        if (this.onAzimuthElevationChange) {
          this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
        }
      },
      get renderElevation() {
        return this.sceneData.elevation;
      },
      set renderElevation(elevation) {
        this.sceneData.elevation = elevation;
        if (this.onAzimuthElevationChange) {
          this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
        }
      },
      get volScaleMultiplier() {
        return this.sceneData.volScaleMultiplier;
      },
      set volScaleMultiplier(scale6) {
        this.sceneData.volScaleMultiplier = scale6;
        this.onZoom3DChange(scale6);
      },
      get crosshairPos() {
        return this.sceneData.crosshairPos;
      },
      set crosshairPos(crosshairPos) {
        this.sceneData.crosshairPos = crosshairPos;
      },
      get clipPlane() {
        return this.sceneData.clipPlane;
      },
      set clipPlane(clipPlane) {
        this.sceneData.clipPlane = clipPlane;
      },
      get clipPlaneDepthAziElev() {
        return this.sceneData.clipPlaneDepthAziElev;
      },
      set clipPlaneDepthAziElev(clipPlaneDepthAziElev) {
        this.sceneData.clipPlaneDepthAziElev = clipPlaneDepthAziElev;
      },
      get pan2Dxyzmm() {
        return this.sceneData.pan2Dxyzmm;
      },
      /**
       * Sets current 2D pan in 3D mm
       */
      set pan2Dxyzmm(pan2Dxyzmm) {
        this.sceneData.pan2Dxyzmm = pan2Dxyzmm;
      },
      get gamma() {
        return this.sceneData.gamma;
      },
      /**
       * Sets current gamma
       */
      set gamma(newGamma) {
        this.sceneData.gamma = newGamma;
      }
    };
  }
  /**
   * Title of the document
   */
  get title() {
    return this.data.title;
  }
  /**
   * Gets preview image blob
   * @returns dataURL of preview image
   */
  get previewImageDataURL() {
    return this.data.previewImageDataURL;
  }
  /**
   * Sets preview image blob
   * @param dataURL - encoded preview image
   */
  set previewImageDataURL(dataURL) {
    this.data.previewImageDataURL = dataURL;
  }
  /**
   * @param title - title of document
   */
  set title(title) {
    this.data.title = title;
  }
  get imageOptionsArray() {
    return this.data.imageOptionsArray;
  }
  /**
   * Gets the base 64 encoded blobs of associated images
   */
  get encodedImageBlobs() {
    return this.data.encodedImageBlobs;
  }
  /**
   * Gets the base 64 encoded blob of the associated drawing
   * TODO the return type was marked as string[] here, was that an error?
   */
  get encodedDrawingBlob() {
    return this.data.encodedDrawingBlob;
  }
  /**
   * Gets the options of the {@link Niivue} instance
   */
  get opts() {
    return this.data.opts;
  }
  /**
   * Sets the options of the {@link Niivue} instance
   */
  set opts(opts) {
    this.data.opts = { ...opts };
  }
  /**
   * Gets the 3D labels of the {@link Niivue} instance
   */
  get labels() {
    return this.data.labels;
  }
  /**
   * Sets the 3D labels of the {@link Niivue} instance
   */
  set labels(labels) {
    this.data.labels = labels;
  }
  get customData() {
    return this.data.customData;
  }
  set customData(data) {
    this.data.customData = data;
  }
  /**
   * Checks if document has an image by id
   */
  hasImage(image) {
    return this.volumes.find((i) => i.id === image.id) !== void 0;
  }
  /**
   * Checks if document has an image by url
   */
  hasImageFromUrl(url) {
    return this.data.imageOptionsArray.find((i) => i.url === url) !== void 0;
  }
  /**
   * Adds an image and the options an image was created with
   */
  addImageOptions(image, imageOptions) {
    if (!this.hasImage(image)) {
      if (!imageOptions.name) {
        if (imageOptions.url) {
          const absoluteUrlRE = /^(?:[a-z+]+:)?\/\//i;
          const url = absoluteUrlRE.test(imageOptions.url) ? new URL(imageOptions.url) : new URL(imageOptions.url, window.location.href);
          imageOptions.name = url.pathname.split("/").pop();
          if (imageOptions.name.toLowerCase().endsWith(".gz")) {
            imageOptions.name = imageOptions.name.slice(0, -3);
          }
          if (!imageOptions.name.toLowerCase().endsWith(".nii")) {
            imageOptions.name += ".nii";
          }
        } else {
          imageOptions.name = "untitled.nii";
        }
      }
    }
    imageOptions.imageType = NVIMAGE_TYPE.NII;
    this.data.imageOptionsArray.push(imageOptions);
    this.imageOptionsMap.set(image.id, this.data.imageOptionsArray.length - 1);
  }
  /**
   * Removes image from the document as well as its options
   */
  removeImage(image) {
    if (this.imageOptionsMap.has(image.id)) {
      const index = this.imageOptionsMap.get(image.id);
      if (this.data.imageOptionsArray.length > index) {
        this.data.imageOptionsArray.splice(index, 1);
      }
      this.imageOptionsMap.delete(image.id);
    }
    this.volumes = this.volumes.filter((i) => i.id !== image.id);
  }
  /**
   * Returns the options for the image if it was added by url
   */
  getImageOptions(image) {
    return this.imageOptionsMap.has(image.id) ? this.data.imageOptionsArray[this.imageOptionsMap.get(image.id)] : null;
  }
  /**
   * Converts NVDocument to JSON
   */
  json() {
    const data = {
      encodedImageBlobs: [],
      previewImageDataURL: this.data.previewImageDataURL,
      imageOptionsMap: /* @__PURE__ */ new Map()
    };
    const imageOptionsArray = [];
    data.sceneData = { ...this.scene.sceneData };
    data.opts = { ...this.opts };
    if (this.opts.meshThicknessOn2D === Infinity) {
      data.opts.meshThicknessOn2D = "infinity";
    }
    data.labels = [...this.data.labels];
    for (const label of data.labels) {
      delete label.onClick;
    }
    data.customData = this.customData;
    if (this.volumes.length) {
      for (let i = 0; i < this.volumes.length; i++) {
        const volume = this.volumes[i];
        let imageOptions = this.getImageOptions(volume);
        if (imageOptions === null) {
          log.warn("no options found for image, using default");
          imageOptions = {
            name: "",
            colormap: "gray",
            opacity: 1,
            pairedImgData: null,
            cal_min: NaN,
            cal_max: NaN,
            trustCalMinMax: true,
            percentileFrac: 0.02,
            ignoreZeroVoxels: false,
            useQFormNotSForm: false,
            colormapNegative: "",
            colormapLabel: null,
            imageType: NVIMAGE_TYPE.NII,
            frame4D: 0,
            limitFrames4D: NaN,
            // TODO the following were missing
            url: "",
            urlImageData: "",
            alphaThreshold: false,
            cal_minNeg: NaN,
            cal_maxNeg: NaN,
            colorbarVisible: true
          };
        } else {
          if (!("imageType" in imageOptions)) {
            imageOptions.imageType = NVIMAGE_TYPE.NII;
          }
        }
        imageOptions.colormap = volume.colormap;
        imageOptions.colormapLabel = volume.colormapLabel;
        imageOptions.opacity = volume.opacity;
        imageOptions.cal_max = volume.cal_max || NaN;
        imageOptions.cal_min = volume.cal_min || NaN;
        imageOptionsArray.push(imageOptions);
        const encodedImageBlob = NVUtilities.uint8tob64(volume.toUint8Array());
        data.encodedImageBlobs.push(encodedImageBlob);
        data.imageOptionsMap.set(volume.id, i);
      }
    }
    data.imageOptionsArray = [...imageOptionsArray];
    const meshes = [];
    data.connectomes = [];
    for (const mesh of this.meshes) {
      if (mesh.type === "connectome" /* CONNECTOME */) {
        data.connectomes.push(JSON.stringify(mesh.json()));
        continue;
      }
      const copyMesh = {
        pts: mesh.pts,
        tris: mesh.tris,
        name: mesh.name,
        rgba255: Uint8Array.from(mesh.rgba255),
        opacity: mesh.opacity,
        connectome: mesh.connectome,
        dpg: mesh.dpg,
        dps: mesh.dps,
        dpv: mesh.dpv,
        meshShaderIndex: mesh.meshShaderIndex,
        layers: mesh.layers.map((layer) => ({
          values: layer.values,
          nFrame4D: layer.nFrame4D,
          frame4D: 0,
          outlineBorder: layer.outlineBorder,
          global_min: layer.global_min,
          global_max: layer.global_max,
          cal_min: layer.cal_min,
          cal_max: layer.cal_max,
          opacity: layer.opacity,
          colormap: layer.colormap,
          colormapNegative: layer.colormapNegative,
          colormapLabel: layer.colormapLabel,
          useNegativeCmap: layer.useNegativeCmap
        })),
        hasConnectome: mesh.hasConnectome,
        edgeColormap: mesh.edgeColormap,
        edgeColormapNegative: mesh.edgeColormapNegative,
        edgeMax: mesh.edgeMax,
        edgeMin: mesh.edgeMin,
        edges: mesh.edges && Array.isArray(mesh.edges) ? [...mesh.edges] : [],
        extentsMax: mesh.extentsMax,
        extentsMin: mesh.extentsMin,
        furthestVertexFromOrigin: mesh.furthestVertexFromOrigin,
        nodeColormap: mesh.nodeColormap,
        nodeColormapNegative: mesh.nodeColormapNegative,
        nodeMaxColor: mesh.nodeMaxColor,
        nodeMinColor: mesh.nodeMinColor,
        nodeScale: mesh.nodeScale,
        legendLineThickness: mesh.legendLineThickness,
        offsetPt0: mesh.offsetPt0,
        nodes: mesh.nodes
      };
      if (mesh.offsetPt0 && mesh.offsetPt0.length > 0) {
        copyMesh.offsetPt0 = mesh.offsetPt0;
        copyMesh.fiberGroupColormap = mesh.fiberGroupColormap;
        copyMesh.fiberColor = mesh.fiberColor;
        copyMesh.fiberDither = mesh.fiberDither;
        copyMesh.fiberRadius = mesh.fiberRadius;
        copyMesh.colormap = mesh.colormap;
      }
      meshes.push(copyMesh);
    }
    data.meshesString = JSON.stringify(serialize(meshes));
    if (this.drawBitmap) {
      data.encodedDrawingBlob = NVUtilities.uint8tob64(this.drawBitmap);
    }
    return data;
  }
  /**
   * Downloads a JSON file with options, scene, images, meshes and drawing of {@link Niivue} instance
   */
  async download(fileName, compress) {
    const data = this.json();
    const dataText = JSON.stringify(data);
    const contentType = compress ? "application/gzip" : "application/json";
    let content;
    if (compress) {
      content = await NVUtilities.compressStringToArrayBuffer(dataText);
    } else {
      content = dataText;
    }
    NVUtilities.download(content, fileName, contentType);
  }
  /**
   * Deserialize mesh data objects
   */
  static deserializeMeshDataObjects(document2) {
    if (document2.data.meshesString) {
      document2.meshDataObjects = deserialize(JSON.parse(document2.data.meshesString));
      for (const mesh of document2.meshDataObjects) {
        for (const layer of mesh.layers) {
          if ("colorMap" in layer) {
            layer.colormap = layer.colorMap;
            delete layer.colorMap;
          }
          if ("colorMapNegative" in layer) {
            layer.colormapNegative = layer.colorMapNegative;
            delete layer.colorMapNegative;
          }
        }
      }
    }
  }
  /**
   * Factory method to return an instance of NVDocument from a URL
   */
  static async loadFromUrl(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    let documentData;
    if (NVUtilities.isArrayBufferCompressed(buffer)) {
      const documentText = await NVUtilities.decompressArrayBuffer(buffer);
      documentData = JSON.parse(documentText);
    } else {
      const utf8decoder = new TextDecoder();
      documentData = JSON.parse(utf8decoder.decode(buffer));
    }
    return _NVDocument.loadFromJSON(documentData);
  }
  /**
   * Factory method to return an instance of NVDocument from a File object
   */
  static async loadFromFile(file) {
    const arrayBuffer = await NVUtilities.readFileAsync(file);
    let dataString;
    const document2 = new _NVDocument();
    if (NVUtilities.isArrayBufferCompressed(arrayBuffer)) {
      dataString = await NVUtilities.decompressArrayBuffer(arrayBuffer);
    } else {
      const utf8decoder = new TextDecoder();
      dataString = utf8decoder.decode(arrayBuffer);
    }
    document2.data = JSON.parse(dataString);
    if (document2.data.opts.meshThicknessOn2D === "infinity") {
      document2.data.opts.meshThicknessOn2D = Infinity;
    }
    document2.scene.sceneData = { ...INITIAL_SCENE_DATA, ...document2.data.sceneData };
    _NVDocument.deserializeMeshDataObjects(document2);
    return document2;
  }
  /**
   * Factory method to return an instance of NVDocument from JSON
   */
  static loadFromJSON(data) {
    const document2 = new _NVDocument();
    document2.data = data;
    if (document2.data.opts.meshThicknessOn2D === "infinity") {
      document2.data.opts.meshThicknessOn2D = Infinity;
    }
    document2.scene.sceneData = { ...INITIAL_SCENE_DATA, ...data.sceneData };
    _NVDocument.deserializeMeshDataObjects(document2);
    return document2;
  }
};

// src/nvmesh.ts
var NVMeshLayerDefaults = {
  colormap: "gray",
  opacity: 0,
  nFrame4D: 0,
  frame4D: 0,
  outlineBorder: 0,
  cal_min: 0,
  cal_max: 0,
  cal_minNeg: 0,
  cal_maxNeg: 0,
  colormapType: 0 /* MIN_TO_MAX */,
  values: new Array()
};
var NVMeshFromUrlOptions = class {
  constructor(url = "", gl = null, name = "", opacity = 1, rgba255 = new Uint8Array([255, 255, 255, 255]), visible = true, layers = [], colorbarVisible = true) {
    __publicField(this, "url");
    __publicField(this, "gl");
    __publicField(this, "name");
    __publicField(this, "opacity");
    __publicField(this, "rgba255");
    __publicField(this, "visible");
    __publicField(this, "layers");
    __publicField(this, "colorbarVisible");
    this.url = url;
    this.gl = gl;
    this.name = name;
    this.opacity = opacity;
    this.rgba255 = rgba255;
    this.visible = visible;
    this.layers = layers;
    this.colorbarVisible = colorbarVisible;
  }
};
var NVMesh3 = class _NVMesh {
  /**
   * @param pts - a 3xN array of vertex positions (X,Y,Z coordinates).
   * @param tris - a 3xN array of triangle indices (I,J,K; indexed from zero). Each triangle generated from three vertices.
   * @param name - a name for this image. Default is an empty string
   * @param rgba255 - the base color of the mesh. RGBA values from 0 to 255. Default is white
   * @param opacity - the opacity for this mesh. default is 1
   * @param visible - whether or not this image is to be visible
   * @param gl - WebGL rendering context
   * @param connectome - specify connectome edges and nodes. Default is null (not a connectome).
   * @param dpg - Data per group for tractography, see TRK format. Default is null (not tractograpgy)
   * @param dps - Data per streamline for tractography, see TRK format.  Default is null (not tractograpgy)
   * @param dpv - Data per vertex for tractography, see TRK format.  Default is null (not tractograpgy)
   * @param colorbarVisible - does this mesh display a colorbar
   * @param anatomicalStructurePrimary - region for mesh. Default is an empty string
   */
  constructor(pts, tris, name = "", rgba255 = new Uint8Array([255, 255, 255, 255]), opacity = 1, visible = true, gl, connectome = null, dpg = null, dps = null, dpv = null, colorbarVisible = true, anatomicalStructurePrimary = "") {
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "anatomicalStructurePrimary");
    __publicField(this, "colorbarVisible");
    __publicField(this, "furthestVertexFromOrigin");
    __publicField(this, "extentsMin");
    __publicField(this, "extentsMax");
    __publicField(this, "opacity");
    __publicField(this, "visible");
    __publicField(this, "meshShaderIndex", 0);
    __publicField(this, "offsetPt0", null);
    __publicField(this, "colormapInvert", false);
    __publicField(this, "fiberGroupColormap", null);
    __publicField(this, "indexBuffer");
    __publicField(this, "vertexBuffer");
    __publicField(this, "vao");
    __publicField(this, "vaoFiber");
    __publicField(this, "pts");
    __publicField(this, "tris");
    __publicField(this, "layers");
    __publicField(this, "type", "mesh" /* MESH */);
    __publicField(this, "data_type");
    __publicField(this, "rgba255");
    __publicField(this, "fiberLength");
    __publicField(this, "fiberLengths");
    __publicField(this, "fiberDensity");
    __publicField(this, "fiberDither", 0.1);
    __publicField(this, "fiberColor", "Global");
    __publicField(this, "fiberDecimationStride", 1);
    // e.g. if 2 the 50% of streamlines visible, if 3 then 1/3rd
    __publicField(this, "fiberSides", 5);
    // 1=streamline, 2=imposter, >2=mesh(cylinder with fiberSides sides)
    __publicField(this, "fiberRadius", 0);
    // in mm, e.g. 3 means 6mm diameter fibers, ignored if fiberSides < 3
    __publicField(this, "fiberOcclusion", 0);
    // value 0..1 to simulate ambient occlusion
    __publicField(this, "f32PerVertex", 5);
    // MUST be 5 or 7: number of float32s per vertex DEPRECATED, future releases will ALWAYS be 5
    __publicField(this, "fiberMask");
    __publicField(this, "colormap");
    __publicField(this, "dpg");
    __publicField(this, "dps");
    __publicField(this, "dpv");
    __publicField(this, "hasConnectome", false);
    __publicField(this, "connectome");
    // TODO this should somehow get aligned with connectome
    __publicField(this, "indexCount");
    __publicField(this, "vertexCount", 1);
    __publicField(this, "nodeScale", 4);
    __publicField(this, "edgeScale", 1);
    __publicField(this, "legendLineThickness", 0);
    __publicField(this, "nodeColormap", "warm");
    __publicField(this, "edgeColormap", "warm");
    __publicField(this, "nodeColormapNegative");
    __publicField(this, "edgeColormapNegative");
    __publicField(this, "nodeMinColor");
    __publicField(this, "nodeMaxColor");
    __publicField(this, "edgeMin");
    __publicField(this, "edgeMax");
    __publicField(this, "nodes");
    __publicField(this, "edges");
    __publicField(this, "points");
    this.anatomicalStructurePrimary = anatomicalStructurePrimary;
    this.name = name;
    this.colorbarVisible = colorbarVisible;
    this.id = v4();
    const obj = NVMeshUtilities.getExtents(pts);
    this.furthestVertexFromOrigin = obj.mxDx;
    this.extentsMin = obj.extentsMin;
    this.extentsMax = obj.extentsMax;
    this.opacity = opacity > 1 ? 1 : opacity;
    this.visible = visible;
    this.meshShaderIndex = 0;
    this.indexBuffer = gl.createBuffer();
    this.vertexBuffer = gl.createBuffer();
    this.vao = gl.createVertexArray();
    gl.bindVertexArray(this.vao);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    const f32PerVertex = this.f32PerVertex;
    if (f32PerVertex !== 7) {
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 20, 0);
      gl.vertexAttribPointer(1, 4, gl.BYTE, true, 20, 12);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 4, gl.UNSIGNED_BYTE, true, 20, 16);
    } else {
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 28, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 28, 12);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 4, gl.UNSIGNED_BYTE, true, 28, 24);
    }
    gl.bindVertexArray(null);
    this.vaoFiber = gl.createVertexArray();
    this.offsetPt0 = null;
    this.hasConnectome = false;
    this.colormapInvert = false;
    this.fiberGroupColormap = null;
    this.pts = pts;
    this.layers = [];
    this.type = "mesh" /* MESH */;
    this.tris = tris;
    if (rgba255[3] < 1) {
      this.rgba255 = rgba255;
      this.fiberLength = 2;
      this.fiberDither = 0.1;
      this.fiberColor = "Global";
      this.fiberDecimationStride = 1;
      this.fiberMask = [];
      this.colormap = connectome;
      this.dpg = dpg;
      this.dps = dps;
      this.dpv = dpv;
      if (dpg) {
        this.initValuesArray(dpg);
      }
      if (dps) {
        this.initValuesArray(dps);
      }
      if (dpv) {
        this.initValuesArray(dpv);
      }
      this.offsetPt0 = new Uint32Array(tris);
      this.tris = new Uint32Array(0);
      this.updateFibers(gl);
      gl.bindVertexArray(this.vaoFiber);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 16, 12);
      gl.bindVertexArray(null);
      return;
    }
    if (connectome) {
      this.connectome = connectome;
      this.hasConnectome = true;
      const keysArray = Object.keys(connectome);
      for (let i = 0, len4 = keysArray.length; i < len4; i++) {
        this[keysArray[i]] = connectome[keysArray[i]];
      }
    }
    this.rgba255 = rgba255;
    this.updateMesh(gl);
  }
  initValuesArray(va) {
    for (let i = 0; i < va.length; i++) {
      const mn = va[i].vals.reduce((acc, current) => Math.min(acc, current));
      const mx = va[i].vals.reduce((acc, current) => Math.max(acc, current));
      va[i].global_min = mn;
      va[i].global_max = mx;
      va[i].cal_min = mn;
      va[i].cal_max = mx;
    }
    return va;
  }
  // given streamlines (which webGL renders as a single pixel), extrude to cylinders
  linesToCylinders(gl, posClrF32, indices) {
    function v4ToV3(v42) {
      return vec3_exports.fromValues(v42[0], v42[1], v42[2]);
    }
    const primitiveRestart = Math.pow(2, 32) - 1;
    const n_count = indices.length;
    let n_line_vtx = 0;
    let n_streamlines = 0;
    for (let i = 0; i < n_count; i++) {
      if (indices[i] === primitiveRestart) {
        n_streamlines++;
        continue;
      }
      n_line_vtx++;
    }
    const cyl_sides = this.fiberSides;
    const npt = cyl_sides * n_line_vtx;
    const f32PerVertex = this.f32PerVertex;
    if (f32PerVertex !== 5) {
      throw Error("fiberSides > 1 requires f32PerVertex == 5");
    }
    const f32 = new Float32Array(npt * f32PerVertex);
    const u82 = new Uint8Array(f32.buffer);
    let vtx = 0;
    let prevV4 = vec4_exports.create();
    let currV4 = vec4_exports.create();
    let nextV4 = vec4_exports.create();
    const v1 = vec3_exports.create();
    let prevV2 = vec3_exports.create();
    let node = 0;
    const radius = this.fiberRadius;
    for (let i = 0; i < n_count; i++) {
      const isLineEnd = indices[i] === primitiveRestart;
      if (isLineEnd && node < 1) {
        continue;
      }
      let idx2 = indices[i] * 4;
      node++;
      if (node <= 1) {
        prevV4 = vec4_exports.fromValues(posClrF32[idx2 + 0], posClrF32[idx2 + 1], posClrF32[idx2 + 2], posClrF32[idx2 + 3]);
        currV4 = vec4_exports.clone(prevV4);
        if (i + 1 < n_count && indices[i + 1] !== primitiveRestart) {
          idx2 = indices[i + 1] * 4;
          nextV4 = vec4_exports.fromValues(posClrF32[idx2 + 0], posClrF32[idx2 + 1], posClrF32[idx2 + 2], posClrF32[idx2 + 3]);
          vec3_exports.subtract(v1, v4ToV3(prevV4), v4ToV3(nextV4));
          vec3_exports.normalize(v1, v1);
          prevV2 = NiivueObject3D.getFirstPerpVector(v1);
        }
        continue;
      }
      if (isLineEnd) {
        nextV4 = vec4_exports.clone(currV4);
      } else {
        nextV4 = vec4_exports.fromValues(posClrF32[idx2 + 0], posClrF32[idx2 + 1], posClrF32[idx2 + 2], posClrF32[idx2 + 3]);
      }
      vec3_exports.subtract(v1, v4ToV3(prevV4), v4ToV3(nextV4));
      vec3_exports.normalize(v1, v1);
      const D = vec3_exports.create();
      vec3_exports.cross(D, prevV2, v1);
      const v2 = vec3_exports.create();
      vec3_exports.cross(v2, v1, D);
      prevV2 = vec3_exports.clone(prevV2);
      const v3 = vec3_exports.create();
      vec3_exports.cross(v3, v1, v2);
      vec3_exports.normalize(v3, v3);
      const vtxXYZ = vec3_exports.create();
      for (let j = 0; j < cyl_sides; j++) {
        const c = Math.cos(j / cyl_sides * 2 * Math.PI);
        const s = Math.sin(j / cyl_sides * 2 * Math.PI);
        vtxXYZ[0] = radius * (c * v2[0] + s * v3[0]);
        vtxXYZ[1] = radius * (c * v2[1] + s * v3[1]);
        vtxXYZ[2] = radius * (c * v2[2] + s * v3[2]);
        vec3_exports.add(vtxXYZ, v4ToV3(currV4), vtxXYZ);
        const fidx = vtx * f32PerVertex;
        f32[fidx + 0] = vtxXYZ[0];
        f32[fidx + 1] = vtxXYZ[1];
        f32[fidx + 2] = vtxXYZ[2];
        const n3 = vec3_exports.create();
        vec3_exports.subtract(n3, vtxXYZ, v4ToV3(currV4));
        vec3_exports.normalize(n3, n3);
        const fidxU8 = (fidx + 3) * 4;
        u82[fidxU8 + 0] = n3[0] * 127;
        u82[fidxU8 + 1] = n3[1] * 127;
        u82[fidxU8 + 2] = n3[2] * 127;
        f32[fidx + 4] = currV4[3];
        vtx++;
      }
      prevV4 = vec4_exports.clone(currV4);
      currV4 = vec4_exports.clone(nextV4);
      if (isLineEnd) {
        node = 0;
      }
    }
    const nidx = (n_line_vtx - n_streamlines) * cyl_sides * 2 * 3;
    const idxs = new Uint32Array(nidx);
    let idx = 0;
    vtx = 0;
    for (let i = 1; i < n_count; i++) {
      if (indices[i] === primitiveRestart) {
        vtx += cyl_sides;
        continue;
      }
      if (indices[i - 1] === primitiveRestart) {
        continue;
      }
      let prevStartVtx = vtx;
      let startVtx = vtx + cyl_sides;
      const prevStartVtxOverflow = startVtx;
      const startVtxOverflow = startVtx + cyl_sides;
      for (let j = 0; j < cyl_sides; j++) {
        idxs[idx++] = prevStartVtx;
        idxs[idx++] = startVtx++;
        if (startVtx === startVtxOverflow) {
          startVtx = startVtxOverflow - cyl_sides;
        }
        idxs[idx++] = startVtx;
        idxs[idx++] = prevStartVtx++;
        if (prevStartVtx === prevStartVtxOverflow) {
          prevStartVtx = prevStartVtxOverflow - cyl_sides;
        }
        idxs[idx++] = startVtx;
        idxs[idx++] = prevStartVtx;
      }
      vtx += cyl_sides;
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, Uint32Array.from(idxs), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, u82, gl.STATIC_DRAW);
    this.indexCount = nidx;
  }
  // linesToCylinders
  createFiberDensityMap() {
    if (this.fiberDensity) {
      return;
    }
    const pts = this.pts;
    const npt = pts.length / 3;
    let maxExtentsRange = 0;
    for (let i = 0; i < 3; i++) {
      const range = this.extentsMax[i] - this.extentsMin[i];
      maxExtentsRange = Math.max(maxExtentsRange, range);
    }
    this.fiberDensity = new Float32Array(npt);
    if (maxExtentsRange === 0) {
      return;
    }
    const bins = 64;
    const binWidth = maxExtentsRange / (bins - 1);
    const half = binWidth / 2;
    const scale6 = (bins - 1) / maxExtentsRange;
    let densityMap = new Float32Array(bins * bins * bins);
    const mn = [this.extentsMin[0] - half, this.extentsMin[1] - half, this.extentsMin[2] - half];
    const xyz = [0, 0, 0];
    const prevVx = -1;
    const binsXbins = bins * bins;
    let j = 0;
    for (let i = 0; i < npt; i++) {
      xyz[0] = Math.round((pts[j++] - mn[0]) * scale6);
      xyz[1] = Math.round((pts[j++] - mn[1]) * scale6);
      xyz[2] = Math.round((pts[j++] - mn[2]) * scale6);
      const vx = xyz[0] + xyz[1] * bins + xyz[2] * binsXbins;
      if (vx === prevVx) {
        continue;
      }
      densityMap[vx]++;
    }
    function blur3D(vol, dim) {
      let raw = vol.slice();
      let v = -1;
      const dim1 = dim - 1;
      for (let z = 0; z < dim; z++) {
        for (let y = 0; y < dim; y++) {
          for (let x = 0; x < dim; x++) {
            v++;
            if (x < 1 || x >= dim1) {
              continue;
            }
            vol[v] = raw[v - 1] + raw[v] + raw[v] + raw[v + 1];
          }
        }
      }
      v = -1;
      raw = vol.slice();
      for (let z = 0; z < dim; z++) {
        for (let y = 0; y < dim; y++) {
          for (let x = 0; x < dim; x++) {
            v++;
            if (y < 1 || y >= dim1) {
              continue;
            }
            vol[v] = raw[v - dim] + raw[v] + raw[v] + raw[v + dim];
          }
        }
      }
      const dimXdim = dim * dim;
      v = -1;
      raw = vol.slice();
      for (let z = 0; z < dim; z++) {
        for (let y = 0; y < dim; y++) {
          for (let x = 0; x < dim; x++) {
            v++;
            if (z < 1 || z >= dim1) {
              continue;
            }
            vol[v] = raw[v - dimXdim] + raw[v] + raw[v] + raw[dimXdim];
          }
        }
      }
      return vol;
    }
    densityMap = blur3D(densityMap, bins);
    densityMap = blur3D(densityMap, bins);
    let mx = 0;
    let mn0 = Infinity;
    const binsXbinsXbins = bins * bins * bins;
    for (let i = 0; i < binsXbinsXbins; i++) {
      if (densityMap[i] <= 0) {
        continue;
      }
      mx = Math.max(mx, densityMap[i]);
      mn0 = Math.min(mn0, densityMap[i]);
    }
    if (mx <= 1 || mx <= mn0) {
      return;
    }
    j = 0;
    for (let i = 0; i < binsXbinsXbins; i++) {
      densityMap[i] = Math.max(0, densityMap[i] - mn0);
    }
    mx -= mn0;
    for (let i = 0; i < npt; i++) {
      xyz[0] = Math.round((pts[j++] - mn[0]) * scale6);
      xyz[1] = Math.round((pts[j++] - mn[1]) * scale6);
      xyz[2] = Math.round((pts[j++] - mn[2]) * scale6);
      const vx = xyz[0] + xyz[1] * bins + xyz[2] * binsXbins;
      this.fiberDensity[i] = densityMap[vx] / mx;
    }
  }
  // not included in public docs
  // internal function filters tractogram to identify which color and visibility of streamlines
  updateFibers(gl) {
    if (!this.offsetPt0 || !this.fiberLength) {
      return;
    }
    const pts = this.pts;
    const offsetPt0 = this.offsetPt0;
    const n_count = offsetPt0.length - 1;
    const npt = pts.length / 3;
    if (!this.fiberLengths) {
      this.fiberLengths = new Uint32Array(n_count);
      for (let i = 0; i < n_count; i++) {
        const vStart3 = offsetPt0[i] * 3;
        const vEnd3 = (offsetPt0[i + 1] - 1) * 3;
        let len4 = 0;
        for (let j = vStart3; j < vEnd3; j += 3) {
          const v = vec3_exports.fromValues(pts[j + 0] - pts[j + 3], pts[j + 1] - pts[j + 4], pts[j + 2] - pts[j + 5]);
          len4 += vec3_exports.len(v);
        }
        this.fiberLengths[i] = len4;
      }
    }
    const posClrF32 = new Float32Array(npt * 4);
    const posClrU32 = new Uint32Array(posClrF32.buffer);
    let i3 = 0;
    let i4 = 0;
    for (let i = 0; i < npt; i++) {
      posClrF32[i4 + 0] = pts[i3 + 0];
      posClrF32[i4 + 1] = pts[i3 + 1];
      posClrF32[i4 + 2] = pts[i3 + 2];
      i3 += 3;
      i4 += 4;
    }
    const dither = this.fiberDither;
    const ditherHalf = dither * 0.5;
    function rgb2int32(r, g, b) {
      const ditherFrac = dither * Math.random();
      const d = 255 * (ditherFrac - ditherHalf);
      r = Math.max(Math.min(r + d, 255), 0);
      g = Math.max(Math.min(g + d, 255), 0);
      b = Math.max(Math.min(b + d, 255), 0);
      return r + (g << 8) + (b << 16);
    }
    function direction2rgb(x1, y1, z1, x2, y2, z2, ditherFrac) {
      const v = vec3_exports.fromValues(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
      vec3_exports.normalize(v, v);
      const r = ditherFrac - ditherHalf;
      for (let j = 0; j < 3; j++) {
        v[j] = 255 * Math.max(Math.min(Math.abs(v[j]) + r, 1), 0);
      }
      return v[0] + (v[1] << 8) + (v[2] << 16);
    }
    const fiberColor = this.fiberColor.toLowerCase();
    let dps = null;
    let dpv = null;
    if (fiberColor.startsWith("dps") && this.dps && this.dps.length > 0) {
      const n = parseInt(fiberColor.substring(3));
      if (n < this.dps.length && this.dps[n].vals.length === n_count) {
        dps = this.dps[n].vals;
      }
    }
    if (fiberColor.startsWith("dpv") && this.dpv && this.dpv.length > 0) {
      const n = parseInt(fiberColor.substring(3));
      if (n < this.dpv.length && this.dpv[n].vals.length === npt) {
        dpv = this.dpv[n];
      }
    }
    const streamlineVisible = new Int16Array(n_count);
    if (this.dpg && this.fiberGroupColormap !== null) {
      const lut = new Uint8ClampedArray(this.dpg.length * 4);
      const groupVisible = new Array(this.dpg.length).fill(false);
      const cmap = this.fiberGroupColormap;
      if (cmap.A === void 0) {
        cmap.A = Array.from(new Uint8ClampedArray(cmap.I.length).fill(255));
      }
      for (let i = 0; i < cmap.I.length; i++) {
        let idx = cmap.I[i];
        if (idx < 0 || idx >= this.dpg.length) {
          continue;
        }
        if (cmap.A[i] < 1) {
          continue;
        }
        groupVisible[idx] = true;
        idx *= 4;
        lut[idx] = cmap.R[i];
        lut[idx + 1] = cmap.G[i];
        lut[idx + 2] = cmap.B[i];
        lut[idx + 3] = 255;
      }
      streamlineVisible.fill(-1);
      for (let i = 0; i < this.dpg.length; i++) {
        if (!groupVisible[i]) {
          continue;
        }
        for (let v = 0; v < this.dpg[i].vals.length; v++) {
          streamlineVisible[this.dpg[i].vals[v]] = i;
        }
      }
      for (let i = 0; i < n_count; i++) {
        if (streamlineVisible[i] < 0) {
          continue;
        }
        const color = streamlineVisible[i] % 256 * 4;
        const RGBA = rgb2int32(lut[color], lut[color + 1], lut[color + 2]);
        const vStart = offsetPt0[i];
        const vEnd = offsetPt0[i + 1] - 1;
        const vStart4 = vStart * 4 + 3;
        const vEnd4 = vEnd * 4 + 3;
        for (let j = vStart4; j <= vEnd4; j += 4) {
          posClrU32[j] = RGBA;
        }
      }
    } else if (dpv) {
      const lut = cmapper.colormap(this.colormap, this.colormapInvert);
      const mn = dpv.cal_min;
      const mx = dpv.cal_max;
      let v42 = 3;
      for (let i = 0; i < npt; i++) {
        let color = Math.min(Math.max((dpv.vals[i] - mn) / (mx - mn), 0), 1);
        color = Math.round(Math.max(Math.min(255, color * 255))) * 4;
        const RGBA = lut[color] + (lut[color + 1] << 8) + (lut[color + 2] << 16);
        posClrU32[v42] = RGBA;
        v42 += 4;
      }
    } else if (dps) {
      const lut = cmapper.colormap(this.colormap, this.colormapInvert);
      let mn = dps[0];
      let mx = dps[0];
      for (let i = 0; i < n_count; i++) {
        mn = Math.min(mn, dps[i]);
        mx = Math.max(mx, dps[i]);
      }
      if (mx === mn) {
        mn -= 1;
      }
      for (let i = 0; i < n_count; i++) {
        let color = (dps[i] - mn) / (mx - mn);
        color = Math.round(Math.max(Math.min(255, color * 255))) * 4;
        const RGBA = lut[color] + (lut[color + 1] << 8) + (lut[color + 2] << 16);
        const vStart = offsetPt0[i];
        const vEnd = offsetPt0[i + 1] - 1;
        const vStart4 = vStart * 4 + 3;
        const vEnd4 = vEnd * 4 + 3;
        for (let j = vStart4; j <= vEnd4; j += 4) {
          posClrU32[j] = RGBA;
        }
      }
    } else if (fiberColor.includes("fixed")) {
      if (dither === 0) {
        const RGBA = this.rgba255[0] + (this.rgba255[1] << 8) + (this.rgba255[2] << 16);
        let v42 = 3;
        for (let i = 0; i < npt; i++) {
          posClrU32[v42] = RGBA;
          v42 += 4;
        }
      } else {
        for (let i = 0; i < n_count; i++) {
          const RGBA = rgb2int32(this.rgba255[0], this.rgba255[1], this.rgba255[2]);
          const vStart = offsetPt0[i];
          const vEnd = offsetPt0[i + 1] - 1;
          const vStart4 = vStart * 4 + 3;
          const vEnd4 = vEnd * 4 + 3;
          for (let j = vStart4; j <= vEnd4; j += 4) {
            posClrU32[j] = RGBA;
          }
        }
      }
    } else if (fiberColor.includes("local")) {
      for (let i = 0; i < n_count; i++) {
        const vStart = offsetPt0[i];
        const vEnd = offsetPt0[i + 1] - 1;
        let v3 = vStart * 3;
        const vEnd3 = vEnd * 3;
        const ditherFrac = dither * Math.random();
        let RGBA = direction2rgb(pts[v3], pts[v3 + 1], pts[v3 + 2], pts[v3 + 4], pts[v3 + 5], pts[v3 + 6], ditherFrac);
        let v42 = vStart * 4 + 3;
        while (v3 < vEnd3) {
          posClrU32[v42] = RGBA;
          v42 += 4;
          v3 += 3;
          RGBA = direction2rgb(pts[v3 - 3], pts[v3 - 2], pts[v3 - 1], pts[v3 + 3], pts[v3 + 4], pts[v3 + 5], ditherFrac);
        }
        posClrU32[v42] = posClrU32[v42 - 4];
      }
    } else {
      for (let i = 0; i < n_count; i++) {
        const vStart = offsetPt0[i];
        const vEnd = offsetPt0[i + 1] - 1;
        const vStart3 = vStart * 3;
        const vEnd3 = vEnd * 3;
        const RGBA = direction2rgb(
          pts[vStart3],
          pts[vStart3 + 1],
          pts[vStart3 + 2],
          pts[vEnd3],
          pts[vEnd3 + 1],
          pts[vEnd3 + 2],
          dither * Math.random()
        );
        const vStart4 = vStart * 4 + 3;
        const vEnd4 = vEnd * 4 + 3;
        for (let j = vStart4; j <= vEnd4; j += 4) {
          posClrU32[j] = RGBA;
        }
      }
    }
    if (this.fiberOcclusion > 0) {
      let shadeRGBA = function(rgba, frac) {
        const r = frac * (rgba & 255);
        const g = frac * (rgba >> 8 & 255);
        const b = frac * (rgba >> 16 & 255);
        return r + (g << 8) + (b << 16);
      };
      this.createFiberDensityMap();
      for (let i = 0; i < n_count; i++) {
        const vStart = offsetPt0[i];
        const vEnd = offsetPt0[i + 1] - 1;
        const vStart4 = vStart * 4 + 3;
        const vEnd4 = vEnd * 4 + 3;
        let vtx = vStart;
        const bias = Math.min(this.fiberOcclusion, 0.99);
        for (let j = vStart4; j <= vEnd4; j += 4) {
          let shade = this.fiberDensity[vtx++];
          if (shade <= 0) {
            continue;
          }
          shade = shade / ((1 / bias - 2) * (1 - shade) + 1);
          const frac = 1 - Math.min(shade, 0.9);
          let RGBA = posClrU32[j];
          RGBA = shadeRGBA(RGBA, frac);
          posClrU32[j] = RGBA;
        }
      }
    }
    const min_mm = this.fiberLength;
    const primitiveRestart = Math.pow(2, 32) - 1;
    const indices = [];
    let stride = -1;
    for (let i = 0; i < n_count; i++) {
      if (streamlineVisible[i] < 0) {
        continue;
      }
      if (this.fiberLengths[i] < min_mm) {
        continue;
      }
      stride++;
      if (stride % this.fiberDecimationStride !== 0) {
        continue;
      }
      for (let j = offsetPt0[i]; j < offsetPt0[i + 1]; j++) {
        indices.push(j);
      }
      indices.push(primitiveRestart);
    }
    if (this.fiberSides > 2 && this.fiberRadius > 0) {
      this.linesToCylinders(gl, posClrF32, indices);
    } else {
      this.indexCount = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, Uint32Array.from(posClrU32), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, Uint32Array.from(indices), gl.STATIC_DRAW);
    }
  }
  // updateFibers()
  // given X,Y,Z coordinates in world space, return index of nearest vertex as well as
  // the distance of this closest vertex to the coordinates
  indexNearestXYZmm(Xmm, Ymm, Zmm) {
    const pts = this.pts;
    const nvtx = this.pts.length / 3;
    let i = 0;
    let mnDx = Infinity;
    let mnIdx = 0;
    for (let j = 0; j < nvtx; j++) {
      const dx = Math.pow(pts[i] - Xmm, 2) + Math.pow(pts[i + 1] - Ymm, 2) + Math.pow(pts[i + 2] - Zmm, 2);
      if (dx < mnDx) {
        mnDx = dx;
        mnIdx = j;
      }
      i += 3;
    }
    mnDx = Math.sqrt(mnDx);
    return [mnIdx, mnDx];
  }
  // indexNearestXYZmm()
  // internal function discards GPU resources
  unloadMesh(gl) {
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.indexBuffer);
    gl.deleteVertexArray(this.vao);
    gl.deleteVertexArray(this.vaoFiber);
    this.offsetPt0 = null;
    this.tris = null;
    this.pts = null;
    if (this.layers && this.layers.length > 0) {
      for (let i = 0; i < this.layers.length; i++) {
        this.layers[i].values = null;
      }
    }
    if (this.dpg && this.dpg.length > 0) {
      for (let i = 0; i < this.dpg.length; i++) {
        this.dpg[i].vals = null;
      }
    }
    if (this.dps && this.dps.length > 0) {
      for (let i = 0; i < this.dps.length; i++) {
        this.dps[i].vals = null;
      }
    }
  }
  blendColormap(u82, additiveRGBA, layer, mn, mx, lut, invert3 = false) {
    const nvtx = this.pts.length / 3;
    const opacity = Math.min(layer.opacity, 1);
    function lerp4(x, y, a) {
      return x * (1 - a) + y * a;
    }
    function additiveBlend(x, y) {
      return Math.min(x + y, 255);
    }
    const scaleFlip = invert3 ? -1 : 1;
    const frame = Math.min(Math.max(layer.frame4D, 0), layer.nFrame4D - 1);
    const frameOffset = nvtx * frame;
    let mnCal = mn;
    if (!layer.isTransparentBelowCalMin) {
      mnCal = Number.NEGATIVE_INFINITY;
    }
    if (layer.colormapType !== 0 /* MIN_TO_MAX */) {
      mn = Math.min(mn, 0);
    }
    const scale255 = 255 / (mx - mn);
    let borders = new Array(nvtx).fill(false);
    if (layer.outlineBorder !== 0) {
      const v255s = new Uint8Array(nvtx).fill(0);
      for (let j = 0; j < nvtx; j++) {
        const v = scaleFlip * layer.values[j + frameOffset];
        if (v >= mnCal) {
          v255s[j] = 1;
        }
      }
      borders = NVMeshUtilities.getClusterBoundaryU8(v255s, this.tris);
      for (let j = 0; j < nvtx; j++) {
        const v = scaleFlip * layer.values[j + frameOffset];
        if (v < mnCal) {
          borders[j] = false;
        }
      }
    }
    const alphas = new Float32Array(256).fill(opacity);
    if (mnCal > mn && layer.colormapType === 2 /* ZERO_TO_MAX_TRANSLUCENT_BELOW_MIN */) {
      let minOpaque = Math.round((mnCal - mn) * scale255);
      minOpaque = Math.max(minOpaque, 1);
      for (let j = 1; j < minOpaque; j++) {
        alphas[j] = opacity * Math.pow(j / minOpaque, 2);
      }
      alphas[0] = 0;
      mnCal = mn + Number.EPSILON;
    }
    for (let j = 0; j < nvtx; j++) {
      const v = scaleFlip * layer.values[j + frameOffset];
      if (v < mnCal) {
        continue;
      }
      let v255 = Math.round((v - mn) * scale255);
      if (v255 < 0 && layer.isTransparentBelowCalMin) {
        continue;
      }
      v255 = Math.max(0, v255);
      v255 = Math.min(255, v255);
      let opa = alphas[v255];
      v255 *= 4;
      let vtx = j * 28 + 24;
      if (this.f32PerVertex !== 7) {
        vtx = j * 20 + 16;
      }
      if (layer.isAdditiveBlend) {
        const j4 = j * 4;
        additiveRGBA[j4 + 0] = additiveBlend(additiveRGBA[j4 + 0], lut[v255 + 0]);
        additiveRGBA[j4 + 1] = additiveBlend(additiveRGBA[j4 + 1], lut[v255 + 1]);
        additiveRGBA[j4 + 2] = additiveBlend(additiveRGBA[j4 + 2], lut[v255 + 2]);
        additiveRGBA[j4 + 3] = additiveBlend(additiveRGBA[j4 + 3], 255);
      } else {
        if (borders[j]) {
          opa = layer.outlineBorder;
          if (layer.outlineBorder < 0) {
            u82[vtx + 0] = 0;
            u82[vtx + 1] = 0;
            u82[vtx + 2] = 0;
            continue;
          }
        }
        u82[vtx + 0] = lerp4(u82[vtx + 0], lut[v255 + 0], opa);
        u82[vtx + 1] = lerp4(u82[vtx + 1], lut[v255 + 1], opa);
        u82[vtx + 2] = lerp4(u82[vtx + 2], lut[v255 + 2], opa);
      }
    }
  }
  // blendColormap()
  // internal function filters mesh to identify which color of triangulated mesh vertices
  updateMesh(gl) {
    if (this.offsetPt0) {
      this.updateFibers(gl);
      return;
    }
    if (this.hasConnectome) {
      return;
    }
    if (!this.pts || !this.tris || !this.rgba255) {
      log.warn("underspecified mesh");
      return;
    }
    function lerp4(x, y, a) {
      return x * (1 - a) + y * a;
    }
    const posNormClr = this.generatePosNormClr(this.pts, this.tris, this.rgba255);
    const nvtx = this.pts.length / 3;
    const u82 = new Uint8Array(posNormClr.buffer);
    const maxAdditiveBlend = 0;
    const additiveRGBA = new Uint8Array(nvtx * 4);
    if (this.layers && this.layers.length > 0) {
      for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        const opacity = layer.opacity;
        if (opacity <= 0 || layer.cal_min > layer.cal_max) {
          continue;
        }
        if (layer.outlineBorder === void 0) {
          layer.outlineBorder = 0;
        }
        if (layer.isAdditiveBlend === void 0) {
          layer.isAdditiveBlend = false;
        }
        if (layer.colormapLabel && layer.colormapLabel.R && !layer.colormapLabel.lut) {
          layer.colormapLabel = cmapper.makeLabelLut(layer.colormapLabel);
        }
        if (layer.colormapLabel && layer.colormapLabel.lut) {
          const colormapLabel = layer.colormapLabel;
          const lut2 = colormapLabel.lut;
          const nLabel = Math.floor(lut2.length / 4);
          const frame = Math.min(Math.max(layer.frame4D, 0), layer.nFrame4D - 1);
          const frameOffset = nvtx * frame;
          const rgba8 = new Uint8Array(nvtx * 4);
          let k = 0;
          for (let j = 0; j < layer.values.length; j++) {
            let idx = 4 * Math.min(Math.max(layer.values[j + frameOffset], 0), nLabel - 1);
            rgba8[k + 0] = lut2[idx + 0];
            rgba8[k + 1] = lut2[idx + 1];
            rgba8[k + 2] = lut2[idx + 2];
            k += 4;
          }
          let opaque = new Array(nvtx).fill(false);
          if (layer.outlineBorder !== 0) {
            opaque = NVMeshUtilities.getClusterBoundary(rgba8, this.tris);
          }
          k = 0;
          for (let j = 0; j < layer.values.length; j++) {
            let vtx = j * 28 + 24;
            if (this.f32PerVertex !== 7) {
              vtx = j * 20 + 16;
            }
            let opa = opacity;
            if (opaque[j]) {
              opa = layer.outlineBorder;
              if (layer.outlineBorder < 0) {
                u82[vtx + 0] = 0;
                u82[vtx + 1] = 0;
                u82[vtx + 2] = 0;
                k += 4;
                continue;
              }
            }
            u82[vtx + 0] = lerp4(u82[vtx + 0], rgba8[k + 0], opa);
            u82[vtx + 1] = lerp4(u82[vtx + 1], rgba8[k + 1], opa);
            u82[vtx + 2] = lerp4(u82[vtx + 2], rgba8[k + 2], opa);
            k += 4;
          }
          continue;
        }
        if (layer.values instanceof Uint8Array) {
          const rgba8 = new Uint8Array(layer.values.buffer);
          let opaque = new Array(nvtx).fill(true);
          if (layer.outlineBorder !== 0) {
            opaque = NVMeshUtilities.getClusterBoundary(rgba8, this.tris);
          }
          let k = 0;
          for (let j = 0; j < layer.values.length; j++) {
            let vtx = j * 28 + 24;
            if (this.f32PerVertex !== 7) {
              vtx = j * 20 + 16;
            }
            let opa = opacity;
            if (opaque[j]) {
              opa = layer.outlineBorder;
              if (layer.outlineBorder < 0) {
                u82[vtx + 0] = 0;
                u82[vtx + 1] = 0;
                u82[vtx + 2] = 0;
                k += 4;
                continue;
              }
            }
            u82[vtx + 0] = lerp4(u82[vtx + 0], rgba8[k + 0], opa);
            u82[vtx + 1] = lerp4(u82[vtx + 1], rgba8[k + 1], opa);
            u82[vtx + 2] = lerp4(u82[vtx + 2], rgba8[k + 2], opa);
            k += 4;
          }
          continue;
        }
        if (layer.useNegativeCmap) {
          layer.cal_min = Math.max(Number.EPSILON, layer.cal_min);
          layer.cal_max = Math.max(layer.cal_min + 1e-6, layer.cal_max);
        }
        if (layer.isTransparentBelowCalMin === void 0) {
          layer.isTransparentBelowCalMin = true;
        }
        const lut = cmapper.colormap(layer.colormap, layer.colormapInvert);
        this.blendColormap(u82, additiveRGBA, layer, layer.cal_min, layer.cal_max, lut);
        if (layer.useNegativeCmap) {
          const neglut = cmapper.colormap(layer.colormapNegative, layer.colormapInvert);
          let mn = layer.cal_min;
          let mx = layer.cal_max;
          if (isFinite(layer.cal_minNeg) && isFinite(layer.cal_minNeg)) {
            mn = -layer.cal_minNeg;
            mx = -layer.cal_maxNeg;
          }
          this.blendColormap(u82, additiveRGBA, layer, mn, mx, neglut, true);
        }
      }
    }
    if (maxAdditiveBlend > 0) {
      for (let j = 0; j < nvtx; j++) {
        let modulate = function(x, y) {
          return Math.min(x * y * (1 / 255), 255);
        };
        let vtx = j * 28 + 24;
        if (this.f32PerVertex !== 7) {
          vtx = j * 20 + 16;
        }
        const v = j * 4;
        const opacity = Math.min(maxAdditiveBlend, additiveRGBA[v + 3] / 255);
        if (opacity <= 0) {
          continue;
        }
        u82[vtx + 0] = modulate(u82[vtx + 0], additiveRGBA[v + 0]);
        u82[vtx + 1] = modulate(u82[vtx + 1], additiveRGBA[v + 1]);
        u82[vtx + 2] = modulate(u82[vtx + 2], additiveRGBA[v + 2]);
        u82[vtx + 0] = lerp4(u82[vtx + 0], additiveRGBA[v + 0], opacity);
        u82[vtx + 1] = lerp4(u82[vtx + 1], additiveRGBA[v + 1], opacity);
        u82[vtx + 2] = lerp4(u82[vtx + 2], additiveRGBA[v + 2], opacity);
      }
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, Uint32Array.from(this.tris), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, u82, gl.STATIC_DRAW);
    this.indexCount = this.tris.length;
    this.vertexCount = this.pts.length;
  }
  // updateMesh()
  // internal function filters mesh to identify which color of triangulated mesh vertices
  reverseFaces(gl) {
    if (this.offsetPt0) {
      return;
    }
    if (this.hasConnectome) {
      return;
    }
    const tris = this.tris || [];
    for (let j = 0; j < tris.length; j += 3) {
      const tri = tris[j];
      tris[j] = tris[j + 1];
      tris[j + 1] = tri;
    }
    this.updateMesh(gl);
  }
  hierarchicalOrder() {
    const V0 = 12;
    const F0 = 20;
    const nF = this.tris.length / 3;
    const order = Math.log(nF / F0) / Math.log(4);
    if (nF !== Math.pow(4, order) * F0) {
      return NaN;
    }
    const nV = this.pts.length / 3;
    if (nV !== Math.pow(4, order) * (V0 - 2) + 2) {
      return NaN;
    }
    for (let i = 0; i < 15; i += 3) {
      if (this.tris[i] !== 0) {
        return NaN;
      }
    }
    for (let i = 15; i < 24; i += 3) {
      if (this.tris[i] !== 3) {
        return NaN;
      }
    }
    for (let i = 24; i < 30; i += 3) {
      if (this.tris[i] !== 4) {
        return NaN;
      }
    }
    return order;
  }
  decimateFaces(n, ntarget) {
    let fac = this.tris;
    const V0 = 12;
    const F0 = 20;
    for (let j = n - 1; j >= ntarget; j--) {
      const nVjprev = Math.pow(4, j + 1) * (V0 - 2) + 2;
      const nVj = Math.pow(4, j) * (V0 - 2) + 2;
      const nFjprev = fac.length / 3;
      const nFj = Math.pow(4, j) * F0;
      console.log(`order ${j + 1} -> ${j} vertices ${nVjprev} -> ${nVj} faces ${nFjprev} -> ${nFj}`);
      const remap = Array.from({ length: nVjprev }, (_, i) => i + 1);
      for (let i = 0; i < nFjprev; i++) {
        const v1 = fac[3 * i];
        const v2 = fac[3 * i + 1];
        const v3 = fac[3 * i + 2];
        remap[v1 - 1] = Math.min(remap[v1 - 1], v2, v3);
      }
      const facJ = new Uint32Array(nFj * 3);
      for (let i = 0; i < nFj; i++) {
        facJ[3 * i] = remap[fac[3 * i] - 1];
        facJ[3 * i + 1] = remap[fac[3 * i + 1] - 1];
        facJ[3 * i + 2] = remap[fac[3 * i + 2] - 1];
      }
      fac = facJ;
    }
    this.tris = new Uint32Array(fac);
  }
  // internal function simplifies FreeSurfer triangulated mesh and overlays
  decimateHierarchicalMesh(gl, order = 4) {
    const inputOrder = this.hierarchicalOrder();
    if (isNaN(inputOrder)) {
      log.warn("Unable to decimate mesh: it does not have a hierarchical structure");
      return false;
    }
    if (order >= inputOrder) {
      log.warn(`Unable to decimate mesh: input order (${inputOrder}) must be larger than downsampled order (${order})`);
      return false;
    }
    const inputVLength = this.pts.length / 3;
    const V0 = 12;
    const nV = Math.pow(4, order) * (V0 - 2) + 2;
    this.pts = new Float32Array(this.pts.slice(0, nV * 3));
    this.decimateFaces(inputOrder, order);
    if (this.layers && this.layers.length > 0) {
      for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        if (layer.values instanceof Float32Array || layer.values.length !== inputVLength) {
          layer.values = new Float32Array(layer.values.slice(0, nV));
        } else {
          log.warn(`decimation logic needs to be updated`);
        }
      }
    }
    this.updateMesh(gl);
    return true;
  }
  // adjust attributes of a mesh layer. invoked by niivue.setMeshLayerProperty()
  // TODO this method is a bit too generic
  async setLayerProperty(id, key, val, gl) {
    const layer = this.layers[id];
    if (!layer || !(key in layer)) {
      log.warn("mesh does not have property ", key, " for layer ", layer);
      return;
    }
    if (key === "colormapLabel") {
      if (typeof val === "object") {
        layer[key] = cmapper.makeLabelLut(val);
      } else if (typeof val === "string") {
        const cmap = await cmapper.makeLabelLutFromUrl(val);
        layer[key] = cmap;
        this.updateMesh(gl);
        return;
      } else {
        log.error("colormapLabel requires a string or object");
      }
    } else {
      layer[key] = val;
    }
    this.updateMesh(gl);
  }
  // adjust mesh attributes. invoked by niivue.setMeshProperty(()
  // TODO this method is too generic
  setProperty(key, val, gl) {
    if (!(key in this)) {
      log.warn("mesh does not have property ", key, this);
      return;
    }
    this[key] = val;
    this.updateMesh(gl);
  }
  // Each streamline vertex has color, normal and position attributes
  // Interleaved Vertex Data https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html
  generatePosNormClr(pts, tris, rgba255) {
    if (pts.length < 3 || rgba255.length < 4) {
      log.error("Catastrophic failure generatePosNormClr()");
      log.debug("this", this);
      log.debug("pts", pts);
      log.debug("rgba", rgba255);
    }
    const norms = NVMeshUtilities.generateNormals(pts, tris);
    const npt = pts.length / 3;
    const isPerVertexColors = npt === rgba255.length / 4;
    const f32PerVertex = this.f32PerVertex;
    const f32 = new Float32Array(npt * f32PerVertex);
    const u82 = new Uint8Array(f32.buffer);
    let p = 0;
    let c = 0;
    let f = 0;
    let u = (f32PerVertex - 1) * 4;
    for (let i = 0; i < npt; i++) {
      f32[f + 0] = pts[p + 0];
      f32[f + 1] = pts[p + 1];
      f32[f + 2] = pts[p + 2];
      if (f32PerVertex !== 7) {
        u82[u - 4] = norms[p + 0] * 127;
        u82[u - 3] = norms[p + 1] * 127;
        u82[u - 2] = norms[p + 2] * 127;
      } else {
        f32[f + 3] = norms[p + 0];
        f32[f + 4] = norms[p + 1];
        f32[f + 5] = norms[p + 2];
      }
      u82[u] = rgba255[c + 0];
      u82[u + 1] = rgba255[c + 1];
      u82[u + 2] = rgba255[c + 2];
      u82[u + 3] = rgba255[c + 3];
      if (isPerVertexColors) {
        c += 4;
      }
      p += 3;
      f += f32PerVertex;
      u += f32PerVertex * 4;
    }
    return f32;
  }
  // wrapper to read meshes, tractograms and connectomes regardless of format
  static async readMesh(buffer, name, gl, opacity = 1, rgba255 = new Uint8Array([255, 255, 255, 255]), visible = true) {
    let tris = new Uint32Array([]);
    let pts = new Float32Array([]);
    let anatomicalStructurePrimary = "";
    let obj;
    const re = /(?:\.([^.]+))?$/;
    let ext = re.exec(name)[1];
    ext = ext.toUpperCase();
    if (ext === "GZ") {
      ext = re.exec(name.slice(0, -3))[1];
      ext = ext.toUpperCase();
    }
    if (ext === "JCON") {
      log.error("you should never see this message: load using nvconnectome not nvmesh");
    }
    if (ext === "JSON") {
      log.error("you should never see this message: load using nvconnectome not nvmesh");
    }
    rgba255[3] = Math.max(1, rgba255[3]);
    if (ext === "TCK" || ext === "TRK" || ext === "TT" || ext === "TRX" || ext === "TRACT") {
      if (ext === "TCK") {
        obj = NVMeshLoaders.readTCK(buffer);
      } else if (ext === "TRACT") {
        obj = NVMeshLoaders.readTRACT(buffer);
      } else if (ext === "TT") {
        obj = await NVMeshLoaders.readTT(buffer);
      } else if (ext === "TRX") {
        obj = await NVMeshLoaders.readTRX(buffer);
      } else {
        obj = await NVMeshLoaders.readTRK(buffer);
      }
      if (typeof obj === "undefined") {
        const pts2 = new Float32Array([0, 0, 0, 0, 0, 0]);
        const offsetPt0 = new Uint32Array([0]);
        obj = { pts: pts2, offsetPt0 };
        log.error("Creating empty tracts");
      }
      rgba255[3] = 0;
      return new _NVMesh(
        obj.pts,
        obj.offsetPt0,
        name,
        rgba255,
        // colormap,
        opacity,
        // opacity,
        visible,
        // visible,
        gl,
        "inferno",
        obj.dpg || null,
        obj.dps || null,
        obj.dpv || null
      );
    }
    if (ext === "GII") {
      obj = await NVMeshLoaders.readGII(buffer);
    } else if (ext === "MZ3") {
      obj = await NVMeshLoaders.readMZ3(buffer);
      if (!("positions" in obj)) {
        log.warn("MZ3 does not have positions (statistical overlay?)");
      }
    } else if (ext === "ASC") {
      obj = NVMeshLoaders.readASC(buffer);
    } else if (ext === "DFS") {
      obj = NVMeshLoaders.readDFS(buffer);
    } else if (ext === "BYU" || ext === "G") {
      obj = NVMeshLoaders.readGEO(buffer);
    } else if (ext === "GEO") {
      obj = NVMeshLoaders.readGEO(buffer, true);
    } else if (ext === "ICO" || ext === "TRI") {
      obj = NVMeshLoaders.readICO(buffer);
    } else if (ext === "OFF") {
      obj = NVMeshLoaders.readOFF(buffer);
    } else if (ext === "NV") {
      obj = NVMeshLoaders.readNV(buffer);
    } else if (ext === "OBJ") {
      obj = await NVMeshLoaders.readOBJ(buffer);
    } else if (ext === "PLY") {
      obj = NVMeshLoaders.readPLY(buffer);
    } else if (ext === "WRL") {
      obj = NVMeshLoaders.readWRL(buffer);
    } else if (ext === "X3D") {
      obj = NVMeshLoaders.readX3D(buffer);
    } else if (ext === "FIB" || ext === "VTK") {
      obj = NVMeshLoaders.readVTK(buffer);
      if ("offsetPt0" in obj) {
        rgba255[3] = 0;
        return new _NVMesh(
          obj.pts,
          obj.offsetPt0,
          name,
          rgba255,
          // colormap,
          opacity,
          // opacity,
          visible,
          // visible,
          gl,
          "inferno"
        );
      }
    } else if (ext === "SRF") {
      obj = await NVMeshLoaders.readSRF(buffer);
    } else if (ext === "STL") {
      obj = NVMeshLoaders.readSTL(buffer);
    } else {
      obj = NVMeshLoaders.readFreeSurfer(buffer);
    }
    if (obj.anatomicalStructurePrimary) {
      anatomicalStructurePrimary = obj.anatomicalStructurePrimary;
    }
    if (obj instanceof Float32Array) {
      throw new Error("fatal: unknown mesh type loaded");
    }
    if (!("positions" in obj)) {
      throw new Error("positions not loaded");
    }
    if (!obj.indices) {
      throw new Error("indices not loaded");
    }
    pts = obj.positions;
    tris = obj.indices;
    if ("rgba255" in obj && obj.rgba255.length > 0) {
      rgba255 = obj.rgba255;
    }
    if ("colors" in obj && obj.colors && obj.colors.length === pts.length) {
      const n = pts.length / 3;
      rgba255 = new Uint8Array(n * 4);
      let c = 0;
      let k = 0;
      for (let i = 0; i < n; i++) {
        rgba255[k++] = obj.colors[c] * 255;
        rgba255[k++] = obj.colors[c + 1] * 255;
        rgba255[k++] = obj.colors[c + 2] * 255;
        rgba255[k++] = 255;
        c += 3;
      }
    }
    const npt = pts.length / 3;
    const ntri = tris.length / 3;
    if (ntri < 1 || npt < 3) {
      throw new Error("Mesh should have at least one triangle and three vertices");
    }
    rgba255[3] = Math.max(1, rgba255[3]);
    const nvm = new _NVMesh(
      pts,
      tris,
      name,
      rgba255,
      // colormap,
      opacity,
      // opacity,
      visible,
      // visible,
      gl,
      null,
      // connectome
      null,
      // dpg
      null,
      // dps
      null,
      // dpv
      true,
      // colorbarVisible
      anatomicalStructurePrimary
    );
    if ("scalars" in obj && obj.scalars.length > 0) {
      const newLayer = await NVMeshLoaders.readLayer(name, buffer, nvm, opacity, "gray");
      if (typeof newLayer === "undefined") {
        log.warn("readLayer() failed to convert scalars");
      } else {
        nvm.layers.push(newLayer);
        nvm.updateMesh(gl);
      }
    }
    return nvm;
  }
  static async loadLayer(layer, nvmesh) {
    let buffer = new Uint8Array().buffer;
    function base64ToArrayBuffer(base64) {
      const binary_string = window.atob(base64);
      const len4 = binary_string.length;
      const bytes = new Uint8Array(len4);
      for (let i = 0; i < len4; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }
    if (layer.base64 !== void 0) {
      buffer = base64ToArrayBuffer(layer.base64);
    } else {
      if (!layer.url) {
        throw new Error("layer: missing url");
      }
      const response = await fetch(layer.url, { headers: layer.headers });
      if (!response.ok) {
        throw Error(response.statusText);
      }
      buffer = await response.arrayBuffer();
    }
    let layerName;
    let urlParts = [];
    if (layer.name && layer.name !== "") {
      layerName = layer.name;
    } else {
      if (!layer.url) {
        throw new Error("layer: missing url");
      }
      try {
        urlParts = new URL(layer.url).pathname.split("/");
      } catch (e) {
        urlParts = layer.url.split("/");
      } finally {
        layerName = urlParts.slice(-1)[0];
      }
    }
    if (layerName.indexOf("?") > -1) {
      layerName = layerName.slice(0, layerName.indexOf("?"));
    }
    let opacity = 0.5;
    if ("opacity" in layer) {
      opacity = layer.opacity;
    }
    let colormap = "warm";
    if ("colormap" in layer) {
      colormap = layer.colormap;
    }
    let colormapNegative = "winter";
    if ("colormapNegative" in layer) {
      colormapNegative = layer.colormapNegative;
    }
    let useNegativeCmap = false;
    if ("useNegativeCmap" in layer) {
      useNegativeCmap = layer.useNegativeCmap;
    }
    let cal_min = null;
    if ("cal_min" in layer) {
      cal_min = layer.cal_min;
    }
    let cal_max = null;
    if ("cal_max" in layer) {
      cal_max = layer.cal_max;
    }
    const newLayer = await NVMeshLoaders.readLayer(
      layerName,
      buffer,
      nvmesh,
      opacity,
      colormap,
      colormapNegative,
      useNegativeCmap,
      cal_min,
      cal_max
    );
    if (newLayer) {
      nvmesh.layers.push(newLayer);
    }
  }
  /**
   * factory function to load and return a new NVMesh instance from a given URL
   */
  static async loadFromUrl({
    url = "",
    headers = {},
    gl,
    name = "",
    opacity = 1,
    rgba255 = [255, 255, 255, 255],
    visible = true,
    layers = [],
    buffer = new ArrayBuffer(0)
  } = {}) {
    let urlParts = url.split("/");
    if (name === "") {
      try {
        urlParts = new URL(url).pathname.split("/");
      } catch (e) {
        urlParts = url.split("/");
      }
      name = urlParts.slice(-1)[0];
      if (name.indexOf("?") > -1) {
        name = name.slice(0, name.indexOf("?"));
      }
    }
    if (url === "") {
      throw Error("url must not be empty");
    }
    if (!gl) {
      throw Error("gl context is null");
    }
    let buff;
    if (buffer.byteLength > 0) {
      buff = buffer;
    } else {
      const response = await fetch(url, { headers });
      if (!response.ok) {
        throw Error(response.statusText);
      }
      buff = await response.arrayBuffer();
    }
    const nvmesh = await this.readMesh(buff, name, gl, opacity, new Uint8Array(rgba255), visible);
    if (!layers || layers.length < 1) {
      return nvmesh;
    }
    for (let i = 0; i < layers.length; i++) {
      await _NVMesh.loadLayer(layers[i], nvmesh);
    }
    nvmesh.updateMesh(gl);
    return nvmesh;
  }
  // not included in public docs
  // loading Nifti files
  static async readFileAsync(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  }
  /**
   * factory function to load and return a new NVMesh instance from a file in the browser
   *
   * @returns NVMesh instance
   */
  static async loadFromFile({
    file,
    gl,
    name = "",
    opacity = 1,
    rgba255 = [255, 255, 255, 255],
    visible = true,
    layers = []
  } = {}) {
    if (!file) {
      throw new Error("file must be set");
    }
    if (!gl) {
      throw new Error("rendering context must be set");
    }
    const buffer = await _NVMesh.readFileAsync(file);
    const nvmesh = await _NVMesh.readMesh(buffer, name, gl, opacity, new Uint8Array(rgba255), visible);
    if (!layers || layers.length < 1) {
      return nvmesh;
    }
    for (let i = 0; i < layers.length; i++) {
      await _NVMesh.loadLayer(layers[i], nvmesh);
    }
    nvmesh.updateMesh(gl);
    return nvmesh;
  }
  /**
   * load and return a new NVMesh instance from a base64 encoded string
   */
  async loadFromBase64({
    base64,
    gl,
    name = "",
    opacity = 1,
    rgba255 = [255, 255, 255, 255],
    visible = true,
    layers = []
  } = {}) {
    if (!base64) {
      throw new Error("base64 must bet set");
    }
    if (!gl) {
      throw new Error("rendering context must be set");
    }
    function base64ToArrayBuffer(base642) {
      const binary_string = window.atob(base642);
      const len4 = binary_string.length;
      const bytes = new Uint8Array(len4);
      for (let i = 0; i < len4; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }
    const buffer = base64ToArrayBuffer(base64);
    const nvmesh = await _NVMesh.readMesh(buffer, name, gl, opacity, new Uint8Array(rgba255), visible);
    if (!layers || layers.length < 1) {
      return nvmesh;
    }
    for (let i = 0; i < layers.length; i++) {
      await _NVMesh.loadLayer(layers[i], nvmesh);
    }
    nvmesh.updateMesh(gl);
    return nvmesh;
  }
};

// src/matcaps/Shiny.jpg
var Shiny_default = "data:image/jpeg;base64,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ZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAABOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAAMjhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAACAAAAAgAAAAAEAG0AYwA2ADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAIAAAAAAFJnaHRsb25nAAACAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAA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bnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMTJUMjA6MDc6NDcrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0OGNjMGI3YS1iYTJkLWZmNDAtYmNkNC1jNGQzMzIyZjBiNzQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYzFjM2NhNS1hYTg4LWI5NGMtOGE4MS05YmU4MjA3ZGZiODciPiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YThjMGNhZTYtODNjYy1hYzQ4LWI2YzAtN2FiODNlOWJkMGM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWMxYzNjYTUtYWE4OC1iOTRjLThhODEtOWJlODIwN2RmYjg3IiBzdEV2dDp3aGVuPSIyMDE4LTA3LTEyVDIwOjA3OjQ3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmI3MzZlZC0zOTRhLTM2NDgtYThiOC02Mzk1MmY0NDcxMjIiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTY6MTM6NTgrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0xM1QxNzo1NDoyNyswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTc6NTQ6MjcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg3NjM1NDk5LWZiMTItYWU0MC04NWEzLThkMWFiN2NkZGVhOSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFjMWMzY2E1LWFhODgtYjk0Yy04YTgxLTliZTgyMDdkZmI4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAEAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1Q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";

// src/fonts/Roboto-Regular.png
var Roboto_Regular_default = "data:image/png;base64,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";

// src/fonts/Roboto-Regular.json
var Roboto_Regular_default2 = {
  atlas: {
    type: "msdf",
    distanceRange: 2,
    size: 59.65625,
    width: 512,
    height: 256,
    yOrigin: "bottom"
  },
  metrics: {
    emSize: 1,
    lineHeight: 1.171875,
    ascender: 0.927734375,
    descender: -0.244140625,
    underlineY: -0.09765625,
    underlineThickness: 0.048828125
  },
  glyphs: [
    { unicode: 32, advance: 0.24755859375 },
    {
      unicode: 33,
      advance: 0.25732421875,
      planeBounds: {
        left: 0.056159633438645884,
        bottom: -0.02437761405677056,
        right: 0.20702396031135412,
        top: 0.7299440203067705
      },
      atlasBounds: {
        left: 488.5,
        bottom: 145.5,
        right: 497.5,
        top: 190.5
      }
    },
    {
      unicode: 34,
      advance: 0.31982421875,
      planeBounds: {
        left: 0.049409125974004715,
        bottom: 0.48691155587022,
        right: 0.2840869677759953,
        top: 0.77187750662978
      },
      atlasBounds: {
        left: 486.5,
        bottom: 213.5,
        right: 500.5,
        top: 230.5
      }
    },
    {
      unicode: 35,
      advance: 0.61572265625,
      planeBounds: {
        left: 0.037219103997511785,
        bottom: -0.02169206718177056,
        right: 0.6239137085024882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 66.5,
        bottom: 51.5,
        right: 101.5,
        top: 96.5
      }
    },
    {
      unicode: 36,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.02956531458715296,
        bottom: -0.12381369908983761,
        right: 0.5324464041628472,
        top: 0.8484230740898377
      },
      atlasBounds: {
        left: 109.5,
        bottom: 197.5,
        right: 139.5,
        top: 255.5
      }
    },
    {
      unicode: 37,
      advance: 0.732421875,
      planeBounds: {
        left: 0.026481776289942378,
        bottom: -0.030073418674698794,
        right: 0.7137525987100576,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 88.5,
        bottom: 144.5,
        right: 129.5,
        top: 190.5
      }
    },
    {
      unicode: 38,
      advance: 0.62158203125,
      planeBounds: {
        left: 0.03225572125458355,
        bottom: -0.030073418674698794,
        right: 0.6357130287454166,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 130.5,
        bottom: 144.5,
        right: 166.5,
        top: 190.5
      }
    },
    {
      unicode: 39,
      advance: 0.17431640625,
      planeBounds: {
        left: 0.028244602049502358,
        bottom: 0.49895501673814824,
        right: 0.14558352295049765,
        top: 0.7671582645118518
      },
      atlasBounds: {
        left: 498.5,
        bottom: 62.5,
        right: 505.5,
        top: 78.5
      }
    },
    {
      unicode: 40,
      advance: 0.341796875,
      planeBounds: {
        left: 0.042983329377291775,
        bottom: -0.250029542422407,
        right: 0.34471198312270823,
        top: 0.8227834486724072
      },
      atlasBounds: {
        left: 0.5,
        bottom: 191.5,
        right: 18.5,
        top: 255.5
      }
    },
    {
      unicode: 41,
      advance: 0.34765625,
      planeBounds: {
        left: -0.003159248747708225,
        bottom: -0.250029542422407,
        right: 0.29856940499770823,
        top: 0.8227834486724072
      },
      atlasBounds: {
        left: 19.5,
        bottom: 191.5,
        right: 37.5,
        top: 255.5
      }
    },
    {
      unicode: 42,
      advance: 0.4306640625,
      planeBounds: {
        left: -0.011208599684062338,
        bottom: 0.27785390031593765,
        right: 0.44138438093406235,
        top: 0.7304468809340623
      },
      atlasBounds: {
        left: 449.5,
        bottom: 23.5,
        right: 476.5,
        top: 50.5
      }
    },
    {
      unicode: 43,
      advance: 0.56689453125,
      planeBounds: {
        left: 0.01353503347629649,
        bottom: 0.053493525733368255,
        right: 0.5499415290237036,
        top: 0.6066627242666317
      },
      atlasBounds: {
        left: 361.5,
        bottom: 17.5,
        right: 393.5,
        top: 50.5
      }
    },
    {
      unicode: 44,
      advance: 0.1962890625,
      planeBounds: {
        left: -0.009919475797210583,
        bottom: -0.15981695975478,
        right: 0.1744702570472106,
        top: 0.12514899100478
      },
      atlasBounds: {
        left: 498.5,
        bottom: 79.5,
        right: 509.5,
        top: 96.5
      }
    },
    {
      unicode: 45,
      advance: 0.27587890625,
      planeBounds: {
        left: -0.00527594412977999,
        bottom: 0.24333249267450235,
        right: 0.27969000662978,
        top: 0.36067141357549765
      },
      atlasBounds: { left: 52.5, bottom: 7.5, right: 69.5, top: 14.5 }
    },
    {
      unicode: 46,
      advance: 0.26318359375,
      planeBounds: {
        left: 0.051032680313645884,
        bottom: -0.027092319686354116,
        right: 0.20189700718635412,
        top: 0.12377200718635412
      },
      atlasBounds: {
        left: 501.5,
        bottom: 221.5,
        right: 510.5,
        top: 230.5
      }
    },
    {
      unicode: 47,
      advance: 0.412109375,
      planeBounds: {
        left: -0.013733006073205867,
        bottom: -0.08573505127848349,
        right: 0.4053345685732059,
        top: 0.7356373950284835
      },
      atlasBounds: {
        left: 252.5,
        bottom: 206.5,
        right: 277.5,
        top: 255.5
      }
    },
    {
      unicode: 48,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.037458384830081196,
        bottom: -0.030073418674698794,
        right: 0.5235767714199189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 167.5,
        bottom: 144.5,
        right: 196.5,
        top: 190.5
      }
    },
    {
      unicode: 49,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.06023674350936354,
        bottom: -0.01998308280677056,
        right: 0.37872810024063647,
        top: 0.7343385515567705
      },
      atlasBounds: {
        left: 488.5,
        bottom: 97.5,
        right: 507.5,
        top: 142.5
      }
    },
    {
      unicode: 50,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.025334353719224725,
        bottom: -0.01680925468177056,
        right: 0.5449781462807752,
        top: 0.7375123796817705
      },
      atlasBounds: {
        left: 278.5,
        bottom: 51.5,
        right: 309.5,
        top: 96.5
      }
    },
    {
      unicode: 51,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.028181041080081196,
        bottom: -0.030073418674698794,
        right: 0.5142994276699189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 197.5,
        bottom: 144.5,
        right: 226.5,
        top: 190.5
      }
    },
    {
      unicode: 52,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.005886103858368255,
        bottom: -0.02169206718177056,
        right: 0.5590553023916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 310.5,
        bottom: 51.5,
        right: 343.5,
        top: 96.5
      }
    },
    {
      unicode: 53,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.055524791080081196,
        bottom: -0.02657487968177056,
        right: 0.5416431776699189,
        top: 0.7277467546817705
      },
      atlasBounds: {
        left: 344.5,
        bottom: 51.5,
        right: 373.5,
        top: 96.5
      }
    },
    {
      unicode: 54,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.046003306705081196,
        bottom: -0.034712090549698794,
        right: 0.5321216932949189,
        top: 0.7363722467996989
      },
      atlasBounds: {
        left: 227.5,
        bottom: 144.5,
        right: 256.5,
        top: 190.5
      }
    },
    {
      unicode: 55,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.018010134969224725,
        bottom: -0.02169206718177056,
        right: 0.5376539275307752,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 374.5,
        bottom: 51.5,
        right: 405.5,
        top: 96.5
      }
    },
    {
      unicode: 56,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.037702525455081196,
        bottom: -0.030073418674698794,
        right: 0.5238209120449189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 257.5,
        bottom: 144.5,
        right: 286.5,
        top: 190.5
      }
    },
    {
      unicode: 57,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.029401744205081196,
        bottom: -0.025434746799698794,
        right: 0.5155201307949189,
        top: 0.7456495905496989
      },
      atlasBounds: {
        left: 287.5,
        bottom: 144.5,
        right: 316.5,
        top: 190.5
      }
    },
    {
      unicode: 58,
      advance: 0.2421875,
      planeBounds: {
        left: 0.046394008438645884,
        bottom: -0.029431286627488215,
        right: 0.19725833531135412,
        top: 0.5572633178774882
      },
      atlasBounds: {
        left: 439.5,
        bottom: 61.5,
        right: 448.5,
        top: 96.5
      }
    },
    {
      unicode: 59,
      advance: 0.21142578125,
      planeBounds: {
        left: 0.001066852327789419,
        bottom: -0.16459733294591408,
        right: 0.1854565851722106,
        top: 0.556198895445914
      },
      atlasBounds: {
        left: 406.5,
        bottom: 53.5,
        right: 417.5,
        top: 96.5
      }
    },
    {
      unicode: 60,
      advance: 0.50830078125,
      planeBounds: {
        left: 0.016948142433865897,
        bottom: 0.0726146348300812,
        right: 0.4527784200661341,
        top: 0.5587330214199189
      },
      atlasBounds: {
        left: 394.5,
        bottom: 21.5,
        right: 420.5,
        top: 50.5
      }
    },
    {
      unicode: 61,
      advance: 0.548828125,
      planeBounds: {
        left: 0.051535540940937666,
        bottom: 0.17620354038436353,
        right: 0.5041285215590624,
        top: 0.49469489711563647
      },
      atlasBounds: {
        left: 477.5,
        bottom: 31.5,
        right: 504.5,
        top: 50.5
      }
    },
    {
      unicode: 62,
      advance: 0.5224609375,
      planeBounds: {
        left: 0.047629290940937666,
        bottom: 0.0731029160800812,
        right: 0.5002222715590624,
        top: 0.5592213026699189
      },
      atlasBounds: {
        left: 421.5,
        bottom: 21.5,
        right: 448.5,
        top: 50.5
      }
    },
    {
      unicode: 63,
      advance: 0.47216796875,
      planeBounds: {
        left: 0.016704001808865897,
        bottom: -0.027876153049698794,
        right: 0.4525342794411341,
        top: 0.7432081842996989
      },
      atlasBounds: {
        left: 317.5,
        bottom: 144.5,
        right: 343.5,
        top: 190.5
      }
    },
    {
      unicode: 64,
      advance: 0.89794921875,
      planeBounds: {
        left: 0.034064457306783605,
        bottom: -0.23896750384690937,
        right: 0.8721996065996072,
        top: 0.7165065663469093
      },
      atlasBounds: {
        left: 155.5,
        bottom: 198.5,
        right: 205.5,
        top: 255.5
      }
    },
    {
      unicode: 65,
      advance: 0.65234375,
      planeBounds: {
        left: -0.008838044092129387,
        bottom: -0.02169206718177056,
        right: 0.6616700753421295,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 237.5,
        bottom: 51.5,
        right: 277.5,
        top: 96.5
      }
    },
    {
      unicode: 66,
      advance: 0.62255859375,
      planeBounds: {
        left: 0.06464099434422473,
        bottom: -0.02169206718177056,
        right: 0.5842847869057752,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 205.5,
        bottom: 51.5,
        right: 236.5,
        top: 96.5
      }
    },
    {
      unicode: 67,
      advance: 0.65087890625,
      planeBounds: {
        left: 0.038439807122511785,
        bottom: -0.030073418674698794,
        right: 0.6251344116274882,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 344.5,
        bottom: 144.5,
        right: 379.5,
        top: 190.5
      }
    },
    {
      unicode: 68,
      advance: 0.65576171875,
      planeBounds: {
        left: 0.06301501010836826,
        bottom: -0.02169206718177056,
        right: 0.6161842086416317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 162.5,
        bottom: 51.5,
        right: 195.5,
        top: 96.5
      }
    },
    {
      unicode: 69,
      advance: 0.568359375,
      planeBounds: {
        left: 0.0652904160800812,
        bottom: -0.02169206718177056,
        right: 0.5514088026699189,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 132.5,
        bottom: 51.5,
        right: 161.5,
        top: 96.5
      }
    },
    {
      unicode: 70,
      advance: 0.552734375,
      planeBounds: {
        left: 0.059675181705081196,
        bottom: -0.02169206718177056,
        right: 0.5457935682949189,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 102.5,
        bottom: 51.5,
        right: 131.5,
        top: 96.5
      }
    },
    {
      unicode: 71,
      advance: 0.68115234375,
      planeBounds: {
        left: 0.040148791497511785,
        bottom: -0.030073418674698794,
        right: 0.6268433960024882,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 380.5,
        bottom: 144.5,
        right: 415.5,
        top: 190.5
      }
    },
    {
      unicode: 72,
      advance: 0.712890625,
      planeBounds: {
        left: 0.062365588372511785,
        bottom: -0.02169206718177056,
        right: 0.6490601928774882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 30.5,
        bottom: 51.5,
        right: 65.5,
        top: 96.5
      }
    },
    {
      unicode: 73,
      advance: 0.27197265625,
      planeBounds: {
        left: 0.06917965680657412,
        bottom: -0.02169206718177056,
        right: 0.20328128069342588,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 196.5,
        bottom: 51.5,
        right: 204.5,
        top: 96.5
      }
    },
    {
      unicode: 74,
      advance: 0.5517578125,
      planeBounds: {
        left: 0.007184947330081194,
        bottom: -0.02657487968177056,
        right: 0.4933033339199188,
        top: 0.7277467546817705
      },
      atlasBounds: { left: 0.5, bottom: 51.5, right: 29.5, top: 96.5 }
    },
    {
      unicode: 75,
      advance: 0.626953125,
      planeBounds: {
        left: 0.061633166497511785,
        bottom: -0.02169206718177056,
        right: 0.6483277710024882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 452.5,
        bottom: 97.5,
        right: 487.5,
        top: 142.5
      }
    },
    {
      unicode: 76,
      advance: 0.5380859375,
      planeBounds: {
        left: 0.06341786132300943,
        bottom: -0.02169206718177056,
        right: 0.5327735449269906,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 423.5,
        bottom: 97.5,
        right: 451.5,
        top: 142.5
      }
    },
    {
      unicode: 77,
      advance: 0.873046875,
      planeBounds: {
        left: 0.05911847969322944,
        bottom: -0.02169206718177056,
        right: 0.8134401140567705,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 377.5,
        bottom: 97.5,
        right: 422.5,
        top: 142.5
      }
    },
    {
      unicode: 78,
      advance: 0.712890625,
      planeBounds: {
        left: 0.062365588372511785,
        bottom: -0.02169206718177056,
        right: 0.6490601928774882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 341.5,
        bottom: 97.5,
        right: 376.5,
        top: 142.5
      }
    },
    {
      unicode: 79,
      advance: 0.6875,
      planeBounds: {
        left: 0.033395854136655315,
        bottom: -0.030073418674698794,
        right: 0.6536158646133446,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 416.5,
        bottom: 144.5,
        right: 453.5,
        top: 190.5
      }
    },
    {
      unicode: 80,
      advance: 0.630859375,
      planeBounds: {
        left: 0.061550166358368255,
        bottom: -0.02169206718177056,
        right: 0.6147193648916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 273.5,
        bottom: 97.5,
        right: 306.5,
        top: 142.5
      }
    },
    {
      unicode: 81,
      advance: 0.6875,
      planeBounds: {
        left: 0.030466166636655315,
        bottom: -0.14391866037519643,
        right: 0.6506861771133446,
        top: 0.7445045978751964
      },
      atlasBounds: {
        left: 214.5,
        bottom: 202.5,
        right: 251.5,
        top: 255.5
      }
    },
    {
      unicode: 82,
      advance: 0.61572265625,
      planeBounds: {
        left: 0.06350329135836826,
        bottom: -0.02169206718177056,
        right: 0.6166724898916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 186.5,
        bottom: 97.5,
        right: 219.5,
        top: 142.5
      }
    },
    {
      unicode: 83,
      advance: 0.59326171875,
      planeBounds: {
        left: 0.020778681983368255,
        bottom: -0.030073418674698794,
        right: 0.5739478805166317,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 454.5,
        bottom: 144.5,
        right: 487.5,
        top: 190.5
      }
    },
    {
      unicode: 84,
      advance: 0.5966796875,
      planeBounds: {
        left: 0.005480822747511787,
        bottom: -0.02169206718177056,
        right: 0.5921754272524882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 112.5,
        bottom: 97.5,
        right: 147.5,
        top: 142.5
      }
    },
    {
      unicode: 85,
      advance: 0.6484375,
      planeBounds: {
        left: 0.049098994483368255,
        bottom: -0.02657487968177056,
        right: 0.6022681930166317,
        top: 0.7277467546817705
      },
      atlasBounds: {
        left: 78.5,
        bottom: 97.5,
        right: 111.5,
        top: 142.5
      }
    },
    {
      unicode: 86,
      advance: 0.63623046875,
      planeBounds: {
        left: -0.008269192599201152,
        bottom: -0.02169206718177056,
        right: 0.6454762238492011,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 38.5,
        bottom: 97.5,
        right: 77.5,
        top: 142.5
      }
    },
    {
      unicode: 87,
      advance: 0.88720703125,
      planeBounds: {
        left: 0.011923628617731797,
        bottom: -0.02169206718177056,
        right: 0.8835841838822683,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 220.5,
        bottom: 97.5,
        right: 272.5,
        top: 142.5
      }
    },
    {
      unicode: 88,
      advance: 0.626953125,
      planeBounds: {
        left: 0.004098979136655316,
        bottom: -0.02169206718177056,
        right: 0.6243189896133446,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 0.5,
        bottom: 97.5,
        right: 37.5,
        top: 142.5
      }
    },
    {
      unicode: 89,
      advance: 0.6005859375,
      planeBounds: {
        left: -0.010793598988344685,
        bottom: -0.02169206718177056,
        right: 0.6094264114883446,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 148.5,
        bottom: 97.5,
        right: 185.5,
        top: 142.5
      }
    },
    {
      unicode: 90,
      advance: 0.5986328125,
      planeBounds: {
        left: 0.024196650733368255,
        bottom: -0.02169206718177056,
        right: 0.5773658492666317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 307.5,
        bottom: 97.5,
        right: 340.5,
        top: 142.5
      }
    },
    {
      unicode: 91,
      advance: 0.26513671875,
      planeBounds: {
        left: 0.05437250871693295,
        bottom: -0.17280296457569408,
        right: 0.27228764753306706,
        top: 0.8329592145756942
      },
      atlasBounds: {
        left: 59.5,
        bottom: 195.5,
        right: 72.5,
        top: 255.5
      }
    },
    {
      unicode: 92,
      advance: 0.41015625,
      planeBounds: {
        left: 0.0014037126767941326,
        bottom: -0.08573505127848349,
        right: 0.4204712873232059,
        top: 0.7356373950284835
      },
      atlasBounds: {
        left: 278.5,
        bottom: 206.5,
        right: 303.5,
        top: 255.5
      }
    },
    {
      unicode: 93,
      advance: 0.26513671875,
      planeBounds: {
        left: -0.020659233400995285,
        bottom: -0.17280296457569408,
        right: 0.2140186084009953,
        top: 0.8329592145756942
      },
      atlasBounds: {
        left: 94.5,
        bottom: 195.5,
        right: 108.5,
        top: 255.5
      }
    },
    {
      unicode: 94,
      advance: 0.41796875,
      planeBounds: {
        left: 0.006855376669722368,
        bottom: 0.33229482979472236,
        right: 0.40916024833027764,
        top: 0.7345997014552776
      },
      atlasBounds: {
        left: 486.5,
        bottom: 231.5,
        right: 510.5,
        top: 255.5
      }
    },
    {
      unicode: 95,
      advance: 0.451171875,
      planeBounds: {
        left: -0.017473255794918804,
        bottom: -0.09553469482549765,
        right: 0.4686451307949188,
        top: 0.021804226075497646
      },
      atlasBounds: { left: 70.5, bottom: 7.5, right: 99.5, top: 14.5 }
    },
    {
      unicode: 96,
      advance: 0.30908203125,
      planeBounds: {
        left: 0.00391839948107648,
        bottom: 0.5860277898277895,
        right: 0.2553589442689235,
        top: 0.7704175226722105
      },
      atlasBounds: { left: 36.5, bottom: 3.5, right: 51.5, top: 14.5 }
    },
    {
      unicode: 97,
      advance: 0.5439453125,
      planeBounds: {
        left: 0.028181041080081196,
        bottom: -0.029187146002488215,
        right: 0.5142994276699189,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 30.5,
        bottom: 15.5,
        right: 59.5,
        top: 50.5
      }
    },
    {
      unicode: 98,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.048932994205081196,
        bottom: -0.032187684160555265,
        right: 0.5350513807949189,
        top: 0.7724220591605554
      },
      atlasBounds: {
        left: 304.5,
        bottom: 207.5,
        right: 333.5,
        top: 255.5
      }
    },
    {
      unicode: 99,
      advance: 0.5234375,
      planeBounds: {
        left: 0.024518931705081196,
        bottom: -0.029187146002488215,
        right: 0.5106373182949189,
        top: 0.5575074585024882
      },
      atlasBounds: { left: 0.5, bottom: 15.5, right: 29.5, top: 50.5 }
    },
    {
      unicode: 100,
      advance: 0.56396484375,
      planeBounds: {
        left: 0.026227916080081196,
        bottom: -0.032187684160555265,
        right: 0.5123463026699189,
        top: 0.7724220591605554
      },
      atlasBounds: {
        left: 334.5,
        bottom: 207.5,
        right: 363.5,
        top: 255.5
      }
    },
    {
      unicode: 101,
      advance: 0.52978515625,
      planeBounds: {
        left: 0.026472056705081196,
        bottom: -0.029187146002488215,
        right: 0.5125904432949189,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 468.5,
        bottom: 61.5,
        right: 497.5,
        top: 96.5
      }
    },
    {
      unicode: 102,
      advance: 0.34716796875,
      planeBounds: {
        left: 0.004575110905578838,
        bottom: -0.022177918535555265,
        right: 0.3733545765944212,
        top: 0.7824318247855554
      },
      atlasBounds: {
        left: 364.5,
        bottom: 207.5,
        right: 386.5,
        top: 255.5
      }
    },
    {
      unicode: 103,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.026960337955081196,
        bottom: -0.22888445766762702,
        right: 0.5130787245449189,
        top: 0.558962582667627
      },
      atlasBounds: {
        left: 28.5,
        bottom: 143.5,
        right: 57.5,
        top: 190.5
      }
    },
    {
      unicode: 104,
      advance: 0.55078125,
      planeBounds: {
        left: 0.049826556565937666,
        bottom: -0.01892352016762703,
        right: 0.5024195371840624,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 0.5,
        bottom: 143.5,
        right: 27.5,
        top: 190.5
      }
    },
    {
      unicode: 105,
      advance: 0.24267578125,
      planeBounds: {
        left: 0.046882289688645884,
        bottom: -0.01680925468177056,
        right: 0.19774661656135412,
        top: 0.7375123796817705
      },
      atlasBounds: {
        left: 498.5,
        bottom: 145.5,
        right: 507.5,
        top: 190.5
      }
    },
    {
      unicode: 106,
      advance: 0.23876953125,
      planeBounds: {
        left: -0.048979545900995285,
        bottom: -0.2324562772148376,
        right: 0.1856982959009953,
        top: 0.7397804959648377
      },
      atlasBounds: {
        left: 140.5,
        bottom: 197.5,
        right: 154.5,
        top: 255.5
      }
    },
    {
      unicode: 107,
      advance: 0.5068359375,
      planeBounds: {
        left: 0.044294322330081196,
        bottom: -0.01892352016762703,
        right: 0.5304127089199189,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 58.5,
        bottom: 143.5,
        right: 87.5,
        top: 190.5
      }
    },
    {
      unicode: 108,
      advance: 0.24267578125,
      planeBounds: {
        left: 0.05428707868157412,
        bottom: -0.01892352016762703,
        right: 0.18838870256842588,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 477.5,
        bottom: 208.5,
        right: 485.5,
        top: 255.5
      }
    },
    {
      unicode: 109,
      advance: 0.87646484375,
      planeBounds: {
        left: 0.04430890170737297,
        bottom: -0.024304333502488215,
        right: 0.832155942042627,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 116.5,
        bottom: 15.5,
        right: 163.5,
        top: 50.5
      }
    },
    {
      unicode: 110,
      advance: 0.5517578125,
      planeBounds: {
        left: 0.049826556565937666,
        bottom: -0.024304333502488215,
        right: 0.5024195371840624,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 60.5,
        bottom: 15.5,
        right: 87.5,
        top: 50.5
      }
    },
    {
      unicode: 111,
      advance: 0.5703125,
      planeBounds: {
        left: 0.025090213094224725,
        bottom: -0.029187146002488215,
        right: 0.5447340056557752,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 193.5,
        bottom: 15.5,
        right: 224.5,
        top: 50.5
      }
    },
    {
      unicode: 112,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.048444712955081196,
        bottom: -0.22644305141762702,
        right: 0.5345630995449189,
        top: 0.561403988917627
      },
      atlasBounds: {
        left: 447.5,
        bottom: 208.5,
        right: 476.5,
        top: 255.5
      }
    },
    {
      unicode: 113,
      advance: 0.568359375,
      planeBounds: {
        left: 0.025983775455081196,
        bottom: -0.22644305141762702,
        right: 0.5121021620449189,
        top: 0.561403988917627
      },
      atlasBounds: {
        left: 417.5,
        bottom: 208.5,
        right: 446.5,
        top: 255.5
      }
    },
    {
      unicode: 114,
      advance: 0.33837890625,
      planeBounds: {
        left: 0.045180595002291775,
        bottom: -0.024304333502488215,
        right: 0.34690924874770823,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 449.5,
        bottom: 61.5,
        right: 467.5,
        top: 96.5
      }
    },
    {
      unicode: 115,
      advance: 0.515625,
      planeBounds: {
        left: 0.021669814448009427,
        bottom: -0.029187146002488215,
        right: 0.4910254980519906,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 164.5,
        bottom: 15.5,
        right: 192.5,
        top: 50.5
      }
    },
    {
      unicode: 116,
      advance: 0.32666015625,
      planeBounds: {
        left: -0.019433670483564695,
        bottom: -0.02877457520298586,
        right: 0.3158203892335647,
        top: 0.675258950202986
      },
      atlasBounds: {
        left: 418.5,
        bottom: 54.5,
        right: 438.5,
        top: 96.5
      }
    },
    {
      unicode: 117,
      advance: 0.55126953125,
      planeBounds: {
        left: 0.048117572190937666,
        bottom: -0.034069958502488215,
        right: 0.5007105528090624,
        top: 0.5526246460024882
      },
      atlasBounds: {
        left: 88.5,
        bottom: 15.5,
        right: 115.5,
        top: 50.5
      }
    },
    {
      unicode: 118,
      advance: 0.484375,
      planeBounds: {
        left: -0.002092396419918806,
        bottom: -0.02080579450955998,
        right: 0.4840259901699188,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 331.5,
        bottom: 16.5,
        right: 360.5,
        top: 50.5
      }
    },
    {
      unicode: 119,
      advance: 0.75146484375,
      planeBounds: {
        left: -0.002649098431770561,
        bottom: -0.02080579450955998,
        right: 0.7516725359317705,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 225.5,
        bottom: 16.5,
        right: 270.5,
        top: 50.5
      }
    },
    {
      unicode: 120,
      advance: 0.49560546875,
      planeBounds: {
        left: -0.0046143729128470395,
        bottom: -0.02080579450955998,
        right: 0.4982667166628471,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 300.5,
        bottom: 16.5,
        right: 330.5,
        top: 50.5
      }
    },
    {
      unicode: 121,
      advance: 0.47314453125,
      planeBounds: {
        left: -0.007219349544918806,
        bottom: -0.23645281704262702,
        right: 0.4788990370449188,
        top: 0.551394223292627
      },
      atlasBounds: {
        left: 387.5,
        bottom: 208.5,
        right: 416.5,
        top: 255.5
      }
    },
    {
      unicode: 122,
      advance: 0.49560546875,
      planeBounds: {
        left: 0.018007705073009427,
        bottom: -0.02080579450955998,
        right: 0.4873633886769906,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 271.5,
        bottom: 16.5,
        right: 299.5,
        top: 50.5
      }
    },
    {
      unicode: 123,
      advance: 0.33837890625,
      planeBounds: {
        left: 0.011572188891435306,
        bottom: -0.20234398020069408,
        right: 0.3468262486085647,
        top: 0.8034181989506942
      },
      atlasBounds: {
        left: 73.5,
        bottom: 195.5,
        right: 93.5,
        top: 255.5
      }
    },
    {
      unicode: 124,
      advance: 0.24365234375,
      planeBounds: {
        left: 0.06315671142450235,
        bottom: -0.15466084787519643,
        right: 0.18049563232549765,
        top: 0.7337624103751964
      },
      atlasBounds: {
        left: 206.5,
        bottom: 202.5,
        right: 213.5,
        top: 255.5
      }
    },
    {
      unicode: 125,
      advance: 0.33837890625,
      planeBounds: {
        left: -0.010156326733564695,
        bottom: -0.20234398020069408,
        right: 0.3250977329835647,
        top: 0.8034181989506942
      },
      atlasBounds: {
        left: 38.5,
        bottom: 195.5,
        right: 58.5,
        top: 255.5
      }
    },
    {
      unicode: 126,
      advance: 0.68017578125,
      planeBounds: {
        left: 0.046984728997511785,
        bottom: 0.1766063915990047,
        right: 0.6336793335024882,
        top: 0.4112842334009953
      },
      atlasBounds: { left: 0.5, bottom: 0.5, right: 35.5, top: 14.5 }
    }
  ],
  kerning: []
};

// src/nvlabel.ts
var LabelTextAlignment = /* @__PURE__ */ ((LabelTextAlignment2) => {
  LabelTextAlignment2["LEFT"] = "left";
  LabelTextAlignment2["RIGHT"] = "right";
  LabelTextAlignment2["CENTER"] = "center";
  return LabelTextAlignment2;
})(LabelTextAlignment || {});
var LabelLineTerminator = /* @__PURE__ */ ((LabelLineTerminator2) => {
  LabelLineTerminator2["NONE"] = "none";
  LabelLineTerminator2["CIRCLE"] = "circle";
  LabelLineTerminator2["RING"] = "ring";
  return LabelLineTerminator2;
})(LabelLineTerminator || {});
var LabelAnchorPoint = /* @__PURE__ */ ((LabelAnchorPoint2) => {
  LabelAnchorPoint2[LabelAnchorPoint2["NONE"] = 0 /* NONE */] = "NONE";
  LabelAnchorPoint2[LabelAnchorPoint2["TOPLEFT"] = 9] = "TOPLEFT";
  LabelAnchorPoint2[LabelAnchorPoint2["TOPCENTER"] = 10] = "TOPCENTER";
  LabelAnchorPoint2[LabelAnchorPoint2["TOPRIGHT"] = 12] = "TOPRIGHT";
  LabelAnchorPoint2[LabelAnchorPoint2["MIDDLELEFT"] = 17] = "MIDDLELEFT";
  LabelAnchorPoint2[LabelAnchorPoint2["MIDDLECENTER"] = 18] = "MIDDLECENTER";
  LabelAnchorPoint2[LabelAnchorPoint2["MIDDLERIGHT"] = 20] = "MIDDLERIGHT";
  LabelAnchorPoint2[LabelAnchorPoint2["BOTTOMLEFT"] = 33] = "BOTTOMLEFT";
  LabelAnchorPoint2[LabelAnchorPoint2["BOTTOMCENTER"] = 34] = "BOTTOMCENTER";
  LabelAnchorPoint2[LabelAnchorPoint2["BOTTOMRIGHT"] = 36] = "BOTTOMRIGHT";
  return LabelAnchorPoint2;
})(LabelAnchorPoint || {});
var NVLabel3DStyle = class {
  /**
   * @param textColor - Color of text
   * @param textScale - Text Size (0.0..1.0)
   * @param lineWidth - Line width
   * @param lineColor - Line color
   * @param bulletScale - Bullet size respective of text
   * @param bulletColor - Bullet color
   * @param backgroundColor - Background color of label
   */
  constructor(textColor = [1, 1, 1, 1], textScale = 1, textAlignment = "left" /* LEFT */, lineWidth = 0, lineColor = [0, 0, 0], lineTerminator = "none" /* NONE */, bulletScale, bulletColor, backgroundColor) {
    __publicField(this, "textColor");
    __publicField(this, "textScale");
    __publicField(this, "textAlignment");
    __publicField(this, "lineWidth");
    __publicField(this, "lineColor");
    __publicField(this, "lineTerminator");
    __publicField(this, "bulletScale");
    __publicField(this, "bulletColor");
    __publicField(this, "backgroundColor");
    this.textColor = textColor;
    this.textScale = textScale;
    this.textAlignment = textAlignment;
    this.lineWidth = lineWidth;
    this.lineColor = lineColor;
    this.lineTerminator = lineTerminator;
    this.bulletScale = bulletScale;
    this.bulletColor = bulletColor;
    this.backgroundColor = backgroundColor;
  }
};
var NVLabel3D = class {
  /**
   * @param text - The text of the label
   * @param style - The style of the label
   * @param points - An array of points label for label lines
   */
  constructor(text, style, points, anchor, onClick) {
    __publicField(this, "text");
    __publicField(this, "style");
    __publicField(this, "points");
    __publicField(this, "anchor");
    __publicField(this, "onClick");
    this.text = text;
    this.style = style;
    this.points = points;
    this.anchor = anchor || 0 /* NONE */;
    this.onClick = onClick;
  }
};

// src/nvconnectome.ts
var defaultOptions = {
  name: "untitled connectome",
  nodeColormap: "warm",
  nodeColormapNegative: "winter",
  nodeMinColor: 0,
  nodeMaxColor: 4,
  nodeScale: 3,
  edgeColormap: "warm",
  edgeColormapNegative: "winter",
  edgeMin: 2,
  edgeMax: 6,
  edgeScale: 1,
  legendLineThickness: 0
};
var NVConnectome = class _NVConnectome extends NVMesh3 {
  constructor(gl, connectome) {
    super(new Float32Array([]), new Uint32Array([]), connectome.name, new Uint8Array([]), 1, true, gl, connectome);
    __publicField(this, "gl");
    __publicField(this, "nodesChanged");
    this.gl = gl;
    this.type = "connectome" /* CONNECTOME */;
    if (this.nodes) {
      this.updateLabels();
    }
    this.nodesChanged = new EventTarget();
  }
  static convertLegacyConnectome(json) {
    const connectome = { nodes: [], edges: [], ...defaultOptions };
    for (const prop in json) {
      if (prop in defaultOptions) {
        const key = prop;
        connectome[key] = json[key];
      }
    }
    const nodes = json.nodes;
    for (let i = 0; i < nodes.names.length; i++) {
      connectome.nodes.push({
        name: nodes.names[i],
        x: nodes.X[i],
        y: nodes.Y[i],
        z: nodes.Z[i],
        colorValue: nodes.Color[i],
        sizeValue: nodes.Size[i]
      });
    }
    for (let i = 0; i < nodes.names.length - 1; i++) {
      for (let j = i + 1; j < nodes.names.length; j++) {
        const colorValue = json.edges[i * nodes.names.length + j];
        connectome.edges.push({
          first: i,
          second: j,
          colorValue
        });
      }
    }
    return connectome;
  }
  static convertFreeSurferConnectome(json, colormap = "warm") {
    let isValid = true;
    if (!("data_type" in json)) {
      isValid = false;
    } else if (json.data_type !== "fs_pointset") {
      isValid = false;
    }
    if (!("points" in json)) {
      isValid = false;
    }
    if (!isValid) {
      throw Error("not a valid FreeSurfer json pointset");
    }
    const nodes = json.points.map((p) => ({
      name: Array.isArray(p.comments) && p.comments.length > 0 && "text" in p.comments[0] ? p.comments[0].text : "",
      x: p.coordinates.x,
      y: p.coordinates.y,
      z: p.coordinates.z,
      colorValue: 1,
      sizeValue: 1,
      metadata: p.comments
    }));
    const connectome = {
      ...defaultOptions,
      nodeColormap: colormap,
      edgeColormap: colormap,
      nodes,
      edges: []
    };
    return connectome;
  }
  updateLabels() {
    const nodes = this.nodes;
    if (nodes && nodes.length > 0) {
      const largest = nodes.reduce((a, b) => a.sizeValue > b.sizeValue ? a : b).sizeValue;
      let min4, max5;
      if (typeof this.nodeMinColor !== "undefined" && isFinite(this.nodeMinColor)) {
        min4 = this.nodeMinColor;
      } else {
        min4 = nodes[0].colorValue;
        for (let i = 1; i < nodes.length; i++) {
          if (nodes[i].colorValue < min4) {
            min4 = nodes[i].colorValue;
          }
        }
      }
      if (typeof this.nodeMaxColor !== "undefined" && isFinite(this.nodeMaxColor)) {
        max5 = this.nodeMaxColor;
      } else {
        max5 = nodes[0].colorValue;
        for (let i = 1; i < nodes.length; i++) {
          if (nodes[i].colorValue > max5) {
            max5 = nodes[i].colorValue;
          }
        }
      }
      const lut = cmapper.colormap(this.nodeColormap, this.colormapInvert);
      const lutNeg = cmapper.colormap(this.nodeColormapNegative, this.colormapInvert);
      const hasNeg = "nodeColormapNegative" in this;
      const legendLineThickness = this.legendLineThickness ? this.legendLineThickness : 0;
      for (let i = 0; i < nodes.length; i++) {
        let color = nodes[i].colorValue;
        let isNeg = false;
        if (hasNeg && color < 0) {
          isNeg = true;
          color = -color;
        }
        if (min4 < max5) {
          if (color < min4) {
            log.warn("color value lower than min");
            continue;
          }
          color = (color - min4) / (max5 - min4);
        } else {
          color = 1;
        }
        color = Math.round(Math.max(Math.min(255, color * 255))) * 4;
        let rgba = [lut[color], lut[color + 1], lut[color + 2], 255];
        if (isNeg) {
          rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255];
        }
        rgba = rgba.map((c) => c / 255);
        log.debug("adding label for ", nodes[i]);
        nodes[i].label = new NVLabel3D(
          nodes[i].name,
          {
            textColor: rgba,
            bulletScale: nodes[i].sizeValue / largest,
            bulletColor: rgba,
            lineWidth: legendLineThickness,
            lineColor: rgba,
            textScale: 1,
            textAlignment: "left" /* LEFT */,
            lineTerminator: "none" /* NONE */
          },
          [nodes[i].x, nodes[i].y, nodes[i].z]
        );
        log.debug("label for node:", nodes[i].label);
      }
    }
  }
  addConnectomeNode(node) {
    log.debug("adding node", node);
    if (!this.nodes) {
      throw new Error("nodes not defined");
    }
    ;
    this.nodes.push(node);
    this.updateLabels();
    this.nodesChanged.dispatchEvent(new CustomEvent("nodeAdded", { detail: { node } }));
  }
  deleteConnectomeNode(node) {
    const index = this.nodes.indexOf(node);
    const edges = this.edges;
    if (edges) {
      this.edges = edges.filter((e) => e.first !== index && e.second !== index);
    }
    this.nodes = this.nodes.filter((n) => n !== node);
    this.updateLabels();
    this.updateConnectome(this.gl);
    this.nodesChanged.dispatchEvent(new CustomEvent("nodeDeleted", { detail: { node } }));
  }
  updateConnectomeNodeByIndex(index, updatedNode) {
    ;
    this.nodes[index] = updatedNode;
    this.updateLabels();
    this.updateConnectome(this.gl);
    this.nodesChanged.dispatchEvent(new CustomEvent("nodeChanged", { detail: { node: updatedNode } }));
  }
  updateConnectomeNodeByPoint(point, updatedNode) {
    const nodes = this.nodes;
    if (!nodes) {
      throw new Error("Node to update does not exist");
    }
    const node = nodes.find((node2) => NVUtilities.arraysAreEqual([node2.x, node2.y, node2.z], point));
    if (!node) {
      throw new Error(`Node with point ${point} to update does not exist`);
    }
    const index = nodes.findIndex((n) => n === node);
    this.updateConnectomeNodeByIndex(index, updatedNode);
  }
  addConnectomeEdge(first, second, colorValue) {
    const edges = this.edges;
    let edge = edges.find((f) => (f.first === first || f.second === first) && f.first + f.second === first + second);
    if (edge) {
      return edge;
    }
    edge = { first, second, colorValue };
    edges.push(edge);
    this.updateConnectome(this.gl);
    return edge;
  }
  deleteConnectomeEdge(first, second) {
    const edges = this.edges;
    const edge = edges.find((f) => (f.first === first || f.first === second) && f.first + f.second === first + second);
    if (edge) {
      this.edges = edges.filter((e) => e !== edge);
    } else {
      throw new Error(`edge between ${first} and ${second} not found`);
    }
    this.updateConnectome(this.gl);
    return edge;
  }
  findClosestConnectomeNode(point, distance4) {
    const nodes = this.nodes;
    if (!nodes || nodes.length === 0) {
      return null;
    }
    const closeNodes = nodes.map((n, i) => ({
      node: n,
      distance: Math.sqrt(Math.pow(n.x - point[0], 2) + Math.pow(n.y - point[1], 2) + Math.pow(n.z - point[2], 2)),
      index: i
    })).filter((n) => n.distance < distance4).sort((a, b) => a.distance - b.distance);
    if (closeNodes.length > 0) {
      return closeNodes[0].node;
    } else {
      return null;
    }
  }
  updateConnectome(gl) {
    const tris = [];
    const pts = [];
    const rgba255 = [];
    let lut = cmapper.colormap(this.nodeColormap, this.colormapInvert);
    let lutNeg = cmapper.colormap(this.nodeColormapNegative, this.colormapInvert);
    let hasNeg = "nodeColormapNegative" in this;
    if (this.nodeMinColor === void 0) {
      this.nodeMinColor = NaN;
    }
    if (this.nodeMaxColor === void 0) {
      this.nodeMaxColor = NaN;
    }
    if (this.edgeMin === void 0) {
      this.edgeMin = NaN;
    }
    if (this.edgeMax === void 0) {
      this.edgeMax = NaN;
    }
    let min4 = this.nodeMinColor;
    let max5 = this.nodeMaxColor;
    if (!isFinite(min4) || !isFinite(min4)) {
      const nodes2 = this.nodes;
      min4 = nodes2[0].colorValue;
      max5 = nodes2[0].colorValue;
      for (let i = 0; i < nodes2.length; i++) {
        min4 = Math.min(min4, nodes2[i].colorValue);
        max5 = Math.max(max5, nodes2[i].colorValue);
      }
    }
    const nodes = this.nodes;
    const nNode = nodes.length;
    for (let i = 0; i < nNode; i++) {
      const radius = nodes[i].sizeValue * this.nodeScale;
      if (radius <= 0) {
        continue;
      }
      let color = nodes[i].colorValue;
      let isNeg = false;
      if (hasNeg && color < 0) {
        isNeg = true;
        color = -color;
      }
      if (min4 < max5) {
        if (color < min4) {
          continue;
        }
        color = (color - min4) / (max5 - min4);
      } else {
        color = 1;
      }
      color = Math.round(Math.max(Math.min(255, color * 255))) * 4;
      let rgba = [lut[color], lut[color + 1], lut[color + 2], 255];
      if (isNeg) {
        rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255];
      }
      const pt = vec3_exports.fromValues(nodes[i].x, nodes[i].y, nodes[i].z);
      NiivueObject3D.makeColoredSphere(pts, tris, rgba255, radius, pt, rgba);
    }
    lut = cmapper.colormap(this.edgeColormap, this.colormapInvert);
    lutNeg = cmapper.colormap(this.edgeColormapNegative, this.colormapInvert);
    hasNeg = "edgeColormapNegative" in this;
    const edges = this.edges;
    if (edges !== void 0 && edges.length > 0) {
      min4 = this.edgeMin;
      max5 = this.edgeMax;
      if (!isFinite(min4) || !isFinite(min4)) {
        min4 = edges[0].colorValue;
        max5 = edges[0].colorValue;
        for (let i = 0; i < edges.length; i++) {
          min4 = Math.min(min4, edges[i].colorValue);
          max5 = Math.max(max5, edges[i].colorValue);
        }
      }
      for (const edge of edges) {
        let color = edge.colorValue;
        const isNeg = hasNeg && color < 0;
        if (isNeg) {
          color = -color;
        }
        const radius = color * this.edgeScale;
        if (radius <= 0) {
          continue;
        }
        if (min4 < max5) {
          if (color < min4) {
            continue;
          }
          color = (color - min4) / (max5 - min4);
        } else {
          color = 1;
        }
        color = Math.round(Math.max(Math.min(255, color * 255))) * 4;
        let rgba = [lut[color], lut[color + 1], lut[color + 2], 255];
        if (isNeg) {
          rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255];
        }
        const pti = vec3_exports.fromValues(nodes[edge.first].x, nodes[edge.first].y, nodes[edge.first].z);
        const ptj = vec3_exports.fromValues(nodes[edge.second].x, nodes[edge.second].y, nodes[edge.second].z);
        NiivueObject3D.makeColoredCylinder(pts, tris, rgba255, pti, ptj, radius, rgba);
      }
    }
    const pts32 = new Float32Array(pts);
    const tris32 = new Uint32Array(tris);
    const obj = NVMeshUtilities.getExtents(pts32);
    this.furthestVertexFromOrigin = obj.mxDx;
    this.extentsMin = obj.extentsMin;
    this.extentsMax = obj.extentsMax;
    const posNormClr = this.generatePosNormClr(pts32, tris32, new Uint8Array(rgba255));
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, Uint32Array.from(tris32), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, Float32Array.from(posNormClr), gl.STATIC_DRAW);
    this.indexCount = tris.length;
  }
  updateMesh(gl) {
    this.updateConnectome(gl);
    this.updateLabels();
  }
  json() {
    const json = {};
    for (const prop in this) {
      if (prop in defaultOptions || prop === "nodes" || prop === "edges") {
        json[prop] = this[prop];
      }
    }
    return json;
  }
  /**
   * Factory method to create connectome from options
   */
  static async loadConnectomeFromUrl(gl, url) {
    const response = await fetch(url);
    const json = await response.json();
    return new _NVConnectome(gl, json);
  }
};

// src/niivue/utils.ts
function readFileAsDataURL(input) {
  return new Promise((resolve, reject) => {
    let filePromise;
    if (input instanceof File) {
      filePromise = Promise.resolve(input);
    } else {
      filePromise = new Promise((resolve2, reject2) => {
        input.file(resolve2, reject2);
      });
    }
    filePromise.then((file) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (typeof reader.result === "string") {
          resolve(reader.result);
        } else {
          reject(new Error("Expected a string from FileReader.result"));
        }
      };
      reader.onerror = () => {
        reject(reader.error ?? new Error("Unknown FileReader error"));
      };
      reader.readAsDataURL(file);
    }).catch((err2) => reject(err2));
  });
}
function img2ras16(volume) {
  const dims = volume.hdr.dims;
  const perm = volume.permRAS;
  const vx = dims[1] * dims[2] * dims[3];
  const img16 = new Int16Array(vx);
  const layout = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    for (let j2 = 0; j2 < 3; j2++) {
      if (Math.abs(perm[i]) - 1 !== j2) {
        continue;
      }
      layout[j2] = i * Math.sign(perm[i]);
    }
  }
  let stride = 1;
  const instride = [1, 1, 1];
  const inflip = [false, false, false];
  for (let i = 0; i < layout.length; i++) {
    for (let j2 = 0; j2 < layout.length; j2++) {
      const a = Math.abs(layout[j2]);
      if (a !== i) {
        continue;
      }
      instride[j2] = stride;
      if (layout[j2] < 0 || Object.is(layout[j2], -0)) {
        inflip[j2] = true;
      }
      stride *= dims[j2 + 1];
    }
  }
  let xlut = NVUtilities.range(0, dims[1] - 1, 1);
  if (inflip[0]) {
    xlut = NVUtilities.range(dims[1] - 1, 0, -1);
  }
  for (let i = 0; i < dims[1]; i++) {
    xlut[i] *= instride[0];
  }
  let ylut = NVUtilities.range(0, dims[2] - 1, 1);
  if (inflip[1]) {
    ylut = NVUtilities.range(dims[2] - 1, 0, -1);
  }
  for (let i = 0; i < dims[2]; i++) {
    ylut[i] *= instride[1];
  }
  let zlut = NVUtilities.range(0, dims[3] - 1, 1);
  if (inflip[2]) {
    zlut = NVUtilities.range(dims[3] - 1, 0, -1);
  }
  for (let i = 0; i < dims[3]; i++) {
    zlut[i] *= instride[2];
  }
  let j = 0;
  for (let z = 0; z < dims[3]; z++) {
    for (let y = 0; y < dims[2]; y++) {
      for (let x = 0; x < dims[1]; x++) {
        img16[xlut[x] + ylut[y] + zlut[z]] = volume.img[j];
        j++;
      }
    }
  }
  return img16;
}
function nice(x, round4) {
  const exp = Math.floor(Math.log(x) / Math.log(10));
  const f = x / Math.pow(10, exp);
  let nf;
  if (round4) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 3) {
      nf = 2;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f <= 1) {
      nf = 1;
    } else if (f <= 2) {
      nf = 2;
    } else if (f <= 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  return nf * Math.pow(10, exp);
}
function loose_label(min4, max5, ntick = 4) {
  const range = nice(max5 - min4, false);
  const d = nice(range / (ntick - 1), true);
  const graphmin = Math.floor(min4 / d) * d;
  const graphmax = Math.ceil(max5 / d) * d;
  const perfect = graphmin === min4 && graphmax === max5;
  return [d, graphmin, graphmax, perfect];
}
function tickSpacing(mn, mx) {
  let v = loose_label(mn, mx, 3);
  if (!v[3]) {
    v = loose_label(mn, mx, 5);
  }
  if (!v[3]) {
    v = loose_label(mn, mx, 4);
  }
  if (!v[3]) {
    v = loose_label(mn, mx, 3);
  }
  if (!v[3]) {
    v = loose_label(mn, mx, 5);
  }
  return [v[0], v[1], v[2]];
}
function deg2rad(deg) {
  return deg * (Math.PI / 180);
}
function negMinMax(min4, max5, minNeg, maxNeg) {
  let mn = -min4;
  let mx = -max5;
  if (isFinite(minNeg) && isFinite(maxNeg)) {
    mn = minNeg;
    mx = maxNeg;
  }
  if (mn > mx) {
    ;
    [mn, mx] = [mx, mn];
  }
  return [mn, mx];
}
function swizzleVec3(vec, order = [0, 1, 2]) {
  const vout = vec3_exports.create();
  vout[0] = vec[order[0]];
  vout[1] = vec[order[1]];
  vout[2] = vec[order[2]];
  return vout;
}
function isRadiological(mtx) {
  const vRight = vec4_exports.fromValues(1, 0, 0, 0);
  const vRotated = vec4_exports.create();
  vec4_exports.transformMat4(vRotated, vRight, mtx);
  return vRotated[0];
}
function unProject(winX, winY, winZ, mvpMatrix) {
  const inp = vec4_exports.fromValues(winX, winY, winZ, 1);
  const finalMatrix = mat4_exports.clone(mvpMatrix);
  mat4_exports.invert(finalMatrix, finalMatrix);
  inp[0] = inp[0] * 2 - 1;
  inp[1] = inp[1] * 2 - 1;
  inp[2] = inp[2] * 2 - 1;
  const out = vec4_exports.create();
  vec4_exports.transformMat4(out, inp, finalMatrix);
  if (out[3] === 0) {
    return out;
  }
  out[0] /= out[3];
  out[1] /= out[3];
  out[2] /= out[3];
  return out;
}
function unpackFloatFromVec4i(val) {
  const bitSh = [1 / (256 * 256 * 256), 1 / (256 * 256), 1 / 256, 1];
  return (val[0] * bitSh[0] + val[1] * bitSh[1] + val[2] * bitSh[2] + val[3] * bitSh[3]) / 255;
}
function clamp(value, min4, max5) {
  return Math.min(Math.max(value, min4), max5);
}
function encodeRLE(data) {
  const dl = data.length;
  let dp = 0;
  const r = new Uint8Array(dl + Math.ceil(0.01 * dl));
  const rI = new Int8Array(r.buffer);
  let rp = 0;
  while (dp < dl) {
    let v = data[dp];
    dp++;
    let rl = 1;
    while (rl < 129 && dp < dl && data[dp] === v) {
      dp++;
      rl++;
    }
    if (rl > 1) {
      rI[rp] = -rl + 1;
      rp++;
      r[rp] = v;
      rp++;
      continue;
    }
    while (dp < dl) {
      if (rl > 127) {
        break;
      }
      if (dp + 2 < dl) {
        if (v !== data[dp] && data[dp + 2] === data[dp] && data[dp + 1] === data[dp]) {
          break;
        }
      }
      v = data[dp];
      dp++;
      rl++;
    }
    r[rp] = rl - 1;
    rp++;
    for (let i = 0; i < rl; i++) {
      r[rp] = data[dp - rl + i];
      rp++;
    }
  }
  log.info("PackBits " + dl + " -> " + rp + " bytes (x" + dl / rp + ")");
  return r.slice(0, rp);
}
function decodeRLE(rle, decodedlen) {
  const r = new Uint8Array(rle.buffer);
  const rI = new Int8Array(r.buffer);
  let rp = 0;
  const d = new Uint8Array(decodedlen);
  let dp = 0;
  while (rp < r.length) {
    const hdr = rI[rp];
    rp++;
    if (hdr < 0) {
      const v = rI[rp];
      rp++;
      for (let i = 0; i < 1 - hdr; i++) {
        d[dp] = v;
        dp++;
      }
    } else {
      for (let i = 0; i < hdr + 1; i++) {
        d[dp] = rI[rp];
        rp++;
        dp++;
      }
    }
  }
  return d;
}
function intensityRaw2Scaled(hdr, raw) {
  if (hdr.scl_slope === 0) {
    hdr.scl_slope = 1;
  }
  return raw * hdr.scl_slope + hdr.scl_inter;
}

// src/niivue/index.ts
var MESH_EXTENSIONS = [
  "ASC",
  "BYU",
  "DFS",
  "FSM",
  "PIAL",
  "ORIG",
  "INFLATED",
  "SMOOTHWM",
  "SPHERE",
  "WHITE",
  "G",
  "GEO",
  "GII",
  "ICO",
  "MZ3",
  "NV",
  "OBJ",
  "OFF",
  "PLY",
  "SRF",
  "STL",
  "TCK",
  "TRACT",
  "TRI",
  "TRK",
  "TT",
  "TRX",
  "VTK",
  "WRL",
  "X3D",
  "JCON",
  "JSON"
];
var LEFT_MOUSE_BUTTON = 0;
var CENTER_MOUSE_BUTTON = 1;
var RIGHT_MOUSE_BUTTON = 2;
var TEXTURE0_BACK_VOL = 33984;
var TEXTURE1_COLORMAPS = 33985;
var TEXTURE2_OVERLAY_VOL = 33986;
var TEXTURE3_FONT = 33987;
var TEXTURE4_THUMBNAIL = 33988;
var TEXTURE5_MATCAP = 33989;
var TEXTURE6_GRADIENT = 33990;
var TEXTURE7_DRAW = 33991;
var TEXTURE8_GRADIENT_TEMP = 33992;
var TEXTURE9_ORIENT = 33993;
var TEXTURE10_BLEND = 33994;
var TEXTURE11_GC_BACK = 33995;
var TEXTURE12_GC_STRENGTH0 = 33996;
var TEXTURE13_GC_STRENGTH1 = 33997;
var TEXTURE14_GC_LABEL0 = 33998;
var TEXTURE15_GC_LABEL1 = 33999;
var defaultSaveImageOptions = {
  filename: "",
  isSaveDrawing: false,
  volumeByIndex: 0
};
var Niivue = class {
  /**
   * @param options  - options object to set modifiable Niivue properties
   */
  constructor(options = DEFAULT_OPTIONS) {
    __publicField(this, "loaders", {});
    // create a dicom loader
    __publicField(this, "dicomLoader", null);
    // {
    //   loader: (data: DicomLoaderInput) => {
    //     return new Promise<{name: string; data: ArrayBuffer}[]>((resolve, reject) => {
    //       reject('No DICOM loader provided')
    //     })
    //   },
    //   toExt: 'nii'
    // }
    __publicField(this, "canvas", null);
    // the reference to the canvas element on the page
    __publicField(this, "_gl", null);
    // the gl context
    __publicField(this, "isBusy", false);
    // flag to indicate if the scene is busy drawing
    __publicField(this, "needsRefresh", false);
    // flag to indicate if the scene needs to be redrawn
    __publicField(this, "colormapTexture", null);
    // the GPU memory storage of the colormap
    __publicField(this, "colormapLists", []);
    // one entry per colorbar: min, max, tic
    __publicField(this, "volumeTexture", null);
    // the GPU memory storage of the volume
    __publicField(this, "gradientTexture", null);
    // 3D texture for volume rendering lighting
    __publicField(this, "gradientTextureAmount", 0);
    __publicField(this, "renderGradientValues", false);
    __publicField(this, "drawTexture", null);
    // the GPU memory storage of the drawing
    __publicField(this, "drawUndoBitmaps", []);
    // array of drawBitmaps for undo
    __publicField(this, "drawLut", cmapper.makeDrawLut("$itksnap"));
    // the color lookup table for drawing
    __publicField(this, "drawOpacity", 0.8);
    // opacity of drawing (default)
    __publicField(this, "clickToSegmentIsGrowing", false);
    // flag to indicate if the clickToSegment flood fill growing is in progress with left mouse down + drag
    __publicField(this, "clickToSegmentGrowingBitmap", null);
    // the bitmap of the growing flood fill
    __publicField(this, "clickToSegmentXY", [0, 0]);
    // the x,y location of the clickToSegment flood fill
    __publicField(this, "renderDrawAmbientOcclusion", 0.4);
    __publicField(this, "colorbarHeight", 0);
    // height in pixels, set when colorbar is drawn
    __publicField(this, "drawPenLocation", [NaN, NaN, NaN]);
    __publicField(this, "drawPenAxCorSag", -1);
    // do not allow pen to drag between Sagittal/Coronal/Axial
    __publicField(this, "drawFillOverwrites", true);
    // if true, fill overwrites existing drawing
    __publicField(this, "drawPenFillPts", []);
    // store mouse points for filled pen
    __publicField(this, "overlayTexture", null);
    __publicField(this, "overlayTextureID", null);
    __publicField(this, "sliceMMShader");
    __publicField(this, "sliceV1Shader");
    __publicField(this, "orientCubeShader");
    __publicField(this, "orientCubeShaderVAO", null);
    __publicField(this, "rectShader");
    __publicField(this, "rectOutlineShader");
    __publicField(this, "renderShader");
    __publicField(this, "lineShader");
    __publicField(this, "line3DShader");
    __publicField(this, "passThroughShader");
    __publicField(this, "renderGradientShader");
    __publicField(this, "renderGradientValuesShader");
    __publicField(this, "renderSliceShader");
    __publicField(this, "renderVolumeShader");
    __publicField(this, "pickingMeshShader");
    __publicField(this, "pickingImageShader");
    __publicField(this, "colorbarShader");
    __publicField(this, "fontShader", null);
    __publicField(this, "fiberShader");
    __publicField(this, "fontTexture", null);
    __publicField(this, "circleShader");
    __publicField(this, "matCapTexture", null);
    __publicField(this, "bmpShader", null);
    __publicField(this, "bmpTexture", null);
    // thumbnail WebGLTexture object
    __publicField(this, "thumbnailVisible", false);
    __publicField(this, "bmpTextureWH", 1);
    // thumbnail width/height ratio
    __publicField(this, "growCutShader");
    __publicField(this, "orientShaderAtlasU", null);
    __publicField(this, "orientShaderAtlasI", null);
    __publicField(this, "orientShaderU", null);
    __publicField(this, "orientShaderI", null);
    __publicField(this, "orientShaderF", null);
    __publicField(this, "orientShaderRGBU", null);
    __publicField(this, "surfaceShader", null);
    __publicField(this, "blurShader", null);
    __publicField(this, "sobelBlurShader", null);
    __publicField(this, "sobelFirstOrderShader", null);
    __publicField(this, "sobelSecondOrderShader", null);
    __publicField(this, "genericVAO", null);
    // used for 2D slices, 2D lines, 2D Fonts
    __publicField(this, "unusedVAO", null);
    __publicField(this, "crosshairs3D", null);
    __publicField(this, "DEFAULT_FONT_GLYPH_SHEET", Roboto_Regular_default);
    // "/fonts/Roboto-Regular.png";
    __publicField(this, "DEFAULT_FONT_METRICS", Roboto_Regular_default2);
    // "/fonts/Roboto-Regular.json";
    __publicField(this, "fontMetrics");
    __publicField(this, "fontMets", null);
    __publicField(this, "backgroundMasksOverlays", 0);
    __publicField(this, "overlayOutlineWidth", 0);
    // float, 0 for none
    __publicField(this, "overlayAlphaShader", 1);
    // float, 1 for opaque
    __publicField(this, "position");
    __publicField(this, "extentsMin");
    __publicField(this, "extentsMax");
    // ResizeObserver
    __publicField(this, "resizeObserver", null);
    // syncOpts: Record<string, unknown> = {}
    __publicField(this, "syncOpts", {
      "3d": false,
      // legacy option
      "2d": false,
      // legacy option
      zoomPan: false,
      cal_min: false,
      cal_max: false,
      clipPlane: false,
      gamma: false,
      sliceType: false,
      crosshair: false
    });
    __publicField(this, "readyForSync", false);
    // UI Data
    __publicField(this, "uiData", {
      mousedown: false,
      touchdown: false,
      mouseButtonLeftDown: false,
      mouseButtonCenterDown: false,
      mouseButtonRightDown: false,
      mouseDepthPicker: false,
      clickedTile: -1,
      pan2DxyzmmAtMouseDown: [0, 0, 0, 1],
      prevX: 0,
      prevY: 0,
      currX: 0,
      currY: 0,
      currentTouchTime: 0,
      lastTouchTime: 0,
      touchTimer: null,
      doubleTouch: false,
      isDragging: false,
      dragStart: [0, 0],
      dragEnd: [0, 0],
      dragClipPlaneStartDepthAziElev: [0, 0, 0],
      lastTwoTouchDistance: 0,
      multiTouchGesture: false,
      windowX: 0,
      windowY: 0
    });
    __publicField(this, "back", null);
    // base layer; defines image space to work in. Defined as this.volumes[0] in Niivue.loadVolumes
    __publicField(this, "overlays", []);
    // layers added on top of base image (e.g. masks or stat maps). Essentially everything after this.volumes[0] is an overlay. So is necessary?
    __publicField(this, "deferredVolumes", []);
    __publicField(this, "deferredMeshes", []);
    __publicField(this, "furthestVertexFromOrigin", 100);
    __publicField(this, "volScale", []);
    __publicField(this, "vox", []);
    __publicField(this, "mousePos", [0, 0]);
    __publicField(this, "screenSlices", []);
    // empty array
    __publicField(this, "cuboidVertexBuffer");
    __publicField(this, "otherNV", null);
    // another niivue instance that we wish to sync position with
    __publicField(this, "volumeObject3D", null);
    __publicField(this, "pivot3D", [0, 0, 0]);
    // center for rendering rotation
    __publicField(this, "furthestFromPivot", 10);
    // most distant point from pivot
    __publicField(this, "currentClipPlaneIndex", 0);
    __publicField(this, "lastCalled", (/* @__PURE__ */ new Date()).getTime());
    __publicField(this, "selectedObjectId", -1);
    __publicField(this, "CLIP_PLANE_ID", 1);
    __publicField(this, "VOLUME_ID", 254);
    __publicField(this, "DISTANCE_FROM_CAMERA", -0.54);
    __publicField(this, "graph", {
      LTWH: [0, 0, 640, 480],
      opacity: 0,
      vols: [0],
      // e.g. timeline for background volume only, e.g. [0,2] for first and third volumes
      autoSizeMultiplanar: false,
      normalizeValues: false,
      isRangeCalMinMax: false
    });
    __publicField(this, "meshShaders", [
      {
        Name: "Phong",
        Frag: fragMeshShader
      },
      {
        Name: "Matte",
        Frag: fragMeshMatteShader
      },
      {
        Name: "Harmonic",
        Frag: fragMeshShaderSHBlue
      },
      {
        Name: "Hemispheric",
        Frag: fragMeshHemiShader
      },
      {
        Name: "Crevice",
        Frag: fragMeshShaderCrevice
      },
      {
        Name: "Edge",
        Frag: fragMeshEdgeShader
      },
      {
        Name: "Diffuse",
        Frag: fragMeshDiffuseEdgeShader
      },
      {
        Name: "Outline",
        Frag: fragMeshOutlineShader
      },
      {
        Name: "Specular",
        Frag: fragMeshSpecularEdgeShader
      },
      {
        Name: "Toon",
        Frag: fragMeshToonShader
      },
      {
        Name: "Flat",
        Frag: fragFlatMeshShader
      },
      {
        Name: "Matcap",
        Frag: fragMeshMatcapShader
      }
    ]);
    // TODO just let users use DRAG_MODE instead
    __publicField(this, "dragModes", {
      contrast: 1 /* contrast */,
      measurement: 2 /* measurement */,
      none: 0 /* none */,
      pan: 3 /* pan */,
      slicer3D: 4 /* slicer3D */,
      callbackOnly: 5 /* callbackOnly */
    });
    // TODO just let users use SLICE_TYPE instead
    __publicField(this, "sliceTypeAxial", 0 /* AXIAL */);
    __publicField(this, "sliceTypeCoronal", 1 /* CORONAL */);
    __publicField(this, "sliceTypeSagittal", 2 /* SAGITTAL */);
    __publicField(this, "sliceTypeMultiplanar", 3 /* MULTIPLANAR */);
    __publicField(this, "sliceTypeRender", 4 /* RENDER */);
    // Event listeners
    /**
     * callback function to run when the right mouse button is released after dragging
     * @example
     * niivue.onDragRelease = () => {
     *   console.log('drag ended')
     * }
     */
    __publicField(this, "onDragRelease", () => {
    });
    // function to call when contrast drag is released by default. Can be overridden by user
    /**
     * callback function to run when the left mouse button is released
     * @example
     * niivue.onMouseUp = () => {
     *   console.log('mouse up')
     * }
     */
    __publicField(this, "onMouseUp", () => {
    });
    /**
     * callback function to run when the crosshair location changes
     * @example
     * niivue.onLocationChange = (data) => {
     * console.log('location changed')
     * console.log('mm: ', data.mm)
     * console.log('vox: ', data.vox)
     * console.log('frac: ', data.frac)
     * console.log('values: ', data.values)
     * }
     */
    __publicField(this, "onLocationChange", () => {
    });
    /**
     * callback function to run when the user changes the intensity range with the selection box action (right click)
     * @example
     * niivue.onIntensityChange = (volume) => {
     * console.log('intensity changed')
     * console.log('volume: ', volume)
     * }
     */
    __publicField(this, "onIntensityChange", () => {
    });
    /**
     * callback function when clickToSegment is enabled and the user clicks on the image. data contains the volume of the segmented region in mm3 and mL
     * @example
     * niivue.onClickToSegment = (data) => {
     * console.log('clicked to segment')
     * console.log('volume mm3: ', data.mm3)
     * console.log('volume mL: ', data.mL)
     * }
     */
    __publicField(this, "onClickToSegment", () => {
    });
    /**
     * callback function to run when a new volume is loaded
     * @example
     * niivue.onImageLoaded = (volume) => {
     * console.log('volume loaded')
     * console.log('volume: ', volume)
     * }
     */
    __publicField(this, "onImageLoaded", () => {
    });
    /**
     * callback function to run when a new mesh is loaded
     * @example
     * niivue.onMeshLoaded = (mesh) => {
     * console.log('mesh loaded')
     * console.log('mesh: ', mesh)
     * }
     */
    __publicField(this, "onMeshLoaded", () => {
    });
    /**
     * callback function to run when the user changes the volume when a 4D image is loaded
     * @example
     * niivue.onFrameChange = (volume, frameNumber) => {
     * console.log('frame changed')
     * console.log('volume: ', volume)
     * console.log('frameNumber: ', frameNumber)
     * }
     */
    __publicField(this, "onFrameChange", () => {
    });
    /**
     * callback function to run when niivue reports an error
     * @example
     * niivue.onError = (error) => {
     * console.log('error: ', error)
     * }
     */
    __publicField(this, "onError", () => {
    });
    /// TODO was undocumented
    __publicField(this, "onColormapChange", () => {
    });
    /**
     * callback function to run when niivue reports detailed info
     * @example
     * niivue.onInfo = (info) => {
     * console.log('info: ', info)
     * }
     */
    __publicField(this, "onInfo", () => {
    });
    /**
     * callback function to run when niivue reports a warning
     * @example
     * niivue.onWarn = (warn) => {
     * console.log('warn: ', warn)
     * }
     */
    __publicField(this, "onWarn", () => {
    });
    /**
     * callback function to run when niivue reports a debug message
     * @example
     * niivue.onDebug = (debug) => {
     * console.log('debug: ', debug)
     * }
     */
    __publicField(this, "onDebug", () => {
    });
    /**
     * callback function to run when a volume is added from a url
     * @example
     * niivue.onVolumeAddedFromUrl = (imageOptions, volume) => {
     * console.log('volume added from url')
     * console.log('imageOptions: ', imageOptions)
     * console.log('volume: ', volume)
     * }
     */
    __publicField(this, "onVolumeAddedFromUrl", () => {
    });
    __publicField(this, "onVolumeWithUrlRemoved", () => {
    });
    /**
     * callback function to run when updateGLVolume is called (most users will not need to use
     * @example
     * niivue.onVolumeUpdated = () => {
     * console.log('volume updated')
     * }
     */
    __publicField(this, "onVolumeUpdated", () => {
    });
    /**
     * callback function to run when a mesh is added from a url
     * @example
     * niivue.onMeshAddedFromUrl = (meshOptions, mesh) => {
     * console.log('mesh added from url')
     * console.log('meshOptions: ', meshOptions)
     * console.log('mesh: ', mesh)
     * }
     */
    __publicField(this, "onMeshAddedFromUrl", () => {
    });
    // TODO seems redundant with onMeshLoaded
    __publicField(this, "onMeshAdded", () => {
    });
    __publicField(this, "onMeshWithUrlRemoved", () => {
    });
    // not implemented anywhere...
    __publicField(this, "onZoom3DChange", () => {
    });
    /**
     * callback function to run when the user changes the rotation of the 3D rendering
     * @example
     * niivue.onAzimuthElevationChange = (azimuth, elevation) => {
     * console.log('azimuth: ', azimuth)
     * console.log('elevation: ', elevation)
     * }
     */
    __publicField(this, "onAzimuthElevationChange", () => {
    });
    /**
     * callback function to run when the user changes the clip plane
     * @example
     * niivue.onClipPlaneChange = (clipPlane) => {
     * console.log('clipPlane: ', clipPlane)
     * }
     */
    __publicField(this, "onClipPlaneChange", () => {
    });
    __publicField(this, "onCustomMeshShaderAdded", () => {
    });
    __publicField(this, "onMeshShaderChanged", () => {
    });
    __publicField(this, "onMeshPropertyChanged", () => {
    });
    __publicField(this, "onDicomLoaderFinishedWithImages", () => {
    });
    /**
     * callback function to run when the user loads a new NiiVue document
     * @example
     * niivue.onDocumentLoaded = (document) => {
     * console.log('document: ', document)
     * }
     */
    __publicField(this, "onDocumentLoaded", () => {
    });
    __publicField(this, "document", new NVDocument());
    __publicField(this, "mediaUrlMap", /* @__PURE__ */ new Map());
    __publicField(this, "initialized", false);
    __publicField(this, "currentDrawUndoBitmap");
    for (const name in options) {
      if (typeof options[name] === "function") {
        this[name] = options[name];
      } else {
        this.opts[name] = DEFAULT_OPTIONS[name] === void 0 ? DEFAULT_OPTIONS[name] : options[name];
      }
    }
    if (this.opts.forceDevicePixelRatio === 0) {
      this.uiData.dpr = window.devicePixelRatio || 1;
    } else if (this.opts.forceDevicePixelRatio < 0) {
      this.uiData.dpr = 1;
    } else {
      this.uiData.dpr = this.opts.forceDevicePixelRatio;
    }
    this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps;
    if (this.opts.drawingEnabled) {
      this.createEmptyDrawing();
    }
    if (this.opts.thumbnail.length > 0) {
      this.thumbnailVisible = true;
    }
    log.setLogLevel(this.opts.logLevel);
  }
  get scene() {
    return this.document.scene;
  }
  get opts() {
    return this.document.opts;
  }
  get sliceMosaicString() {
    return this.document.opts.sliceMosaicString || "";
  }
  set sliceMosaicString(newSliceMosaicString) {
    this.document.opts.sliceMosaicString = newSliceMosaicString;
  }
  get isAlphaClipDark() {
    return this.document.opts.isAlphaClipDark;
  }
  set isAlphaClipDark(newVal) {
    this.document.opts.isAlphaClipDark = newVal;
  }
  get volumes() {
    return this.document.volumes;
  }
  set volumes(volumes) {
    this.document.volumes = volumes;
  }
  get meshes() {
    return this.document.meshes;
  }
  set meshes(meshes) {
    this.document.meshes = meshes;
  }
  get drawBitmap() {
    return this.document.drawBitmap;
  }
  set drawBitmap(drawBitmap) {
    this.document.drawBitmap = drawBitmap;
  }
  get volScaleMultiplier() {
    return this.scene.volScaleMultiplier;
  }
  set volScaleMultiplier(scale6) {
    this.setScale(scale6);
  }
  /**
   * save webgl2 canvas as png format bitmap
   * @param filename - filename for screen capture
   * @example niivue.saveScene('test.png');
   * @see {@link https://niivue.github.io/niivue/features/ui.html | live demo usage}
   */
  async saveScene(filename = "niivue.png") {
    function saveBlob(blob, name) {
      const a = document.createElement("a");
      document.body.appendChild(a);
      a.style.display = "none";
      const url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = name;
      a.click();
      a.remove();
    }
    const canvas = this.canvas;
    if (!canvas) {
      throw new Error("canvas not defined");
    }
    this.drawScene();
    canvas.toBlob((blob) => {
      if (!blob) {
        return;
      }
      if (filename === "") {
        filename = `niivue-screenshot-${(/* @__PURE__ */ new Date()).toString()}.png`;
        filename = filename.replace(/\s/g, "_");
      }
      saveBlob(blob, filename);
    });
  }
  /**
   * attach the Niivue instance to the webgl2 canvas by element id
   * @param id - the id of an html canvas element
   * @param isAntiAlias - determines if anti-aliasing is requested (if not specified, AA usage depends on hardware)
   * @example niivue = new Niivue().attachTo('gl')
   * @example await niivue.attachTo('gl')
   * @see {@link https://niivue.github.io/niivue/features/basic.multiplanar.html | live demo usage}
   */
  async attachTo(id, isAntiAlias = null) {
    await this.attachToCanvas(document.getElementById(id), isAntiAlias);
    log.debug("attached to element with id: ", id);
    return this;
  }
  /**
   * attach the Niivue instance to a canvas element directly
   * @param canvas - the canvas element reference
   * @example
   * niivue = new Niivue()
   * await niivue.attachToCanvas(document.getElementById(id))
   */
  async attachToCanvas(canvas, isAntiAlias = null) {
    this.canvas = canvas;
    if (isAntiAlias === null) {
      isAntiAlias = navigator.hardwareConcurrency > 6;
      log.debug("AntiAlias ", isAntiAlias, " Threads ", navigator.hardwareConcurrency);
    }
    this.gl = this.canvas.getContext("webgl2", {
      alpha: true,
      antialias: isAntiAlias
    });
    log.info("NIIVUE VERSION ", version);
    this.canvas.parentElement.style.backgroundColor = "black";
    if (this.opts.isResizeCanvas) {
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      this.canvas.style.display = "block";
      this.canvas.width = this.canvas.offsetWidth;
      this.canvas.height = this.canvas.offsetHeight;
      window.addEventListener("resize", () => {
        requestAnimationFrame(() => {
          this.resizeListener();
        });
      });
      this.resizeObserver = new ResizeObserver(() => {
        requestAnimationFrame(() => {
          this.resizeListener();
        });
      });
      this.resizeObserver.observe(this.canvas.parentElement);
    }
    if (this.opts.interactive) {
      this.registerInteractions();
    }
    await this.init();
    this.drawScene();
    return this;
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to another. useful for using one canvas to drive another.
   * @param otherNV - the other Niivue instance that is the main controller
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue2.syncWith(niivue1)
   * @deprecated use broadcastTo instead
   * @see {@link https://niivue.github.io/niivue/features/sync.mesh.html | live demo usage}
   */
  syncWith(otherNV, syncOpts = { "2d": true, "3d": true }) {
    if (!(otherNV instanceof Array)) {
      otherNV = [otherNV];
    }
    this.otherNV = otherNV;
    this.syncOpts = { ...syncOpts };
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to others. useful for using one canvas to drive another.
   * @param otherNV - the other Niivue instance(s)
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue3 = new Niivue()
   * niivue1.broadcastTo(niivue2)
   * niivue1.broadcastTo([niivue2, niivue3])
   * @see {@link https://niivue.github.io/niivue/features/sync.mesh.html | live demo usage}
   */
  broadcastTo(otherNV, syncOpts = { "2d": true, "3d": true }) {
    if (!(otherNV instanceof Array)) {
      otherNV = [otherNV];
    }
    this.otherNV = otherNV;
    this.syncOpts = syncOpts;
  }
  doSync3d(otherNV) {
    otherNV.scene.renderAzimuth = this.scene.renderAzimuth;
    otherNV.scene.renderElevation = this.scene.renderElevation;
    otherNV.scene.volScaleMultiplier = this.scene.volScaleMultiplier;
  }
  // both crosshair and zoomPan
  doSync2d(otherNV) {
    const thisMM = this.frac2mm(this.scene.crosshairPos);
    otherNV.scene.crosshairPos = otherNV.mm2frac(thisMM);
    otherNV.scene.pan2Dxyzmm = vec4_exports.clone(this.scene.pan2Dxyzmm);
  }
  doSyncGamma(otherNV) {
    const thisGamma = this.scene.gamma;
    const otherGamma = otherNV.scene.gamma;
    if (thisGamma !== otherGamma) {
      otherNV.setGamma(thisGamma);
    }
  }
  doSyncZoomPan(otherNV) {
    otherNV.scene.pan2Dxyzmm = vec4_exports.clone(this.scene.pan2Dxyzmm);
  }
  doSyncCrosshair(otherNV) {
    const thisMM = this.frac2mm(this.scene.crosshairPos);
    otherNV.scene.crosshairPos = otherNV.mm2frac(thisMM);
  }
  doSyncCalMin(otherNV) {
    if (this.volumes[0].cal_min !== otherNV.volumes[0].cal_min) {
      otherNV.volumes[0].cal_min = this.volumes[0].cal_min;
      otherNV.updateGLVolume();
    }
  }
  doSyncCalMax(otherNV) {
    if (this.volumes[0].cal_max !== otherNV.volumes[0].cal_max) {
      otherNV.volumes[0].cal_max = this.volumes[0].cal_max;
      otherNV.updateGLVolume();
    }
  }
  doSyncSliceType(otherNV) {
    otherNV.setSliceType(this.opts.sliceType);
  }
  doSyncClipPlane(otherNV) {
    otherNV.setClipPlane(this.scene.clipPlaneDepthAziElev);
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to another. useful for using one canvas to drive another.
   * @internal
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue2.syncWith(niivue1)
   * niivue2.sync()
   */
  sync() {
    if (!this.gl || !this.otherNV || typeof this.otherNV === "undefined") {
      return;
    }
    if (!this.gl.canvas.matches(":focus")) {
      return;
    }
    for (let i = 0; i < this.otherNV.length; i++) {
      if (this.otherNV[i] === this) {
        continue;
      }
      if (this.syncOpts.gamma) {
        this.doSyncGamma(this.otherNV[i]);
      }
      if (this.syncOpts.crosshair) {
        this.doSyncCrosshair(this.otherNV[i]);
      }
      if (this.syncOpts.zoomPan) {
        this.doSyncZoomPan(this.otherNV[i]);
      }
      if (this.syncOpts.sliceType) {
        this.doSyncSliceType(this.otherNV[i]);
      }
      if (this.syncOpts.cal_min) {
        this.doSyncCalMin(this.otherNV[i]);
      }
      if (this.syncOpts.cal_max) {
        this.doSyncCalMax(this.otherNV[i]);
      }
      if (this.syncOpts.clipPlane) {
        this.doSyncClipPlane(this.otherNV[i]);
      }
      if (this.syncOpts["2d"]) {
        this.doSync2d(this.otherNV[i]);
      }
      if (this.syncOpts["3d"]) {
        this.doSync3d(this.otherNV[i]);
      }
      this.otherNV[i].drawScene();
      this.otherNV[i].createOnLocationChange();
    }
  }
  /** Not documented publicly for now
   * test if two arrays have equal values for each element
   * @param a - the first array
   * @param b - the second array
   * @example Niivue.arrayEquals(a, b)
   *
   * TODO this should maybe just use array-equal from NPM
   */
  arrayEquals(a, b) {
    return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]);
  }
  /**
   * callback function to handle resize window events, redraws the scene.
   * @internal
   */
  resizeListener() {
    if (!this.canvas || !this.gl) {
      return;
    }
    if (!this.opts.isResizeCanvas) {
      if (this.opts.forceDevicePixelRatio >= 0) {
        log.warn("this.opts.forceDevicePixelRatio requires isResizeCanvas");
      }
      this.drawScene();
      return;
    }
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this.canvas.style.display = "block";
    if (this.opts.forceDevicePixelRatio === 0) {
      this.uiData.dpr = window.devicePixelRatio || 1;
    } else if (this.opts.forceDevicePixelRatio < 0) {
      this.uiData.dpr = 1;
    } else {
      this.uiData.dpr = this.opts.forceDevicePixelRatio;
    }
    log.debug("devicePixelRatio: " + this.uiData.dpr);
    if ("width" in this.canvas.parentElement) {
      this.canvas.width = this.canvas.parentElement.width * this.uiData.dpr;
      this.canvas.height = this.canvas.parentElement.height * this.uiData.dpr;
    } else {
      this.canvas.width = this.canvas.offsetWidth * this.uiData.dpr;
      this.canvas.height = this.canvas.offsetHeight * this.uiData.dpr;
    }
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    this.drawScene();
  }
  /* Not included in public docs
   * The following two functions are to address offset issues
   * https://stackoverflow.com/questions/42309715/how-to-correctly-pass-mouse-coordinates-to-webgl
   * note:  no test yet
   */
  /**
   * callback to handle mouse move events relative to the canvas
   * @internal
   * @returns the mouse position relative to the canvas
   */
  getRelativeMousePosition(event, target) {
    target = target || event.target;
    if (!target) {
      return;
    }
    const rect = target.getBoundingClientRect();
    return {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    };
  }
  // not included in public docs
  // assumes target or event.target is canvas
  // note: no test yet
  getNoPaddingNoBorderCanvasRelativeMousePosition(event, target) {
    target = target || event.target;
    const pos = this.getRelativeMousePosition(event, target);
    return pos;
  }
  // not included in public docs
  // handler for context menu (right click)
  // here, we disable the normal context menu so that
  // we can use some custom right click events
  // note: no test yet
  mouseContextMenuListener(e) {
    e.preventDefault();
  }
  // not included in public docs
  // handler for all mouse button presses
  // note: no test yet
  mouseDownListener(e) {
    e.preventDefault();
    this.drawPenLocation = [NaN, NaN, NaN];
    this.drawPenAxCorSag = -1;
    this.uiData.mousedown = true;
    this.setDragStart(0, 0);
    this.setDragEnd(0, 0);
    log.debug("mouse down");
    log.debug(e);
    const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
    if (!pos) {
      return;
    }
    const [x, y] = [pos.x * this.uiData.dpr, pos.y * this.uiData.dpr];
    if (this.opts.clickToSegment) {
      this.clickToSegmentXY = [x, y];
    }
    const label = this.getLabelAtPoint([x, y]);
    if (label) {
      if (label.onClick) {
        label.onClick(label);
        return;
      }
      for (const mesh of this.meshes) {
        if (mesh.type !== "connectome" /* CONNECTOME */) {
          continue;
        }
        for (const node of mesh.nodes) {
          if (node.label === label) {
            this.scene.crosshairPos = this.mm2frac([node.x, node.y, node.z]);
            this.updateGLVolume();
            this.drawScene();
          }
        }
      }
    }
    this.uiData.clickedTile = this.tileIndex(x, y);
    if (e.button === LEFT_MOUSE_BUTTON && e.shiftKey) {
      this.uiData.mouseButtonCenterDown = true;
      this.mouseCenterButtonHandler(e);
    } else if (e.button === LEFT_MOUSE_BUTTON) {
      this.uiData.mouseButtonLeftDown = true;
      this.mouseLeftButtonHandler(e);
    } else if (e.button === RIGHT_MOUSE_BUTTON) {
      this.uiData.mouseButtonRightDown = true;
      this.mouseRightButtonHandler(e);
    } else if (e.button === CENTER_MOUSE_BUTTON) {
      this.uiData.mouseButtonCenterDown = true;
      this.mouseCenterButtonHandler(e);
    }
  }
  // not included in public docs
  // handler for mouse left button down
  // note: no test yet
  mouseLeftButtonHandler(e) {
    if (e.ctrlKey || this.opts.dragModePrimary === 0 /* crosshair */) {
      const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
      this.mouseDown(pos.x, pos.y);
      this.mouseClick(pos.x, pos.y);
    } else if (this.opts.dragModePrimary === 1 /* windowing */) {
      this.uiData.windowX = e.x;
      this.uiData.windowY = e.y;
    }
  }
  // not included in public docs
  // handler for mouse center button down
  // note: no test yet
  mouseCenterButtonHandler(e) {
    const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
    this.mousePos = [pos.x * this.uiData.dpr, pos.y * this.uiData.dpr];
    if (this.opts.dragMode === 0 /* none */) {
      return;
    }
    this.setDragStart(pos.x, pos.y);
    if (!this.uiData.isDragging) {
      this.uiData.pan2DxyzmmAtMouseDown = vec4_exports.clone(this.scene.pan2Dxyzmm);
    }
    this.uiData.isDragging = true;
    this.uiData.dragClipPlaneStartDepthAziElev = this.scene.clipPlaneDepthAziElev;
  }
  // not included in public docs
  // handler for mouse right button down
  // note: no test yet
  mouseRightButtonHandler(e) {
    const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
    this.mousePos = [pos.x * this.uiData.dpr, pos.y * this.uiData.dpr];
    if (this.opts.dragMode === 0 /* none */) {
      return;
    }
    this.setDragStart(pos.x, pos.y);
    if (!this.uiData.isDragging) {
      this.uiData.pan2DxyzmmAtMouseDown = vec4_exports.clone(this.scene.pan2Dxyzmm);
    }
    this.uiData.isDragging = true;
    this.uiData.dragClipPlaneStartDepthAziElev = this.scene.clipPlaneDepthAziElev;
  }
  /**
   * calculate the the min and max voxel indices from an array of two values (used in selecting intensities with the selection box)
   * @param array - an array of two values
   * @returns an array of two values representing the min and max voxel indices
   */
  calculateMinMaxVoxIdx(array) {
    if (array.length > 2) {
      throw new Error("array must not contain more than two values");
    }
    return [Math.floor(Math.min(array[0], array[1])), Math.floor(Math.max(array[0], array[1]))];
  }
  // not included in public docs
  // note: no test yet
  calculateNewRange({ volIdx = 0 } = {}) {
    if (this.opts.sliceType === 4 /* RENDER */ && this.sliceMosaicString.length < 1) {
      return;
    }
    if (this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1]) {
      return;
    }
    let frac = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]);
    if (frac[0] < 0) {
      return;
    }
    const startVox = this.frac2vox(frac, volIdx);
    frac = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
    if (frac[0] < 0) {
      return;
    }
    const endVox = this.frac2vox(frac, volIdx);
    let hi = -Number.MAX_VALUE;
    let lo = Number.MAX_VALUE;
    const xrange = this.calculateMinMaxVoxIdx([startVox[0], endVox[0]]);
    const yrange = this.calculateMinMaxVoxIdx([startVox[1], endVox[1]]);
    const zrange = this.calculateMinMaxVoxIdx([startVox[2], endVox[2]]);
    if (startVox[0] - endVox[0] === 0) {
      xrange[1] = startVox[0] + 1;
    } else if (startVox[1] - endVox[1] === 0) {
      yrange[1] = startVox[1] + 1;
    } else if (startVox[2] - endVox[2] === 0) {
      zrange[1] = startVox[2] + 1;
    }
    const hdr = this.volumes[volIdx].hdr;
    const img = this.volumes[volIdx].img;
    if (!hdr || !img) {
      return;
    }
    const xdim = hdr.dims[1];
    const ydim = hdr.dims[2];
    for (let z = zrange[0]; z < zrange[1]; z++) {
      const zi = z * xdim * ydim;
      for (let y = yrange[0]; y < yrange[1]; y++) {
        const yi = y * xdim;
        for (let x = xrange[0]; x < xrange[1]; x++) {
          const index = zi + yi + x;
          if (lo > img[index]) {
            lo = img[index];
          }
          if (hi < img[index]) {
            hi = img[index];
          }
        }
      }
    }
    if (lo >= hi) {
      return;
    }
    const mnScale = intensityRaw2Scaled(hdr, lo);
    const mxScale = intensityRaw2Scaled(hdr, hi);
    this.volumes[volIdx].cal_min = mnScale;
    this.volumes[volIdx].cal_max = mxScale;
    this.onIntensityChange(this.volumes[volIdx]);
  }
  generateMouseUpCallback(fracStart, fracEnd) {
    const tileStart = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
    const tileEnd = this.tileIndex(this.uiData.dragEnd[0], this.uiData.dragEnd[1]);
    let tileIdx = -1;
    if (tileStart === tileEnd) {
      tileIdx = tileEnd;
    }
    let axCorSag = -1;
    if (tileIdx >= 0) {
      axCorSag = this.screenSlices[tileIdx].axCorSag;
    }
    const mmStart = this.frac2mm(fracStart);
    const mmEnd = this.frac2mm(fracEnd);
    const v = vec3_exports.create();
    vec3_exports.sub(v, vec3_exports.fromValues(mmStart[0], mmStart[1], mmStart[2]), vec3_exports.fromValues(mmEnd[0], mmEnd[1], mmEnd[2]));
    const mmLength = vec3_exports.len(v);
    const voxStart = this.frac2vox(fracStart);
    const voxEnd = this.frac2vox(fracEnd);
    this.onDragRelease({
      fracStart,
      fracEnd,
      voxStart,
      voxEnd,
      mmStart,
      mmEnd,
      mmLength,
      tileIdx,
      axCorSag
    });
  }
  // not included in public docs
  // handler for mouse button up (all buttons)
  // note: no test yet
  mouseUpListener() {
    function isFunction(test) {
      return Object.prototype.toString.call(test).indexOf("Function") > -1;
    }
    const uiData = {
      mouseButtonRightDown: this.uiData.mouseButtonRightDown,
      mouseButtonCenterDown: this.uiData.mouseButtonCenterDown,
      isDragging: this.uiData.isDragging,
      mousePos: this.mousePos,
      fracPos: this.canvasPos2frac(this.mousePos)
      // xyzMM: this.frac2mm(fracPos),
    };
    this.uiData.mousedown = false;
    this.uiData.mouseButtonRightDown = false;
    const wasCenterDown = this.uiData.mouseButtonCenterDown;
    this.uiData.mouseButtonCenterDown = false;
    this.uiData.mouseButtonLeftDown = false;
    if (this.drawPenFillPts.length > 0) {
      this.drawPenFilled();
    } else if (this.drawPenAxCorSag >= 0) {
      if (this.opts.clickToSegment) {
        const sumBitmap = this.sumBitmap(this.drawBitmap);
        const sumSeg = this.sumBitmap(this.clickToSegmentGrowingBitmap);
        if (sumSeg > sumBitmap) {
          this.updateBitmapFromClickToSegment();
        }
      }
    }
    this.drawAddUndoBitmap();
    this.drawPenLocation = [NaN, NaN, NaN];
    this.drawPenAxCorSag = -1;
    if (isFunction(this.onMouseUp)) {
      this.onMouseUp(uiData);
    }
    if (this.uiData.isDragging) {
      this.uiData.isDragging = false;
      if (this.opts.dragMode === 5 /* callbackOnly */) {
        this.drawScene();
      }
      const fracStart = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]);
      const fracEnd = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
      this.generateMouseUpCallback(fracStart, fracEnd);
      if (this.opts.dragMode === 6 /* roiSelection */) {
        return;
      }
      if (this.opts.dragMode !== 1 /* contrast */) {
        return;
      }
      if (wasCenterDown) {
        return;
      }
      if (this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1]) {
        return;
      }
      this.calculateNewRange({ volIdx: 0 });
      this.refreshLayers(this.volumes[0], 0);
    }
    this.drawScene();
  }
  // not included in public docs
  checkMultitouch(e) {
    if (this.uiData.touchdown && !this.uiData.multiTouchGesture) {
      const rect = this.canvas.getBoundingClientRect();
      this.mouseDown(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      this.mouseClick(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }
  }
  // not included in public docs
  // handler for single finger touch event (like mouse down)
  // note: no test yet
  touchStartListener(e) {
    e.preventDefault();
    if (!this.uiData.touchTimer) {
      this.uiData.touchTimer = setTimeout(() => {
        this.resetBriCon(e);
      }, this.opts.longTouchTimeout);
    }
    this.uiData.touchdown = true;
    this.uiData.currentTouchTime = (/* @__PURE__ */ new Date()).getTime();
    const timeSinceTouch = this.uiData.currentTouchTime - this.uiData.lastTouchTime;
    if (timeSinceTouch < this.opts.doubleTouchTimeout && timeSinceTouch > 0) {
      this.uiData.doubleTouch = true;
      this.setDragStart(
        e.targetTouches[0].clientX - e.target.getBoundingClientRect().left,
        e.targetTouches[0].clientY - e.target.getBoundingClientRect().top
      );
      this.resetBriCon(e);
      this.uiData.lastTouchTime = this.uiData.currentTouchTime;
      return;
    } else {
      this.uiData.doubleTouch = false;
      this.setDragStart(0, 0);
      this.setDragEnd(0, 0);
      this.uiData.lastTouchTime = this.uiData.currentTouchTime;
    }
    if (this.uiData.touchdown && e.touches.length < 2) {
      this.uiData.multiTouchGesture = false;
    } else {
      this.uiData.multiTouchGesture = true;
    }
    setTimeout(this.checkMultitouch.bind(this), 1, e);
  }
  // not included in public docs
  // handler for touchend (finger lift off screen)
  // note: no test yet
  touchEndListener(e) {
    e.preventDefault();
    this.uiData.touchdown = false;
    this.uiData.lastTwoTouchDistance = 0;
    this.uiData.multiTouchGesture = false;
    if (this.uiData.touchTimer) {
      clearTimeout(this.uiData.touchTimer);
      this.uiData.touchTimer = null;
    }
    if (this.uiData.isDragging) {
      this.uiData.isDragging = false;
      if (this.opts.dragMode === 1 /* contrast */) {
        this.calculateNewRange();
        this.refreshLayers(this.volumes[0], 0);
      }
      const fracStart = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]);
      const fracEnd = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
      this.generateMouseUpCallback(fracStart, fracEnd);
    }
    this.mouseUpListener();
  }
  windowingHandler(x, y, volIdx = 0) {
    const wx = this.uiData.windowX;
    const wy = this.uiData.windowY;
    let mn = this.volumes[0].cal_min;
    let mx = this.volumes[0].cal_max;
    const gmn = this.volumes[0].global_min;
    const gmx = this.volumes[0].global_max;
    if (y < wy) {
      mn += 1;
      mx += 1;
    } else if (y > wy) {
      mn -= 1;
      mx -= 1;
    }
    if (x > wx) {
      mn -= 1;
      mx += 1;
    } else if (x < wx) {
      mn += 1;
      mx -= 1;
    }
    if (mx - mn < 1) {
      mx = mn + 1;
    }
    if (mn < gmn) {
      mn = gmn;
    }
    if (mx > gmx) {
      mx = gmx;
    }
    if (mn > mx) {
      mn = mx - 1;
    }
    this.volumes[volIdx].cal_min = mn;
    this.volumes[volIdx].cal_max = mx;
    this.refreshLayers(this.volumes[volIdx], 0);
    this.uiData.windowX = x;
    this.uiData.windowY = y;
  }
  // not included in public docs
  // handler for mouse move over canvas
  // note: no test yet
  mouseMoveListener(e) {
    if (this.uiData.mousedown) {
      const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
      if (!pos) {
        return;
      }
      const x = pos.x * this.uiData.dpr;
      const y = pos.y * this.uiData.dpr;
      const tile = this.tileIndex(x, y);
      if (tile !== this.uiData.clickedTile) {
        return;
      }
      if (this.uiData.mouseButtonLeftDown) {
        const isCrosshairMode = this.opts.dragModePrimary === 0 /* crosshair */;
        const isWindowingMode = this.opts.dragModePrimary === 1 /* windowing */;
        const ctrlKey = e.ctrlKey;
        if (ctrlKey || isCrosshairMode) {
          this.mouseMove(pos.x, pos.y);
          this.mouseClick(pos.x, pos.y);
        } else if (isWindowingMode) {
          this.windowingHandler(e.x, e.y);
        }
      } else if (this.uiData.mouseButtonRightDown || this.uiData.mouseButtonCenterDown) {
        this.setDragEnd(pos.x, pos.y);
      }
      this.drawScene();
      this.uiData.prevX = this.uiData.currX;
      this.uiData.prevY = this.uiData.currY;
    } else if (!this.uiData.mousedown && this.opts.clickToSegment) {
      const pos = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
      if (!pos) {
        return;
      }
      const x = pos.x * this.uiData.dpr;
      const y = pos.y * this.uiData.dpr;
      this.mousePos = [x, y];
      this.drawScene();
    }
  }
  // not included in public docs
  // note: should update this to accept a volume index to reset a selected volume rather than only the background (TODO)
  // reset brightness and contrast to global min and max
  // note: no test yet
  resetBriCon(msg = null) {
    if (this.uiData.isDragging) {
      return;
    }
    let isRender = false;
    if (this.opts.sliceType === 4 /* RENDER */) {
      isRender = true;
    }
    let x = 0;
    let y = 0;
    if (msg !== null) {
      if ("targetTouches" in msg) {
        x = msg.targetTouches[0].clientX - msg.target.getBoundingClientRect().left;
        y = msg.targetTouches[0].clientY - msg.target.getBoundingClientRect().top;
      } else {
        x = msg.offsetX;
        y = msg.offsetY;
      }
      x *= this.uiData.dpr;
      y *= this.uiData.dpr;
      if (this.inRenderTile(x, y) >= 0) {
        isRender = true;
      }
    }
    if (isRender) {
      this.uiData.mouseDepthPicker = true;
      this.drawScene();
      this.drawScene();
      return;
    }
    if (this.opts.dragMode === 4 /* slicer3D */) {
      return;
    }
    if (this.volumes.length < 1) {
      return;
    }
    if (this.uiData.doubleTouch) {
      return;
    }
    this.volumes[0].cal_min = this.volumes[0].robust_min;
    this.volumes[0].cal_max = this.volumes[0].robust_max;
    this.onIntensityChange(this.volumes[0]);
    this.refreshLayers(this.volumes[0], 0);
    this.drawScene();
  }
  setDragStart(x, y) {
    x *= this.uiData.dpr;
    y *= this.uiData.dpr;
    this.uiData.dragStart[0] = x;
    this.uiData.dragStart[1] = y;
  }
  setDragEnd(x, y) {
    x *= this.uiData.dpr;
    y *= this.uiData.dpr;
    this.uiData.dragEnd[0] = x;
    this.uiData.dragEnd[1] = y;
  }
  // not included in public docs
  // handler for touch move (moving finger on screen)
  // note: no test yet
  touchMoveListener(e) {
    if (this.uiData.touchdown && e.touches.length < 2) {
      const rect = this.canvas.getBoundingClientRect();
      if (!this.uiData.isDragging) {
        this.uiData.pan2DxyzmmAtMouseDown = vec4_exports.clone(this.scene.pan2Dxyzmm);
      }
      this.uiData.isDragging = true;
      if (this.uiData.doubleTouch && this.uiData.isDragging) {
        this.setDragEnd(
          e.targetTouches[0].clientX - e.target.getBoundingClientRect().left,
          e.targetTouches[0].clientY - e.target.getBoundingClientRect().top
        );
        this.drawScene();
        return;
      }
      const isCrosshairMode = this.opts.dragModePrimary === 0 /* crosshair */;
      const isWindowingMode = this.opts.dragModePrimary === 1 /* windowing */;
      if (isCrosshairMode) {
        this.mouseClick(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
        this.mouseMove(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      } else if (isWindowingMode) {
        this.windowingHandler(e.touches[0].pageX, e.touches[0].pageY);
        this.drawScene();
      }
    } else {
      this.handlePinchZoom(e);
    }
  }
  // not included in public docs
  handlePinchZoom(e) {
    if (e.targetTouches.length === 2 && e.changedTouches.length === 2) {
      const dist4 = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
      const rect = this.canvas.getBoundingClientRect();
      this.mousePos = [e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top];
      if (dist4 < this.uiData.lastTwoTouchDistance) {
        this.sliceScroll2D(-0.01, e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      } else {
        this.sliceScroll2D(0.01, e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      }
      this.uiData.lastTwoTouchDistance = dist4;
    }
  }
  // not included in public docs
  // handler for keyboard shortcuts
  keyUpListener(e) {
    if (e.code === this.opts.clipPlaneHotKey) {
      const now = (/* @__PURE__ */ new Date()).getTime();
      const elapsed = now - this.lastCalled;
      if (elapsed > this.opts.keyDebounceTime) {
        this.currentClipPlaneIndex = (this.currentClipPlaneIndex + 1) % 7;
        switch (this.currentClipPlaneIndex) {
          case 0:
            this.scene.clipPlaneDepthAziElev = [2, 0, 0];
            break;
          case 1:
            this.scene.clipPlaneDepthAziElev = [0, 270, 0];
            break;
          case 2:
            this.scene.clipPlaneDepthAziElev = [0, 90, 0];
            break;
          case 3:
            this.scene.clipPlaneDepthAziElev = [0, 0, 0];
            break;
          case 4:
            this.scene.clipPlaneDepthAziElev = [0, 180, 0];
            break;
          case 5:
            this.scene.clipPlaneDepthAziElev = [0, 0, -90];
            break;
          case 6:
            this.scene.clipPlaneDepthAziElev = [0, 0, 90];
            break;
        }
        this.setClipPlane(this.scene.clipPlaneDepthAziElev);
      }
      this.lastCalled = now;
    } else if (e.code === this.opts.viewModeHotKey) {
      const now = (/* @__PURE__ */ new Date()).getTime();
      const elapsed = now - this.lastCalled;
      if (elapsed > this.opts.keyDebounceTime) {
        this.setSliceType((this.opts.sliceType + 1) % 5);
        this.lastCalled = now;
      }
    }
  }
  keyDownListener(e) {
    if (e.code === "KeyH" && this.opts.sliceType === 4 /* RENDER */) {
      this.setRenderAzimuthElevation(this.scene.renderAzimuth - 1, this.scene.renderElevation);
    } else if (e.code === "KeyL" && this.opts.sliceType === 4 /* RENDER */) {
      this.setRenderAzimuthElevation(this.scene.renderAzimuth + 1, this.scene.renderElevation);
    } else if (e.code === "KeyJ" && this.opts.sliceType === 4 /* RENDER */) {
      this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation + 1);
    } else if (e.code === "KeyK" && this.opts.sliceType === 4 /* RENDER */) {
      this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation - 1);
    } else if (e.code === "KeyH" && this.opts.sliceType !== 4 /* RENDER */) {
      this.moveCrosshairInVox(-1, 0, 0);
    } else if (e.code === "KeyL" && this.opts.sliceType !== 4 /* RENDER */) {
      this.moveCrosshairInVox(1, 0, 0);
    } else if (e.code === "KeyU" && this.opts.sliceType !== 4 /* RENDER */ && e.ctrlKey) {
      this.moveCrosshairInVox(0, 0, 1);
    } else if (e.code === "KeyD" && this.opts.sliceType !== 4 /* RENDER */ && e.ctrlKey) {
      this.moveCrosshairInVox(0, 0, -1);
    } else if (e.code === "KeyJ" && this.opts.sliceType !== 4 /* RENDER */) {
      this.moveCrosshairInVox(0, -1, 0);
    } else if (e.code === "KeyK" && this.opts.sliceType !== 4 /* RENDER */) {
      this.moveCrosshairInVox(0, 1, 0);
    } else if (e.code === "KeyM" && this.opts.sliceType !== 4 /* RENDER */) {
      this.opts.dragMode++;
      if (this.opts.dragMode >= 4 /* slicer3D */) {
        this.opts.dragMode = 0 /* none */;
      }
      log.info("drag mode changed to ", DRAG_MODE[this.opts.dragMode]);
    } else if (e.code === "ArrowLeft") {
      this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D - 1);
    } else if (e.code === "ArrowRight") {
      this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D + 1);
    } else if (e.code === "Slash" && e.shiftKey) {
      alert(`NIIVUE VERSION: ${version}`);
    }
  }
  // not included in public docs
  // handler for scroll wheel events (slice scrolling)
  // note: no test yet
  wheelListener(e) {
    e.preventDefault();
    e.stopPropagation();
    if (this.thumbnailVisible) {
      return;
    }
    const dragStartSum = this.uiData.dragStart.reduce((a, b) => a + b, 0);
    const dragEndSum = this.uiData.dragEnd.reduce((a, b) => a + b, 0);
    const validDrag = dragStartSum > 0 && dragEndSum > 0;
    if (this.opts.dragMode === 6 /* roiSelection */ && validDrag) {
      const delta = e.deltaY > 0 ? 1 : -1;
      if (this.uiData.dragStart[0] < this.uiData.dragEnd[0]) {
        this.uiData.dragStart[0] -= delta;
        this.uiData.dragEnd[0] += delta;
      } else {
        this.uiData.dragStart[0] += delta;
        this.uiData.dragEnd[0] -= delta;
      }
      if (this.uiData.dragStart[1] < this.uiData.dragEnd[1]) {
        this.uiData.dragStart[1] -= delta;
        this.uiData.dragEnd[1] += delta;
      } else {
        this.uiData.dragStart[1] += delta;
        this.uiData.dragEnd[1] -= delta;
      }
      this.uiData.isDragging = true;
      this.drawScene();
      this.uiData.isDragging = false;
      const tileIdx = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
      this.generateMouseUpCallback(
        this.screenXY2TextureFrac(this.uiData.dragStart[0], this.uiData.dragStart[1], tileIdx),
        this.screenXY2TextureFrac(this.uiData.dragEnd[0], this.uiData.dragEnd[1], tileIdx)
      );
      return;
    }
    const rect = this.canvas.getBoundingClientRect();
    if (e.deltaY < 0) {
      this.sliceScroll2D(-0.01, e.clientX - rect.left, e.clientY - rect.top);
    } else {
      this.sliceScroll2D(0.01, e.clientX - rect.left, e.clientY - rect.top);
    }
  }
  // not included in public docs
  // setup interactions with the canvas. Mouse clicks and touches
  // note: no test yet
  registerInteractions() {
    if (!this.canvas) {
      throw new Error("canvas undefined");
    }
    this.canvas.addEventListener("mousedown", this.mouseDownListener.bind(this));
    this.canvas.addEventListener("mouseup", this.mouseUpListener.bind(this));
    this.canvas.addEventListener("mousemove", this.mouseMoveListener.bind(this));
    this.canvas.addEventListener("touchstart", this.touchStartListener.bind(this));
    this.canvas.addEventListener("touchend", this.touchEndListener.bind(this));
    this.canvas.addEventListener("touchmove", this.touchMoveListener.bind(this));
    this.canvas.addEventListener("wheel", this.wheelListener.bind(this));
    this.canvas.addEventListener("contextmenu", this.mouseContextMenuListener.bind(this));
    this.canvas.addEventListener("dblclick", this.resetBriCon.bind(this));
    this.canvas.addEventListener("dragenter", this.dragEnterListener.bind(this), false);
    this.canvas.addEventListener("dragover", this.dragOverListener.bind(this), false);
    this.canvas.addEventListener("drop", this.dropListener.bind(this), false);
    this.canvas.setAttribute("tabindex", "0");
    this.canvas.addEventListener("keyup", this.keyUpListener.bind(this), false);
    this.canvas.addEventListener("keydown", this.keyDownListener.bind(this), false);
  }
  // not included in public docs
  dragEnterListener(e) {
    e.stopPropagation();
    e.preventDefault();
  }
  // not included in public docs
  dragOverListener(e) {
    e.stopPropagation();
    e.preventDefault();
  }
  // not included in public docs
  getFileExt(fullname, upperCase = true) {
    log.debug("fullname: ", fullname);
    const re = /(?:\.([^.]+))?$/;
    let ext = re.exec(fullname)[1];
    ext = ext.toUpperCase();
    if (ext === "GZ") {
      ext = re.exec(fullname.slice(0, -3))[1];
      ext = ext.toUpperCase();
    } else if (ext === "CBOR") {
      const endExt = ext;
      ext = re.exec(fullname.slice(0, -5))[1];
      ext = ext.toUpperCase();
      ext = `${ext}.${endExt}`;
    }
    return upperCase ? ext : ext.toLowerCase();
  }
  /**
   * Add an image and notify subscribers
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  async addVolumeFromUrl(imageOptions) {
    const volume = await NVImage.loadFromUrl(imageOptions);
    this.document.addImageOptions(volume, imageOptions);
    volume.onColormapChange = this.onColormapChange;
    this.mediaUrlMap.set(volume, imageOptions.url);
    if (this.onVolumeAddedFromUrl) {
      this.onVolumeAddedFromUrl(imageOptions, volume);
    }
    this.addVolume(volume);
    return volume;
  }
  async addVolumesFromUrl(imageOptionsArray) {
    const promises = imageOptionsArray.map(async (imageItem) => {
      const ext = this.getFileExt(imageItem.name || imageItem.url);
      if (ext === "DCM") {
        throw new Error("DICOM files must be loaded using useDicomLoader");
      }
      if (this.loaders[ext]) {
        let itemToLoad = imageItem.url;
        const toExt = this.loaders[ext].toExt;
        let name = imageItem.name || imageItem.url;
        name = name.split("/").pop();
        if (typeof imageItem.url === "string") {
          const url = imageItem.url;
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to load file: ${response.statusText}`);
            }
            itemToLoad = await response.arrayBuffer();
          } catch (error) {
            throw new Error(`Failed to load url ${url}: ${error}`);
          }
        }
        const buffer = await this.loaders[ext].loader(itemToLoad);
        imageItem.url = buffer;
        imageItem.name = `${name}.${toExt}`;
      }
      const imageOptions = {
        url: imageItem.url,
        headers: imageItem.headers,
        name: imageItem.name,
        colormap: imageItem.colormap ? imageItem.colormap : imageItem.colorMap,
        colormapNegative: imageItem.colormapNegative ? imageItem.colormapNegative : imageItem.colorMapNegative,
        opacity: imageItem.opacity,
        urlImgData: imageItem.urlImgData,
        cal_min: imageItem.cal_min,
        cal_max: imageItem.cal_max,
        trustCalMinMax: this.opts.trustCalMinMax,
        isManifest: imageItem.isManifest,
        frame4D: imageItem.frame4D,
        limitFrames4D: imageItem.limitFrames4D || this.opts.limitFrames4D,
        colorbarVisible: imageItem.colorbarVisible
      };
      const volume = await NVImage.loadFromUrl(imageOptions);
      this.document.addImageOptions(volume, imageOptions);
      volume.onColormapChange = this.onColormapChange;
      this.mediaUrlMap.set(volume, imageOptions.url);
      if (this.onVolumeAddedFromUrl) {
        this.onVolumeAddedFromUrl(imageOptions, volume);
      }
      return volume;
    });
    const volumes = await Promise.all(promises);
    for (let i = 0; i < volumes.length; i++) {
      this.addVolume(volumes[i]);
    }
    return volumes;
  }
  /**
   * Find media by url
   */
  getMediaByUrl(url) {
    return [...this.mediaUrlMap.entries()].filter((v) => v[1] === url).map((v) => v[0]).pop();
  }
  /**
   * Remove volume by url
   * @param url - Volume added by url to remove
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  removeVolumeByUrl(url) {
    const volume = this.getMediaByUrl(url);
    if (volume) {
      this.removeVolume(volume);
    } else {
      throw new Error("No volume with URL present");
    }
  }
  async traverseFileTree(item, path = "", fileArray) {
    return new Promise((resolve) => {
      if (item.isFile) {
        item.file((file) => {
          file.fullPath = path + file.name;
          file._webkitRelativePath = path + file.name;
          fileArray.push(file);
          resolve(fileArray);
        });
      } else if (item.isDirectory) {
        const dirReader = item.createReader();
        const readAllEntries = () => {
          dirReader.readEntries((entries) => {
            if (entries.length > 0) {
              const promises = [];
              for (const entry of entries) {
                promises.push(this.traverseFileTree(entry, path + item.name + "/", fileArray));
              }
              Promise.all(promises).then(readAllEntries).catch((e) => {
                throw e;
              });
            } else {
              resolve(fileArray);
            }
          });
        };
        readAllEntries();
      }
    });
  }
  readDirectory(directory) {
    const reader = directory.createReader();
    let allEntiresInDir = [];
    const getFileObjects = async (fileSystemEntries) => {
      const allFileObects = [];
      const getFile = async (fileEntry) => {
        return new Promise((resolve, reject) => fileEntry.file(resolve, reject));
      };
      for (let i = 0; i < fileSystemEntries.length; i++) {
        allFileObects.push(await getFile(fileSystemEntries[i]));
        console.log(allFileObects);
      }
      return allFileObects;
    };
    const readEntries = () => {
      reader.readEntries((entries) => {
        if (entries.length) {
          allEntiresInDir = allEntiresInDir.concat(entries);
          readEntries();
        } else {
          getFileObjects(allEntiresInDir).then(async (allFileObjects) => {
            console.log(allFileObjects);
          }).catch((e) => {
            throw e;
          });
        }
      });
    };
    readEntries();
    return allEntiresInDir;
  }
  /**
   * Returns boolean: true if filename ends with mesh extension (TRK, pial, etc)
   * @param url - filename
   */
  isMeshExt(url) {
    const ext = this.getFileExt(url);
    log.debug("dropped ext");
    log.debug(ext);
    return MESH_EXTENSIONS.includes(ext);
  }
  /**
   * Load an image or mesh from an array buffer
   * @param buffer - ArrayBuffer with the entire contents of a mesh or volume
   * @param name - string of filename, extension used to infer type (NIfTI, MGH, MZ3, etc)
   * @see {@link http://192.168.0.150:8080/features/draganddrop.html | live demo usage}
   */
  async loadFromArrayBuffer(buffer, name) {
    const ext = this.getFileExt(name);
    if (MESH_EXTENSIONS.includes(ext)) {
      await this.addMeshFromUrl({ url: name, buffer });
      return;
    }
    const imageOptions = NVImageFromUrlOptions(name);
    imageOptions.buffer = buffer;
    imageOptions.name = name;
    await this.addVolumeFromUrl(imageOptions);
  }
  /**
   * Load a mesh or image from a file object
   * @param file - File object
   */
  async loadFromFile(file) {
    const ext = this.getFileExt(file.name);
    if (MESH_EXTENSIONS.includes(ext)) {
      await NVMesh3.loadFromFile({ file, gl: this.gl, name: file.name }).then((mesh) => {
        this.addMesh(mesh);
      });
      return;
    }
    await NVImage.loadFromFile({
      file,
      name: file.name
    }).then((volume) => {
      this.addVolume(volume);
    });
  }
  /* useLoader
  
    registers an external file loader for niivue to use when reading files.
  
    the loader must return an array buffer of the file contents for niivue
    to parse and the extension of the file so niivue can infer the file type to load. 
  
    example: 
  
    const myCustomLoader = (File) => {
      // ... do parsing here ...
      return {
        arrayBuffer: ArrayBuffer,
        fileExt: 'iwi.cbor',
        positions: Float32Array | [], // allows for mesh loading to mz3
        indices: Uint32Array | [], // allows for mesh loading to mz3
      }
  
    nv.useLoader({
      loader: myCustomLoader,
      fileExt: 'iwi.cbor',
      toExt: 'nii'
    })
  
    */
  // interface LoaderMap {
  //   [key: string]: {
  //     loader: LoaderFunction;
  //     toExt: string;
  //   };
  // }
  // Example usage:
  // const loaderMap: LoaderMap = {
  //   'TXT': { loader: (file: File) => file.text(), toExt: 'json' }
  // };
  // loader can either be a function that takes a file or ArrayBuffer, or the async version of that.
  useLoader(loader, fileExt, toExt) {
    this.loaders = {
      ...this.loaders,
      [fileExt.toUpperCase()]: {
        loader,
        toExt
      }
    };
  }
  useDicomLoader(loader) {
    this.dicomLoader = loader;
  }
  getDicomLoader() {
    return this.dicomLoader;
  }
  // dicom loading is a special case because it can take a list
  // of files (e.g. from a user supplied DICOM directory) or a single file.
  // Our preferred DICOM loader is the WASM port of dcm2niix (implemented in a separate niivue loader module).
  // useDicomLoader(loader: unknown, toExt: string) {
  //   this.loaders = {
  //     ...this.loaders,
  //     ['DCM']: {
  //       loader,
  //       toExt,
  //     },
  //   }
  // }
  // not included in public docs
  async dropListener(e) {
    e.stopPropagation();
    e.preventDefault();
    if (!this.opts.dragAndDropEnabled) {
      return;
    }
    const urlsToLoad = [];
    const files = [];
    const dt = e.dataTransfer;
    if (!dt) {
      return;
    }
    const url = dt.getData("text/uri-list");
    if (url) {
      urlsToLoad.push(url);
      const imageOptions = NVImageFromUrlOptions(url);
      const ext = this.getFileExt(url);
      log.debug("dropped ext");
      log.debug(ext);
      if (MESH_EXTENSIONS.includes(ext)) {
        this.addMeshFromUrl({ url }).catch((e2) => {
          throw e2;
        });
      } else if (ext === "NVD") {
        this.loadDocumentFromUrl(url).catch((e2) => {
          throw e2;
        });
      } else {
        this.addVolumeFromUrl(imageOptions).catch((e2) => {
          throw e2;
        });
      }
    } else {
      const items = dt.items;
      if (items.length > 0) {
        if (!e.shiftKey && !e.altKey) {
          this.volumes = [];
          this.overlays = [];
          this.meshes = [];
        }
        this.closeDrawing();
        for (const item of Array.from(items)) {
          const entry = item.webkitGetAsEntry();
          log.debug(entry);
          if (!entry) {
            throw new Error("could not get entry from file");
          }
          if (entry.isFile) {
            const ext = this.getFileExt(entry.name);
            let pairedImageData;
            if (entry.name.lastIndexOf("HEAD") !== -1) {
              for (const pairedItem of Array.from(items)) {
                const pairedEntry = pairedItem.webkitGetAsEntry();
                if (!pairedEntry) {
                  throw new Error("could not get paired entry");
                }
                const fileBaseName = entry.name.substring(0, entry.name.lastIndexOf("HEAD"));
                const pairedItemBaseName = pairedEntry.name.substring(0, pairedEntry.name.lastIndexOf("BRIK"));
                if (fileBaseName === pairedItemBaseName) {
                  pairedImageData = pairedEntry;
                }
              }
            }
            if (entry.name.lastIndexOf("BRIK") !== -1) {
              continue;
            }
            if (this.loaders[ext]) {
              const dataUrl = await readFileAsDataURL(entry);
              await this.loadImages([
                {
                  url: dataUrl,
                  name: `${entry.name}`
                }
              ]);
              continue;
            }
            if (MESH_EXTENSIONS.includes(ext)) {
              ;
              entry.file((file) => {
                ;
                (async () => {
                  try {
                    const mesh = await NVMesh3.loadFromFile({
                      file,
                      gl: this.gl,
                      name: file.name
                    });
                    this.addMesh(mesh);
                  } catch (e2) {
                    console.error("Error loading mesh:", e2);
                  }
                })().catch((err2) => console.error(err2));
              });
              continue;
            } else if (ext === "NVD") {
              ;
              entry.file((file) => {
                ;
                (async () => {
                  try {
                    const nvdoc = await NVDocument.loadFromFile(file);
                    await this.loadDocument(nvdoc);
                    log.debug("loaded document");
                  } catch (e2) {
                    console.error(e2);
                  }
                })().catch((err2) => console.error(err2));
              });
              break;
            }
            ;
            entry.file((file) => {
              ;
              (async () => {
                try {
                  if (pairedImageData) {
                    ;
                    pairedImageData.file((imgfile) => {
                      ;
                      (async () => {
                        try {
                          const volume = await NVImage.loadFromFile({
                            file,
                            urlImgData: imgfile,
                            limitFrames4D: this.opts.limitFrames4D
                          });
                          this.addVolume(volume);
                        } catch (e2) {
                          console.error(e2);
                        }
                      })().catch(console.error);
                    });
                  } else {
                    const volume = await NVImage.loadFromFile({
                      file,
                      urlImgData: pairedImageData,
                      limitFrames4D: this.opts.limitFrames4D
                    });
                    if (e.altKey) {
                      log.debug("alt key detected: assuming this is a drawing overlay");
                      this.drawClearAllUndoBitmaps();
                      this.loadDrawing(volume);
                    } else {
                      this.addVolume(volume);
                    }
                  }
                } catch (e2) {
                  console.error(e2);
                }
              })().catch(console.error);
            });
          } else if (entry.isDirectory) {
            this.traverseFileTree(entry, "", files).then((files2) => {
              const loader = this.getDicomLoader().loader;
              if (!loader) {
                throw new Error("No loader for DICOM files");
              }
              loader(files2).then(async (fileArrayBuffers) => {
                console.log(fileArrayBuffers);
                const promises = fileArrayBuffers.map(
                  (loaderImage) => NVImage.loadFromUrl({
                    url: loaderImage.data,
                    name: loaderImage.name,
                    limitFrames4D: this.opts.limitFrames4D
                  })
                );
                Promise.all(promises).then(async (loadedNvImages) => {
                  console.log("from dicom loader");
                  console.log(loadedNvImages);
                  await this.onDicomLoaderFinishedWithImages(loadedNvImages);
                }).catch((e2) => {
                  throw e2;
                });
              }).catch((error) => {
                console.error("Error loading DICOM files:", error);
              });
            }).catch((e2) => {
              throw e2;
            });
          }
        }
      }
    }
    this.drawScene();
  }
  /**
   * insert a gap between slices of a mutliplanar view.
   * @param pixels - spacing between tiles of multiplanar view
   * @example niivue.setMultiplanarPadPixels(4)
   * @see {@link https://niivue.github.io/niivue/features/atlas.html | live demo usage}
   */
  setMultiplanarPadPixels(pixels) {
    this.opts.multiplanarPadPixels = pixels;
    this.drawScene();
  }
  /**
   * control placement of 2D slices.
   * @param layout - AUTO: 0, COLUMN: 1, GRID: 2, ROW: 3,
   * @example niivue.setMultiplanarLayout(2)
   * @see {@link https://niivue.github.io/niivue/features/layout.html | live demo usage}
   */
  setMultiplanarLayout(layout) {
    if (typeof layout === "string") {
      layout = parseInt(layout);
    }
    this.opts.multiplanarLayout = layout;
    this.drawScene();
  }
  /**
   * determine if text appears at corner (true) or sides of 2D slice.
   * @param isCornerOrientationText - controls position of text
   * @example niivue.setCornerOrientationText(true)
   * @see {@link https://niivue.github.io/niivue/features/worldspace2.html | live demo usage}
   */
  setCornerOrientationText(isCornerOrientationText) {
    this.opts.isCornerOrientationText = isCornerOrientationText;
    this.updateGLVolume();
  }
  /**
   * determine proportion of screen real estate devoted to rendering in multiplanar view.
   * @param fraction - proportion of screen devoted to primary (hero) image (0 to disable)
   * @example niivue.setHeroImage(0.5)
   * @see {@link https://niivue.github.io/niivue/features/layout.html | live demo usage}
   */
  setHeroImage(fraction) {
    this.opts.heroImageFraction = fraction;
    this.drawScene();
  }
  /**
   * control whether 2D slices use radiological or neurological convention.
   * @param isRadiologicalConvention - new display convention
   * @example niivue.setRadiologicalConvention(true)
   * @see {@link https://niivue.github.io/niivue/features/worldspace.html | live demo usage}
   */
  setRadiologicalConvention(isRadiologicalConvention) {
    this.opts.isRadiologicalConvention = isRadiologicalConvention;
    this.updateGLVolume();
  }
  /**
   * Reset scene to default settings.
   * @param options - @see NiiVueOptions
   * @param resetBriCon - also reset contrast (default false).
   * @example niivue.nv1.setDefaults(opts, true);
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  setDefaults(options = {}, resetBriCon = false) {
    this.document.opts = { ...DEFAULT_OPTIONS };
    this.scene.sceneData = { ...INITIAL_SCENE_DATA };
    for (const name in options) {
      if (typeof options[name] === "function") {
        this[name] = options[name];
      } else {
        this.opts[name] = DEFAULT_OPTIONS[name] === void 0 ? DEFAULT_OPTIONS[name] : options[name];
      }
    }
    this.scene.pan2Dxyzmm = [0, 0, 0, 1];
    if (resetBriCon && this.volumes && this.volumes.length > 0) {
      for (let i = 0; i < this.volumes.length; i++) {
        this.volumes[i].cal_min = this.volumes[i].robust_min;
        this.volumes[i].cal_max = this.volumes[i].robust_max;
      }
    }
    this.updateGLVolume();
  }
  /**
   * Limit visibility of mesh in front of a 2D image. Requires world-space mode.
   * @param meshThicknessOn2D - distance from voxels for clipping mesh. Use Infinity to show entire mesh or 0.0 to hide mesh.
   * @example niivue.setMeshThicknessOn2D(42)
   * @see {@link https://niivue.github.io/niivue/features/worldspace2.html | live demo usage}
   */
  setMeshThicknessOn2D(meshThicknessOn2D) {
    this.opts.meshThicknessOn2D = meshThicknessOn2D;
    this.updateGLVolume();
  }
  /**
   * Create a custom multi-slice mosaic (aka lightbox, montage) view.
   * @param str - description of mosaic.
   * @example niivue.setSliceMosaicString("A 0 20 C 30 S 42")
   * @see {@link https://niivue.github.io/niivue/features/mosaics.html | live demo usage}
   */
  setSliceMosaicString(str6) {
    this.sliceMosaicString = str6;
    this.updateGLVolume();
  }
  /**
   * control 2D slice view mode.
   * @param isSliceMM - control whether 2D slices use world space (true) or voxel space (false). Beware that voxel space mode limits properties like panning, zooming and mesh visibility.
   * @example niivue.setSliceMM(true)
   * @see {@link https://niivue.github.io/niivue/features/worldspace2.html | live demo usage}
   */
  setSliceMM(isSliceMM) {
    this.opts.isSliceMM = isSliceMM;
    this.updateGLVolume();
  }
  /**
   * control whether voxel overlays are combined using additive (emission) or traditional (transmission) blending.
   * @param isAdditiveBlend - emission (true) or transmission (false) mixing
   * @example niivue.isAdditiveBlend(true)
   * @see {@link https://niivue.github.io/niivue/features/additive.voxels.html | live demo usage}
   */
  setAdditiveBlend(isAdditiveBlend) {
    this.opts.isAdditiveBlend = isAdditiveBlend;
    this.updateGLVolume();
  }
  /**
   * Detect if display is using radiological or neurological convention.
   * @returns radiological convention status
   * @example let rc = niivue.getRadiologicalConvention()
   */
  getRadiologicalConvention() {
    return this.opts.isRadiologicalConvention;
  }
  /**
   * Force WebGL canvas to use high resolution display, regardless of browser defaults.
   * @param forceDevicePixelRatio - -1: block high DPI; 0= allow high DPI: >0 use specified pixel ratio
   * @example niivue.setHighResolutionCapable(true);
   * @see {@link https://niivue.github.io/niivue/features/sync.mesh.html | live demo usage}
   */
  setHighResolutionCapable(forceDevicePixelRatio) {
    if (typeof forceDevicePixelRatio === "boolean") {
      forceDevicePixelRatio = forceDevicePixelRatio ? 0 : -1;
    }
    this.opts.forceDevicePixelRatio = forceDevicePixelRatio;
    this.resizeListener();
    this.drawScene();
  }
  /**
   * add a new volume to the canvas
   * @param volume - the new volume to add to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.addVolume(NVImage.loadFromUrl({url:'../someURL.nii.gz'}))
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  addVolume(volume) {
    this.volumes.push(volume);
    const idx = this.volumes.length === 1 ? 0 : this.volumes.length - 1;
    this.setVolume(volume, idx);
    this.onImageLoaded(volume);
    log.debug("loaded volume", volume.name);
    log.debug(volume);
  }
  /**
   * add a new mesh to the canvas
   * @param mesh - the new mesh to add to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.addMesh(NVMesh.loadFromUrl({url:'../someURL.gii'}))
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  addMesh(mesh) {
    this.meshes.push(mesh);
    const idx = this.meshes.length === 1 ? 0 : this.meshes.length - 1;
    this.setMesh(mesh, idx);
    this.onMeshLoaded(mesh);
  }
  /**
   * get the index of a volume by its unique id. unique ids are assigned to the NVImage.id property when a new NVImage is created.
   * @param id - the id string to search for
   * @example
   * niivue = new Niivue()
   * niivue.getVolumeIndexByID(someVolume.id)
   */
  getVolumeIndexByID(id) {
    const n = this.volumes.length;
    for (let i = 0; i < n; i++) {
      const id_i = this.volumes[i].id;
      if (id_i === id) {
        return i;
      }
    }
    return -1;
  }
  // not included in public docs
  // Internal function to store drawings that can be used for undo operations
  drawAddUndoBitmap() {
    if (!this.drawBitmap || this.drawBitmap.length < 1) {
      log.debug("drawAddUndoBitmap error: No drawing open");
      return;
    }
    this.currentDrawUndoBitmap++;
    if (this.currentDrawUndoBitmap >= this.opts.maxDrawUndoBitmaps) {
      this.currentDrawUndoBitmap = 0;
    }
    this.drawUndoBitmaps[this.currentDrawUndoBitmap] = encodeRLE(this.drawBitmap);
  }
  // not included in public docs
  // Internal function to delete all drawing undo images
  drawClearAllUndoBitmaps() {
    this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps;
    if (!this.drawUndoBitmaps || this.drawUndoBitmaps.length < 1) {
      return;
    }
    for (let i = this.drawUndoBitmaps.length - 1; i >= 0; i--) {
      this.drawUndoBitmaps[i] = new Uint8Array();
    }
  }
  /**
   * Restore drawing to previous state
   * @example niivue.drawUndo();
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  drawUndo() {
    if (this.drawUndoBitmaps.length < 1) {
      log.debug("undo bitmaps not loaded");
      return;
    }
    this.currentDrawUndoBitmap--;
    if (this.currentDrawUndoBitmap < 0) {
      this.currentDrawUndoBitmap = this.drawUndoBitmaps.length - 1;
    }
    if (this.currentDrawUndoBitmap >= this.drawUndoBitmaps.length) {
      this.currentDrawUndoBitmap = 0;
    }
    if (this.drawUndoBitmaps[this.currentDrawUndoBitmap].length < 2) {
      log.debug("drawUndo is misbehaving");
      return;
    }
    this.drawBitmap = decodeRLE(this.drawUndoBitmaps[this.currentDrawUndoBitmap], this.drawBitmap.length);
    this.refreshDrawing(true);
  }
  // not included in public docs
  loadDrawing(drawingBitmap) {
    if (this.drawBitmap) {
      log.debug("Overwriting open drawing!");
    }
    if (!this.back) {
      throw new Error("back undefined");
    }
    this.drawClearAllUndoBitmaps();
    const dims = drawingBitmap.hdr.dims;
    if (dims[1] !== this.back.hdr.dims[1] || dims[2] !== this.back.hdr.dims[2] || dims[3] !== this.back.hdr.dims[3]) {
      log.debug("drawing dimensions do not match background image");
      return false;
    }
    if (drawingBitmap.img.constructor !== Uint8Array) {
      log.debug("Drawings should be UINT8");
    }
    const perm = drawingBitmap.permRAS;
    const vx = dims[1] * dims[2] * dims[3];
    this.drawBitmap = new Uint8Array(vx);
    this.drawTexture = this.r8Tex(this.drawTexture, TEXTURE7_DRAW, this.back.dims, true);
    const layout = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      for (let j2 = 0; j2 < 3; j2++) {
        if (Math.abs(perm[i]) - 1 !== j2) {
          continue;
        }
        layout[j2] = i * Math.sign(perm[i]);
      }
    }
    let stride = 1;
    const instride = [1, 1, 1];
    const inflip = [false, false, false];
    for (let i = 0; i < layout.length; i++) {
      for (let j2 = 0; j2 < layout.length; j2++) {
        const a = Math.abs(layout[j2]);
        if (a !== i) {
          continue;
        }
        instride[j2] = stride;
        if (layout[j2] < 0 || Object.is(layout[j2], -0)) {
          inflip[j2] = true;
        }
        stride *= dims[j2 + 1];
      }
    }
    let xlut = NVUtilities.range(0, dims[1] - 1, 1);
    if (inflip[0]) {
      xlut = NVUtilities.range(dims[1] - 1, 0, -1);
    }
    for (let i = 0; i < dims[1]; i++) {
      xlut[i] *= instride[0];
    }
    let ylut = NVUtilities.range(0, dims[2] - 1, 1);
    if (inflip[1]) {
      ylut = NVUtilities.range(dims[2] - 1, 0, -1);
    }
    for (let i = 0; i < dims[2]; i++) {
      ylut[i] *= instride[1];
    }
    let zlut = NVUtilities.range(0, dims[3] - 1, 1);
    if (inflip[2]) {
      zlut = NVUtilities.range(dims[3] - 1, 0, -1);
    }
    for (let i = 0; i < dims[3]; i++) {
      zlut[i] *= instride[2];
    }
    const inVs = drawingBitmap.img;
    const outVs = this.drawBitmap;
    let j = 0;
    for (let z = 0; z < dims[3]; z++) {
      for (let y = 0; y < dims[2]; y++) {
        for (let x = 0; x < dims[1]; x++) {
          outVs[xlut[x] + ylut[y] + zlut[z]] = inVs[j];
          j++;
        }
      }
    }
    this.drawAddUndoBitmap();
    this.refreshDrawing(false);
    this.drawScene();
    return true;
  }
  // not included in public docs
  binarize(volume) {
    const dims = volume.hdr.dims;
    const vx = dims[1] * dims[2] * dims[3];
    const img = new Uint8Array(vx);
    for (let i = 0; i < vx; i++) {
      if (volume.img[i] !== 0) {
        img[i] = 1;
      }
    }
    volume.img = img;
    volume.hdr.datatypeCode = 2 /* DT_UINT8 */;
    volume.hdr.cal_min = 0;
    volume.hdr.cal_max = 1;
  }
  /**
   * Open drawing
   * @param filename - of NIfTI format drawing
   * @param isBinarize - if true will force drawing voxels to be either 0 or 1.
   * @example niivue.loadDrawingFromUrl("../images/lesion.nii.gz");
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  async loadDrawingFromUrl(fnm, isBinarize = false) {
    if (this.drawBitmap) {
      log.debug("Overwriting open drawing!");
    }
    this.drawClearAllUndoBitmaps();
    let ok = false;
    try {
      const volume = await NVImage.loadFromUrl(NVImageFromUrlOptions(fnm));
      if (isBinarize) {
        await this.binarize(volume);
      }
      ok = this.loadDrawing(volume);
    } catch (err2) {
      log.error("loadDrawingFromUrl() failed to load " + fnm);
      this.drawClearAllUndoBitmaps();
    }
    return ok;
  }
  // not included in public docs
  findOtsu(mlevel = 2) {
    if (this.volumes.length < 1) {
      return [];
    }
    const img = this.volumes[0].img;
    const nvox = img.length;
    if (nvox < 1) {
      return [];
    }
    const nBin = 256;
    const maxBin = nBin - 1;
    const h = new Array(nBin).fill(0);
    const mn = this.volumes[0].cal_min;
    const mx = this.volumes[0].cal_max;
    if (mx <= mn) {
      return [];
    }
    const scale2raw = (mx - mn) / nBin;
    function bin2raw(bin) {
      return bin * scale2raw + mn;
    }
    const scale2bin = (nBin - 1) / Math.abs(mx - mn);
    const inter = this.volumes[0].hdr.scl_inter;
    const slope = this.volumes[0].hdr.scl_slope;
    for (let v = 0; v < nvox; v++) {
      let val = img[v] * slope + inter;
      val = Math.min(Math.max(val, mn), mx);
      val = Math.round((val - mn) * scale2bin);
      h[val]++;
    }
    const P = Array(nBin).fill(0).map(() => Array(nBin).fill(0));
    const S = Array(nBin).fill(0).map(() => Array(nBin).fill(0));
    for (let i = 1; i < nBin; ++i) {
      P[i][i] = h[i];
      S[i][i] = i * h[i];
    }
    for (let i = 1; i < nBin - 1; ++i) {
      P[1][i + 1] = P[1][i] + h[i + 1];
      S[1][i + 1] = S[1][i] + (i + 1) * h[i + 1];
    }
    for (let i = 2; i < nBin; i++) {
      for (let j = i + 1; j < nBin; j++) {
        P[i][j] = P[1][j] - P[1][i - 1];
        S[i][j] = S[1][j] - S[1][i - 1];
      }
    }
    for (let i = 1; i < nBin; ++i) {
      for (let j = i + 1; j < nBin; j++) {
        if (P[i][j] !== 0) {
          P[i][j] = S[i][j] * S[i][j] / P[i][j];
        }
      }
    }
    let max5 = 0;
    const t = [Infinity, Infinity, Infinity];
    if (mlevel > 3) {
      for (let l = 0; l < nBin - 3; l++) {
        for (let m = l + 1; m < nBin - 2; m++) {
          for (let h2 = m + 1; h2 < nBin - 1; h2++) {
            const v = P[0][l] + P[l + 1][m] + P[m + 1][h2] + P[h2 + 1][maxBin];
            if (v > max5) {
              t[0] = l;
              t[1] = m;
              t[2] = h2;
              max5 = v;
            }
          }
        }
      }
    } else if (mlevel === 3) {
      for (let l = 0; l < nBin - 2; l++) {
        for (let h2 = l + 1; h2 < nBin - 1; h2++) {
          const v = P[0][l] + P[l + 1][h2] + P[h2 + 1][maxBin];
          if (v > max5) {
            t[0] = l;
            t[1] = h2;
            max5 = v;
          }
        }
      }
    } else {
      for (let i = 0; i < nBin - 1; i++) {
        const v = P[0][i] + P[i + 1][maxBin];
        if (v > max5) {
          t[0] = i;
          max5 = v;
        }
      }
    }
    return [bin2raw(t[0]), bin2raw(t[1]), bin2raw(t[2])];
  }
  /**
   * remove dark voxels in air
   * @param levels - (2-4) segment brain into this many types. For example drawOtsu(2) will create a binary drawing where bright voxels are colored and dark voxels are clear.
   * @example niivue.drawOtsu(3);
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  drawOtsu(levels = 2) {
    if (this.volumes.length === 0) {
      return;
    }
    const nvox = this.volumes[0].img.length;
    const thresholds = this.findOtsu(levels);
    if (thresholds.length < 3) {
      return;
    }
    if (!this.drawBitmap) {
      this.createEmptyDrawing();
    }
    const drawImg = this.drawBitmap;
    const img = this.volumes[0].img;
    for (let i = 0; i < nvox; i++) {
      if (drawImg[i] !== 0) {
        continue;
      }
      const v = img[i];
      if (v > thresholds[0]) {
        drawImg[i] = 1;
      }
      if (v > thresholds[1]) {
        drawImg[i] = 2;
      }
      if (v > thresholds[2]) {
        drawImg[i] = 3;
      }
    }
    this.drawAddUndoBitmap();
    this.refreshDrawing(true);
  }
  /**
   * remove dark voxels in air
   * @param level - (1-5) larger values for more preserved voxels
   * @param volIndex - volume to dehaze
   * @example niivue.removeHaze(3, 0);
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  removeHaze(level = 5, volIndex = 0) {
    const img = this.volumes[volIndex].img;
    const hdr = this.volumes[volIndex].hdr;
    const nvox = img.length;
    let otsu = 2;
    if (level === 5 || level === 1) {
      otsu = 4;
    }
    if (level === 4 || level === 2) {
      otsu = 3;
    }
    const thresholds = this.findOtsu(otsu);
    if (thresholds.length < 3) {
      return;
    }
    let threshold = thresholds[0];
    if (level === 1) {
      threshold = thresholds[2];
    }
    if (level === 2) {
      threshold = thresholds[1];
    }
    const inter = hdr.scl_inter;
    const slope = hdr.scl_slope;
    const mn = this.volumes[volIndex].global_min;
    for (let v = 0; v < nvox; v++) {
      const val = img[v] * slope + inter;
      if (val < threshold) {
        img[v] = mn;
      }
    }
    this.refreshLayers(this.volumes[volIndex], 0);
    this.drawScene();
  }
  /**
   * save voxel-based image to disk
   * @param fnm - filename of NIfTI image to create
   * @param isSaveDrawing - determines whether drawing or background image is saved
   * @param volumeByIndex - determines layer to save (0 for background)
   * @param volumeByIndex - determines layer to save (0 for background)
   * @example niivue.saveImage({ filename: "myimage.nii.gz", isSaveDrawing: true });
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  async saveImage(options = defaultSaveImageOptions) {
    const saveOptions = {
      ...defaultSaveImageOptions,
      ...options
    };
    const { filename, isSaveDrawing, volumeByIndex } = saveOptions;
    log.debug("saveImage", filename, isSaveDrawing, volumeByIndex);
    if (this.back?.dims === void 0) {
      log.debug("No voxelwise image open");
      return false;
    }
    if (isSaveDrawing) {
      if (!this.drawBitmap) {
        log.debug("No drawing open");
        return false;
      }
      const perm = this.volumes[0].permRAS;
      if (perm[0] === 1 && perm[1] === 2 && perm[2] === 3) {
        log.debug("saving drawing");
        const img2 = await this.volumes[0].saveToDisk(filename, this.drawBitmap);
        return img2;
      } else {
        log.debug("saving drawing");
        const dims = this.volumes[0].hdr.dims;
        const layout = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          for (let j2 = 0; j2 < 3; j2++) {
            if (Math.abs(perm[i]) - 1 !== j2) {
              continue;
            }
            layout[j2] = i * Math.sign(perm[i]);
          }
        }
        let stride = 1;
        const instride = [1, 1, 1];
        const inflip = [false, false, false];
        for (let i = 0; i < layout.length; i++) {
          for (let j2 = 0; j2 < layout.length; j2++) {
            const a = Math.abs(layout[j2]);
            if (a !== i) {
              continue;
            }
            instride[j2] = stride;
            if (layout[j2] < 0 || Object.is(layout[j2], -0)) {
              inflip[j2] = true;
            }
            stride *= dims[j2 + 1];
          }
        }
        let xlut = NVUtilities.range(0, dims[1] - 1, 1);
        if (inflip[0]) {
          xlut = NVUtilities.range(dims[1] - 1, 0, -1);
        }
        for (let i = 0; i < dims[1]; i++) {
          xlut[i] *= instride[0];
        }
        let ylut = NVUtilities.range(0, dims[2] - 1, 1);
        if (inflip[1]) {
          ylut = NVUtilities.range(dims[2] - 1, 0, -1);
        }
        for (let i = 0; i < dims[2]; i++) {
          ylut[i] *= instride[1];
        }
        let zlut = NVUtilities.range(0, dims[3] - 1, 1);
        if (inflip[2]) {
          zlut = NVUtilities.range(dims[3] - 1, 0, -1);
        }
        for (let i = 0; i < dims[3]; i++) {
          zlut[i] *= instride[2];
        }
        const inVs = new Uint8Array(this.drawBitmap);
        const outVs = new Uint8Array(dims[1] * dims[2] * dims[3]);
        let j = 0;
        for (let z = 0; z < dims[3]; z++) {
          for (let y = 0; y < dims[2]; y++) {
            for (let x = 0; x < dims[1]; x++) {
              outVs[j] = inVs[xlut[x] + ylut[y] + zlut[z]];
              j++;
            }
          }
        }
        log.debug("saving drawing");
        const img2 = this.volumes[0].saveToDisk(filename, outVs);
        return img2;
      }
    }
    log.debug("saving image");
    const img = this.volumes[volumeByIndex].saveToDisk(filename);
    return img;
  }
  // not included in public docs
  getMeshIndexByID(id) {
    if (typeof id === "number") {
      if (id >= this.meshes.length) {
        return -1;
      }
      return id;
    }
    const n = this.meshes.length;
    for (let i = 0; i < n; i++) {
      const id_i = this.meshes[i].id;
      if (id_i === id) {
        return i;
      }
    }
    return -1;
  }
  /**
   * change property of mesh, tractogram or connectome
   * @param id - identity of mesh to change
   * @param key - attribute to change
   * @param value - for attribute
   * @example niivue.setMeshProperty(niivue.meshes[0].id, 'fiberLength', 42)
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  setMeshProperty(id, key, val) {
    const idx = this.getMeshIndexByID(id);
    if (idx < 0) {
      log.warn("setMeshProperty() id not loaded", id);
      return;
    }
    this.meshes[idx].setProperty(key, val, this.gl);
    this.updateGLVolume();
    this.onMeshPropertyChanged(idx, key, val);
  }
  /**
   * returns the index of the mesh vertex that is closest to the provided coordinates
   * @param id - identity of mesh to change
   * @param Xmm - location in left/right dimension
   * @param Ymm - location in posterior/anterior dimension
   * @param Zmm - location in foot/head dimension
   * @returns the an array where ret[0] is the mesh index and ret[1] is distance from vertex to coordinates
   * @example niivue.indexNearestXYZmm(niivue.meshes[0].id, -22, 42, 13)
   * @see {@link https://niivue.github.io/niivue/features/clipplanes.html | live demo usage}
   */
  indexNearestXYZmm(mesh, Xmm, Ymm, Zmm) {
    const idx = this.getMeshIndexByID(mesh);
    if (idx < 0) {
      log.warn("indexNearestXYZmm() id not loaded", mesh);
      return [NaN, NaN];
    }
    return this.meshes[idx].indexNearestXYZmm(Xmm, Ymm, Zmm);
  }
  /**
   * reduce complexity of FreeSurfer mesh
   * @param mesh - identity of mesh to change
   * @param order - decimation order 0..6
   * @example niivue.decimateHierarchicalMesh(niivue.meshes[0].id, 4)
   * @returns boolean false if mesh is not hierarchical or of lower order
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  decimateHierarchicalMesh(mesh, order = 3) {
    const idx = this.getMeshIndexByID(mesh);
    if (idx < 0) {
      log.warn("reverseFaces() id not loaded", mesh);
      return;
    }
    const ret = this.meshes[idx].decimateHierarchicalMesh(this.gl, order);
    this.updateGLVolume();
    return ret;
  }
  /**
   * reverse triangle winding of mesh (swap front and back faces)
   * @param id - identity of mesh to change
   * @example niivue.reverseFaces(niivue.meshes[0].id)
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  reverseFaces(mesh) {
    const idx = this.getMeshIndexByID(mesh);
    if (idx < 0) {
      log.warn("reverseFaces() id not loaded", mesh);
      return;
    }
    this.meshes[idx].reverseFaces(this.gl);
    this.updateGLVolume();
  }
  /**
   * reverse triangle winding of mesh (swap front and back faces)
   * @param mesh - identity of mesh to change
   * @param layer - selects the mesh overlay (e.g. GIfTI or STC file)
   * @param key - attribute to change
   * @param value - for attribute
   * @example niivue.setMeshLayerProperty(niivue.meshes[0].id, 0, 'frame4D', 22)
   * @see {@link https://niivue.github.io/niivue/features/mesh.4D.html | live demo usage}
   */
  async setMeshLayerProperty(mesh, layer, key, val) {
    const idx = this.getMeshIndexByID(mesh);
    if (idx < 0) {
      log.warn("setMeshLayerProperty() id not loaded", mesh);
      return;
    }
    await this.meshes[idx].setLayerProperty(layer, key, val, this.gl);
    this.updateGLVolume();
  }
  /**
   * adjust offset position and scale of 2D sliceScale
   * @param xyzmmZoom - first three components are spatial, fourth is scaling
   * @example niivue.setPan2Dxyzmm([5,-4, 2, 1.5])
   */
  setPan2Dxyzmm(xyzmmZoom) {
    this.scene.pan2Dxyzmm = xyzmmZoom;
    if (this.opts.yoke3Dto2DZoom) {
      this.scene.volScaleMultiplier = xyzmmZoom[3];
    }
    this.drawScene();
  }
  /**
   * set rotation of 3D render view
   * @example niivue.setRenderAzimuthElevation(45, 15)
   * @see {@link https://niivue.github.io/niivue/features/mask.html | live demo usage}
   */
  setRenderAzimuthElevation(a, e) {
    this.scene.renderAzimuth = a;
    this.scene.renderElevation = e;
    this.onAzimuthElevationChange(a, e);
    this.drawScene();
  }
  /**
   * get the index of an overlay by its unique id. unique ids are assigned to the NVImage.id property when a new NVImage is created.
   * @param id - the id string to search for
   * @see NiiVue#getVolumeIndexByID
   * @example
   * niivue = new Niivue()
   * niivue.getOverlayIndexByID(someVolume.id)
   */
  getOverlayIndexByID(id) {
    const n = this.overlays.length;
    for (let i = 0; i < n; i++) {
      const id_i = this.overlays[i].id;
      if (id_i === id) {
        return i;
      }
    }
    return -1;
  }
  /**
   * set the index of a volume. This will change it's ordering and appearance if there are multiple volumes loaded.
   * @param volume - the volume to update
   * @param toIndex - the index to move the volume to. The default is the background (0 index)
   * @example
   * niivue = new Niivue()
   * niivue.setVolume(someVolume, 1) // move it to the second position in the array of loaded volumes (0 is the first position)
   */
  setVolume(volume, toIndex = 0) {
    const numberOfLoadedImages = this.volumes.length;
    if (toIndex > numberOfLoadedImages) {
      return;
    }
    const volIndex = this.getVolumeIndexByID(volume.id);
    if (toIndex === 0) {
      this.volumes.splice(volIndex, 1);
      this.volumes.unshift(volume);
      this.back = this.volumes[0];
      this.overlays = this.volumes.slice(1);
    } else if (toIndex < 0) {
      this.volumes.splice(this.getVolumeIndexByID(volume.id), 1);
      this.back = this.volumes[0];
      if (this.volumes.length > 1) {
        this.overlays = this.volumes.slice(1);
      } else {
        this.overlays = [];
      }
    } else {
      this.volumes.splice(volIndex, 1);
      this.volumes.splice(toIndex, 0, volume);
      this.overlays = this.volumes.slice(1);
      this.back = this.volumes[0];
    }
    this.updateGLVolume();
  }
  // not included in public docs
  setMesh(mesh, toIndex = 0) {
    this.meshes.forEach((m) => {
      log.debug("MESH: ", m.name);
    });
    const numberOfLoadedMeshes = this.meshes.length;
    if (toIndex > numberOfLoadedMeshes) {
      return;
    }
    const meshIndex = this.getMeshIndexByID(mesh.id);
    if (toIndex === 0) {
      this.meshes.splice(meshIndex, 1);
      this.meshes.unshift(mesh);
    } else if (toIndex < 0) {
      this.meshes.splice(this.getMeshIndexByID(mesh.id), 1);
    } else {
      this.meshes.splice(meshIndex, 1);
      this.meshes.splice(toIndex, 0, mesh);
    }
    this.updateGLVolume();
    this.meshes.forEach((m) => {
      log.debug(m.name);
    });
  }
  /**
   * Remove a volume
   * @param volume - volume to delete
   * @example
   * niivue = new Niivue()
   * niivue.removeVolume(this.volumes[3])
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  removeVolume(volume) {
    this.setVolume(volume, -1);
    if (this.mediaUrlMap.has(volume)) {
      const url = this.mediaUrlMap.get(volume);
      this.onVolumeWithUrlRemoved(url);
      this.mediaUrlMap.delete(volume);
    }
    this.drawScene();
  }
  /**
   * Remove a volume by index
   * @param index - of volume to remove
   */
  removeVolumeByIndex(index) {
    if (index >= this.volumes.length) {
      throw new Error("Index of volume out of bounds");
    }
    this.removeVolume(this.volumes[index]);
  }
  /**
   * Remove a triangulated mesh, connectome or tractogram
   * @param mesh - mesh to delete
   * @example
   * niivue = new Niivue()
   * niivue.removeMesh(this.meshes[3])
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  removeMesh(mesh) {
    mesh.unloadMesh(this.gl);
    this.setMesh(mesh, -1);
    if (this.mediaUrlMap.has(mesh)) {
      const url = this.mediaUrlMap.get(mesh);
      this.onMeshWithUrlRemoved(url);
      this.mediaUrlMap.delete(mesh);
    }
  }
  /**
   * Remove a triangulated mesh, connectome or tractogram
   * @param url - URL of mesh to delete
   * @example
   * niivue.removeMeshByUrl('../images/cit168.mz3')
   */
  removeMeshByUrl(url) {
    const mesh = this.getMediaByUrl(url);
    if (mesh) {
      this.removeMesh(mesh);
      this.mediaUrlMap.delete(mesh);
      this.onMeshWithUrlRemoved(url);
    }
  }
  /**
   * Move a volume to the bottom of the stack of loaded volumes. The volume will become the background
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeToBottom(this.volumes[3]) // move the 4th volume to the 0 position. It will be the new background
   */
  moveVolumeToBottom(volume) {
    this.setVolume(volume, 0);
  }
  /**
   * Move a volume up one index position in the stack of loaded volumes. This moves it up one layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeUp(this.volumes[0]) // move the background image to the second index position (it was 0 index, now will be 1)
   */
  moveVolumeUp(volume) {
    const volIdx = this.getVolumeIndexByID(volume.id);
    this.setVolume(volume, volIdx + 1);
  }
  /**
   * Move a volume down one index position in the stack of loaded volumes. This moves it down one layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeDown(this.volumes[1]) // move the second image to the background position (it was 1 index, now will be 0)
   */
  moveVolumeDown(volume) {
    const volIdx = this.getVolumeIndexByID(volume.id);
    this.setVolume(volume, volIdx - 1);
  }
  /**
   * Move a volume to the top position in the stack of loaded volumes. This will be the top layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeToTop(this.volumes[0]) // move the background image to the top layer position
   */
  moveVolumeToTop(volume) {
    this.setVolume(volume, this.volumes.length - 1);
  }
  // not included in public docs
  // update mouse position from new mouse down coordinates
  // note: no test yet
  mouseDown(x, y) {
    x *= this.uiData.dpr;
    y *= this.uiData.dpr;
    this.mousePos = [x, y];
  }
  // not included in public docs
  // note: no test yet
  mouseMove(x, y) {
    x *= this.uiData.dpr;
    y *= this.uiData.dpr;
    const dx = (x - this.mousePos[0]) / this.uiData.dpr;
    const dy = (y - this.mousePos[1]) / this.uiData.dpr;
    this.mousePos = [x, y];
    if (this.inRenderTile(x, y) < 0) {
      return;
    }
    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
      return;
    }
    this.scene.renderAzimuth += dx;
    this.scene.renderElevation += dy;
    this.drawScene();
  }
  /**
   * convert spherical AZIMUTH, ELEVATION to Cartesian
   * @param azimuth - azimuth number
   * @param elevation - elevation number
   * @returns the converted [x, y, z] coordinates
   * @example
   * niivue = new Niivue()
   * xyz = niivue.sph2cartDeg(42, 42)
   */
  sph2cartDeg(azimuth, elevation) {
    const Phi = -elevation * (Math.PI / 180);
    const Theta = (azimuth - 90) % 360 * (Math.PI / 180);
    const ret = [Math.cos(Phi) * Math.cos(Theta), Math.cos(Phi) * Math.sin(Theta), Math.sin(Phi)];
    const len4 = Math.sqrt(ret[0] * ret[0] + ret[1] * ret[1] + ret[2] * ret[2]);
    if (len4 <= 0) {
      return ret;
    }
    ret[0] /= len4;
    ret[1] /= len4;
    ret[2] /= len4;
    return ret;
  }
  /**
   * update the clip plane orientation in 3D view mode
   * @param azimuthElevationDepth - a two component vector. azimuth: camera position in degrees around object, typically 0..360 (or -180..+180). elevation: camera height in degrees, range -90..90
   * @example
   * niivue = new Niivue()
   * niivue.setClipPlane([42, 42])
   * @see {@link https://niivue.github.io/niivue/features/mask.html | live demo usage}
   */
  setClipPlane(depthAzimuthElevation) {
    const v = this.sph2cartDeg(depthAzimuthElevation[1] + 180, depthAzimuthElevation[2]);
    this.scene.clipPlane = [v[0], v[1], v[2], depthAzimuthElevation[0]];
    this.scene.clipPlaneDepthAziElev = depthAzimuthElevation;
    this.onClipPlaneChange(this.scene.clipPlane);
    this.drawScene();
  }
  /**
   * set the crosshair and colorbar outline color
   * @param color - an RGBA array. values range from 0 to 1
   * @example
   * niivue = new Niivue()
   * niivue.setCrosshairColor([0, 1, 0, 0.5]) // set crosshair to transparent green
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  setCrosshairColor(color) {
    this.opts.crosshairColor = color;
    this.drawScene();
  }
  /**
   * set thickness of crosshair
   * @example niivue.crosshairWidth(2)
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  setCrosshairWidth(crosshairWidth) {
    this.opts.crosshairWidth = crosshairWidth;
    if (this.crosshairs3D) {
      this.crosshairs3D.mm[0] = NaN;
    }
    this.drawScene();
  }
  /*
   * set colors and labels for different drawing values
   * @param {array} cmap a structure mapping indices to colors and labels
   * @example
   * let cmap = {
   *    R: [0, 255, 0],
   *    G: [0, 20, 0],
   *    B: [0, 20, 80],
   *    A: [0, 255, 255],
   *    labels: ["", "white-matter", "delete T1"],
   *  };
   *  nv.setDrawColormap(cmap);
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  setDrawColormap(name) {
    this.drawLut = cmapper.makeDrawLut(name);
    this.updateGLVolume();
  }
  /**
   * does dragging over a 2D slice create a drawing?
   * @param trueOrFalse - enabled (true) or not (false)
   * @example niivue.setDrawingEnabled(true)
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  setDrawingEnabled(trueOrFalse) {
    this.opts.drawingEnabled = trueOrFalse;
    if (this.opts.drawingEnabled) {
      if (!this.drawBitmap) {
        this.createEmptyDrawing();
      }
    }
    this.drawScene();
  }
  /**
   * determine color and style of drawing
   * @param penValue - sets the color of the pen
   * @param isFilledPen - determines if dragging creates flood-filled shape
   * @example niivue.setPenValue(1, true)
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  setPenValue(penValue, isFilledPen = false) {
    this.opts.penValue = penValue;
    this.opts.isFilledPen = isFilledPen;
    this.drawScene();
  }
  /**
   * control whether drawing is transparent (0), opaque (1) or translucent (between 0 and 1).
   * @param opacity - translucency of drawing
   * @example niivue.setDrawOpacity(0.7)
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  setDrawOpacity(opacity) {
    this.drawOpacity = opacity;
    this.drawScene();
  }
  /**
   * set the selection box color. A selection box is drawn when you right click and drag to change image contrast
   * @param color - an RGBA array. values range from 0 to 1
   * @example
   * niivue = new Niivue()
   * niivue.setSelectionBoxColor([0, 1, 0, 0.5]) // set to transparent green
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  setSelectionBoxColor(color) {
    this.opts.selectionBoxColor = color;
  }
  // not included in public docs
  sliceScroll2D(posChange, x, y, isDelta = true) {
    if (this.opts.scrollRequiresFocus && this.canvas !== document.activeElement) {
      log.warn("Canvas element does not have focus. Scroll events will not be processed.");
      return;
    }
    if (this.inGraphTile(x, y)) {
      let vol = this.volumes[0].frame4D;
      if (posChange > 0) {
        vol++;
      }
      if (posChange < 0) {
        vol--;
      }
      this.setFrame4D(this.volumes[0].id, vol);
      return;
    }
    if (posChange !== 0 && this.opts.dragMode === 3 /* pan */ && this.inRenderTile(this.uiData.dpr * x, this.uiData.dpr * y) === -1) {
      let zoom = this.scene.pan2Dxyzmm[3] * (1 + 10 * posChange);
      zoom = Math.round(zoom * 10) / 10;
      const zoomChange = this.scene.pan2Dxyzmm[3] - zoom;
      if (this.opts.yoke3Dto2DZoom) {
        this.scene.volScaleMultiplier = zoom;
      }
      this.scene.pan2Dxyzmm[3] = zoom;
      const mm = this.frac2mm(this.scene.crosshairPos);
      this.scene.pan2Dxyzmm[0] += zoomChange * mm[0];
      this.scene.pan2Dxyzmm[1] += zoomChange * mm[1];
      this.scene.pan2Dxyzmm[2] += zoomChange * mm[2];
      this.drawScene();
      this.canvas.focus();
      this.sync();
      return;
    }
    this.mouseClick(x, y, posChange, isDelta);
  }
  /**
   * set the slice type. This changes the view mode
   * @param sliceType - an enum of slice types to use
   * @example
   * niivue = new Niivue()
   * niivue.setSliceType(Niivue.sliceTypeMultiplanar)
   * @see {@link https://niivue.github.io/niivue/features/basic.multiplanar.html | live demo usage}
   */
  setSliceType(st) {
    this.opts.sliceType = st;
    this.drawScene();
    return this;
  }
  /**
   * set the opacity of a volume given by volume index
   * @param volIdx - the volume index of the volume to change
   * @param newOpacity - the opacity value. valid values range from 0 to 1. 0 will effectively remove a volume from the scene
   * @example
   * niivue = new Niivue()
   * niivue.setOpacity(0, 0.5) // make the first volume transparent
   * @see {@link https://niivue.github.io/niivue/features/atlas.html | live demo usage}
   */
  setOpacity(volIdx, newOpacity) {
    this.volumes[volIdx].opacity = newOpacity;
    this.updateGLVolume();
  }
  /**
   * set the scale of the 3D rendering. Larger numbers effectively zoom.
   * @param scale - the new scale value
   * @example
   * niivue.setScale(2) // zoom some
   * @see {@link https://niivue.github.io/niivue/features/shiny.volumes.html | live demo usage}
   */
  setScale(scale6) {
    this.scene.volScaleMultiplier = scale6;
    this.drawScene();
  }
  /**
   * set the color of the 3D clip plane
   * @param color - the new color. expects an array of RGBA values. values can range from 0 to 1
   * @example
   * niivue.setClipPlaneColor([1, 1, 1, 0.5]) // white, transparent
   * @see {@link https://niivue.github.io/niivue/features/clipplanes.html | live demo usage}
   */
  setClipPlaneColor(color) {
    this.opts.clipPlaneColor = color;
    this.renderShader.use(this.gl);
    this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor);
    this.drawScene();
  }
  /**
   * adjust thickness of the 3D clip plane
   * @param thick - thickness of slab. Value 0..1.73 (cube opposite corner length is sqrt(3)).
   * @example
   * niivue.setClipPlaneThick(0.3) // thin slab
   * @see {@link https://niivue.github.io/niivue/features/clipplanes.html | live demo usage}
   */
  setClipPlaneThick(thick) {
    this.opts.clipThick = thick;
    this.renderShader.use(this.gl);
    this.gl.uniform1f(this.renderShader.uniforms.clipThick, this.opts.clipThick);
    this.drawScene();
  }
  /**
   * set the clipping region for volume rendering
   * @param color - the new color. expects an array of RGBA values. values can range from 0 to 1
   * @example
   * niivue.setClipPlaneColor([0.0, 0.0, 0.2], [1.0, 1.0, 0.7]) // remove inferior 20% and superior 30%
   * @see {@link https://niivue.github.io/niivue/features/clipplanes.html | live demo usage}
   */
  setClipVolume(low, high) {
    this.opts.clipVolumeLow = [Math.min(low[0], high[0]), Math.min(low[1], high[1]), Math.min(low[2], high[2])];
    this.opts.clipVolumeHigh = [Math.max(low[0], high[0]), Math.max(low[1], high[1]), Math.max(low[2], high[2])];
    this.renderShader.use(this.gl);
    this.gl.uniform3fv(this.renderShader.uniforms.clipLo, this.opts.clipVolumeLow);
    this.gl.uniform3fv(this.renderShader.uniforms.clipHi, this.opts.clipVolumeHigh);
    this.pickingImageShader.use(this.gl);
    this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo, this.opts.clipVolumeLow);
    this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi, this.opts.clipVolumeHigh);
    this.drawScene();
  }
  /**
   * set proportion of volume rendering influenced by selected matcap.
   * @param gradientAmount - amount of matcap (NaN or 0..1), default 0 (matte, surface normal does not influence color). NaN renders the gradients.
   * @example
   * niivue.setVolumeRenderIllumination(0.6);
   * @see {@link https://niivue.github.io/niivue/features/shiny.volumes.html | live demo usage}
   * @see {@link https://niivue.github.io/niivue/features/gradient.order.html | live demo usage}
   */
  async setVolumeRenderIllumination(gradientAmount = 0) {
    this.renderGradientValues = Number.isNaN(gradientAmount);
    this.renderShader = this.renderVolumeShader;
    if (this.renderGradientValues) {
      this.renderShader = this.renderGradientValuesShader;
    } else if (gradientAmount > 0 || this.opts.gradientOpacity > 0) {
      this.renderShader = this.renderGradientShader;
    } else if (gradientAmount < 0) {
      this.renderShader = this.renderSliceShader;
    }
    this.initRenderShader(this.renderShader, gradientAmount);
    this.renderShader.use(this.gl);
    this.setClipPlaneColor(this.opts.clipPlaneColor);
    if (Number.isNaN(gradientAmount)) {
      this.gradientTextureAmount = 1;
    } else {
      this.gradientTextureAmount = gradientAmount;
    }
    if (this.volumes.length < 1) {
      return;
    }
    this.refreshLayers(this.volumes[0], 0);
    this.drawScene();
  }
  /**
   * set volume rendering opacity influence of the gradient magnitude
   * @param gradientOpacity - amount of gradient magnitude influence on opacity (0..1), default 0 (no-influence)
   * @example
   * niivue.setGradientOpacity(0.6);
   * @see {@link https://niivue.github.io/niivue/features/gradient.opacity.html | live demo usage}
   */
  async setGradientOpacity(gradientOpacity = 0) {
    this.opts.gradientOpacity = gradientOpacity;
    if (this.renderGradientValues) {
      this.renderShader = this.renderGradientValuesShader;
    } else if (this.gradientTextureAmount > 0 || gradientOpacity > 0) {
      this.renderShader = this.renderGradientShader;
    } else if (this.gradientTextureAmount < 0) {
      this.renderShader = this.renderSliceShader;
    }
    this.initRenderShader(this.renderShader, this.gradientTextureAmount);
    this.renderShader.use(this.gl);
    this.drawScene();
  }
  // not included in public docs.
  // note: marked for removal at some point in the future (this just makes a test sphere)
  overlayRGBA(volume) {
    const hdr = volume.hdr;
    const vox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    const imgRGBA = new Uint8ClampedArray(vox * 4);
    const radius = 0.2 * Math.min(Math.min(hdr.dims[1], hdr.dims[2]), hdr.dims[3]);
    const halfX = 0.5 * hdr.dims[1];
    const halfY = 0.5 * hdr.dims[2];
    const halfZ = 0.5 * hdr.dims[3];
    let j = 0;
    for (let z = 0; z < hdr.dims[3]; z++) {
      for (let y = 0; y < hdr.dims[2]; y++) {
        for (let x = 0; x < hdr.dims[1]; x++) {
          const dx = Math.abs(x - halfX);
          const dy = Math.abs(y - halfY);
          const dz = Math.abs(z - halfZ);
          const dist4 = Math.sqrt(dx * dx + dy * dy + dz * dz);
          let v = 0;
          if (dist4 < radius) {
            v = 255;
          }
          imgRGBA[j++] = 0;
          imgRGBA[j++] = v;
          imgRGBA[j++] = 0;
          imgRGBA[j++] = v * 0.5;
        }
      }
    }
    return imgRGBA;
  }
  // not included in public docs
  vox2mm(XYZ, mtx) {
    return NVUtilities.vox2mm(XYZ, mtx);
  }
  /**
   * clone a volume and return a new volume
   * @param index - the index of the volume to clone
   * @returns new volume to work with, but that volume is not added to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.cloneVolume(0)
   */
  cloneVolume(index) {
    return this.volumes[index].clone();
  }
  /**
   *
   * @param url - URL of NVDocument
   */
  async loadDocumentFromUrl(url) {
    const document2 = await NVDocument.loadFromUrl(url);
    await this.loadDocument(document2);
  }
  /**
   * Loads an NVDocument
   * @returns  Niivue instance
   * @see {@link https://niivue.github.io/niivue/features/document.load.html | live demo usage}
   */
  async loadDocument(document2) {
    this.volumes = [];
    this.meshes = [];
    this.document = document2;
    this.document.labels = this.document.labels ? this.document.labels : [];
    const opts = { ...DEFAULT_OPTIONS, ...document2.opts };
    this.scene.pan2Dxyzmm = document2.scene.pan2Dxyzmm ? document2.scene.pan2Dxyzmm : [0, 0, 0, 1];
    this.document.opts = opts;
    this.setClipPlane(this.scene.clipPlaneDepthAziElev);
    log.debug("load document", document2);
    this.mediaUrlMap.clear();
    this.createEmptyDrawing();
    const encodedImageBlobs = document2.encodedImageBlobs;
    for (let i = 0; i < document2.imageOptionsArray.length; i++) {
      const imageOptions = document2.imageOptionsArray[i];
      const base64 = encodedImageBlobs[i];
      if (base64) {
        if ("colorMap" in imageOptions) {
          imageOptions.colormap = imageOptions.colorMap;
        }
        const image = await NVImage.loadFromBase64({ base64, ...imageOptions });
        if (image) {
          if (image.colormapLabel) {
            const length4 = Object.keys(image.colormapLabel.lut).length;
            const uint8ClampedArray = new Uint8ClampedArray(length4);
            for (const key in image.colormapLabel.lut) {
              uint8ClampedArray[key] = image.colormapLabel.lut[key];
            }
            image.colormapLabel.lut = uint8ClampedArray;
          }
          this.addVolume(image);
        }
      }
    }
    if (this.volumes.length > 0) {
      this.back = this.volumes[0];
    }
    for (const meshDataObject of document2.meshDataObjects ?? []) {
      const meshInit = { gl: this.gl, ...meshDataObject };
      if (meshDataObject.offsetPt0) {
        meshInit.rgba255[3] = 0;
        meshInit.tris = new Uint32Array(meshDataObject.offsetPt0);
      }
      log.debug(meshInit);
      const meshToAdd = new NVMesh3(
        meshInit.pts,
        meshInit.tris,
        meshInit.name,
        meshInit.rgba255,
        meshInit.opacity,
        meshInit.visible,
        this.gl,
        meshInit.connectome,
        meshInit.dpg,
        meshInit.dps,
        meshInit.dpv
      );
      if (meshDataObject.offsetPt0) {
        meshToAdd.fiberGroupColormap = meshDataObject.fiberGroupColormap;
        meshToAdd.fiberColor = meshDataObject.fiberColor;
        meshToAdd.fiberDither = meshDataObject.fiberDither;
        meshToAdd.fiberRadius = meshDataObject.fiberRadius;
        meshToAdd.colormap = meshDataObject.colormap;
      }
      meshToAdd.meshShaderIndex = meshInit.meshShaderIndex;
      meshToAdd.layers = meshInit.layers;
      meshToAdd.updateMesh(this.gl);
      log.debug(meshToAdd);
      this.addMesh(meshToAdd);
    }
    if (document2.data.connectomes) {
      for (const connectomeString of document2.data.connectomes) {
        const connectome = JSON.parse(connectomeString);
        const meshToAdd = this.loadConnectomeAsMesh(connectome);
        meshToAdd.updateMesh(this.gl);
        this.addMesh(meshToAdd);
      }
    }
    this.createEmptyDrawing();
    const drawingBase64 = document2.encodedDrawingBlob;
    if (drawingBase64) {
      const drawingBitmap = await NVUtilities.b64toUint8(drawingBase64);
      if (drawingBitmap) {
        const dims = this.back.dims;
        let expectedBytes = dims[1] * dims[2] * dims[3];
        if (drawingBitmap.length - 352 === expectedBytes) {
          expectedBytes += 352;
        }
        if (drawingBitmap.length !== expectedBytes) {
          throw new Error(
            `drawBitmap size does not match the texture dimensions (${dims[1]}\xD7${dims[2]}\xD7${dims[3]}) ${expectedBytes} != ${dims[1] * dims[2] * dims[3]}.`
          );
        }
        this.drawBitmap = drawingBitmap;
        this.refreshDrawing();
      }
    }
    this.updateGLVolume();
    this.drawScene();
    this.onDocumentLoaded(document2);
    return this;
  }
  /**
  * generates JavaScript to load the current scene as a document
  * @param canvasId - id of canvas NiiVue will be attached to
  * @param esm - bundled version of NiiVue
  * @example
  * const javascript = this.generateLoadDocumentJavaScript("gl1");
  * const html = `<html><body><canvas id="gl1"></canvas><script type="module" async>
         ${javascript}<\/script></body></html>`;
  */
  async generateLoadDocumentJavaScript(canvasId, esm) {
    const json = this.json();
    const base64 = await NVUtilities.compressToBase64String(JSON.stringify(json));
    const javascript = `
        ${esm}

        async function saveNiivueAsHtml(pageName) {
          //get new docstring
          const docString = nv1.json();
          const html =
          document.getElementsByTagName("html")[0]
              .innerHTML.replace(base64, await NVUtilities.compressToBase64String(JSON.stringify(docString)));
          NVUtilities.download(html, pageName, "application/html");
        }

        var nv1 = new Niivue();
        await nv1.attachTo("${canvasId}");
        var base64 = "${base64}";
        NVUtilities.decompressBase64String(base64).then((jsonText) => {
          var json = JSON.parse(jsonText); // string -> JSON
          var doc = NVDocument.loadFromJSON(json);
          nv1.loadDocument(doc);
          nv1.updateGLVolume();
        });

      `;
    return javascript;
  }
  /**
   * generates HTML of current scene
   * @param canvasId - id of canvas NiiVue will be attached to
   * @param esm - bundled version of NiiVue
   * @returns HTML with javascript of the current scene
   * @example
   * const template = `<html><body><canvas id="gl1"></canvas><script type="module" async>
   *       %%javascript%%<\/script></body></html>`;
   * nv1.generateHTML("page.html", esm);
   */
  async generateHTML(canvasId = "gl1", esm) {
    const javascript = await this.generateLoadDocumentJavaScript(canvasId, esm);
    const html = `<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width,initial-scale=1.0" />
            <title>Save as HTML</title>
            <style>
            html {
              height: auto;
              min-height: 100%;
              margin: 0;
            }
            body {
              display: flex;
              flex-direction: column;
              margin: 0;
              min-height: 100%;
              width: 100%;
              position: absolute;
              font-family: system-ui, Arial, Helvetica, sans-serif;
              background: #ffffff;
              color: black;
              user-select: none; /* Standard syntax */
            }
            header {
              margin: 10px;
            }
            main {
              flex: 1;
              background: #000000;
              position: relative;
            }
            footer {
              margin: 10px;
            }
            canvas {
              position: absolute;
              cursor: crosshair;
            }
            canvas:focus {
              outline: 0px;
            }
            div {
              display: table-row;
              background-color: blue;
            }
            </style>
          </head>
          <body>
            <noscript>niivue requires JavaScript.</noscript>
            <header>
            Save the current scene as HTML
            <button id="save">Save as HTML</button>
            </header>
            <main>
              <canvas id="gl1"></canvas>
            </main>
            <script type="module" async>
              ${javascript}
              function saveAsHtml() {
                saveNiivueAsHtml("page.html");
              }
              // assign our event handler
              var button = document.getElementById("save");
              button.onclick = saveAsHtml;
            <\/script>
          </body>
        </html>`;
    return html;
  }
  /**
   * save current scene as HTML
   * @param fileName - the name of the HTML file
   * @param canvasId - id of canvas NiiVue will be attached to
   * @param esm - bundled version of NiiVue
   */
  async saveHTML(fileName = "untitled.html", canvasId = "gl1", esm) {
    const html = await this.generateHTML(canvasId, esm);
    return NVUtilities.download(html, fileName, "application/html");
  }
  /**
   * Converts NiiVue scene to JSON
   */
  json() {
    this.document.opts = this.opts;
    this.document.scene = this.scene;
    this.document.volumes = this.volumes;
    this.document.meshes = this.meshes;
    this.drawScene();
    this.document.previewImageDataURL = this.canvas.toDataURL();
    const json = this.document.json();
    return json;
  }
  /**
   * save the entire scene (objects and settings) as a document
   * @param fileName - the name of the document storing the scene
   * @param compress - whether the file should be compressed
   * @example
   * niivue.saveDocument("niivue.basic.nvd")
   * @see {@link https://niivue.github.io/niivue/features/document.3d.html | live demo usage}
   */
  async saveDocument(fileName = "untitled.nvd", compress = true) {
    this.document.title = fileName;
    log.debug("saveDocument", this.volumes[0]);
    this.drawScene();
    this.document.previewImageDataURL = this.canvas.toDataURL();
    this.document.volumes = this.volumes;
    this.document.meshes = this.meshes;
    return this.document.download(fileName, compress);
  }
  // generic loadImages that wraps loadVolumes and loadMeshes
  async loadImages(images) {
    const volumes = [];
    const meshes = [];
    for (const image of images) {
      if ("url" in image) {
        const ext = this.getFileExt(image.name ? image.name : image.url);
        if (this.loaders[ext]) {
          const toExt = this.loaders[ext].toExt.toUpperCase();
          if (MESH_EXTENSIONS.includes(toExt)) {
            meshes.push(image);
          } else {
            volumes.push(image);
          }
          continue;
        }
        if (MESH_EXTENSIONS.includes(ext.toUpperCase())) {
          meshes.push(image);
        } else {
          volumes.push(image);
        }
      }
    }
    if (volumes.length > 0) {
      await this.loadVolumes(volumes);
    }
    if (meshes.length > 0) {
      await this.loadMeshes(meshes);
    }
    return this;
  }
  async loadDicoms(dicomList) {
    if (!this.getDicomLoader()) {
      throw new Error("No dicom loader set. Please set a dicom loader before loading dicoms");
    }
    this.drawScene();
    this.volumes = [];
    this.gl.clearColor(0, 0, 0, 1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    const promises = dicomList.map(async (dicom) => {
      let dicomData = null;
      if (dicom.isManifest) {
        dicomData = await NVImage.fetchDicomData(dicom.url);
      } else {
        const response = await fetch(dicom.url);
        if (!response.ok) {
          throw new Error(`Failed to load file: ${response.statusText}`);
        }
        const dicomArrayBuffer = await response.arrayBuffer();
        const basename = dicom.url.split("/").pop();
        const data2 = dicomArrayBuffer;
        dicomData = [{ name: basename, data: data2 }];
      }
      const dicomLoader = this.getDicomLoader().loader;
      const convertedArrayBuffer = await dicomLoader(dicomData);
      console.log(convertedArrayBuffer);
      const name = convertedArrayBuffer[0].name;
      const data = convertedArrayBuffer[0].data;
      const image = await NVImage.loadFromUrl({ url: data, name });
      return image;
    });
    const nvImages = await Promise.all(promises);
    if (nvImages.length === 1) {
      this.addVolume(nvImages[0]);
    } else {
      this.onDicomLoaderFinishedWithImages(nvImages);
    }
    return this;
  }
  /**
   * load an array of volume objects
   * @param volumeList - the array of objects to load. each object must have a resolvable "url" property at a minimum
   * @returns returns the Niivue instance
   * @example
   * niivue = new Niivue()
   * niivue.loadVolumes([{url: 'someImage.nii.gz}, {url: 'anotherImage.nii.gz'}])
   * @see {@link https://niivue.github.io/niivue/features/mask.html | live demo usage}
   */
  async loadVolumes(volumeList) {
    this.drawScene();
    if (this.thumbnailVisible) {
      this.deferredVolumes = volumeList;
      return this;
    }
    this.volumes = [];
    this.gl.clearColor(0, 0, 0, 1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    await this.addVolumesFromUrl(volumeList);
    return this;
  }
  /**
   * Add mesh and notify subscribers
   */
  async addMeshFromUrl(meshOptions) {
    const ext = this.getFileExt(meshOptions.url);
    if (ext === "JCON" || ext === "JSON") {
      const response = await fetch(meshOptions.url, {});
      const json = await response.json();
      const mesh2 = this.loadConnectomeAsMesh(json);
      this.mediaUrlMap.set(mesh2, meshOptions.url);
      this.onMeshAddedFromUrl(meshOptions, mesh2);
      this.addMesh(mesh2);
      return mesh2;
    }
    const mesh = await NVMesh3.loadFromUrl({ ...meshOptions, gl: this.gl });
    this.mediaUrlMap.set(mesh, meshOptions.url);
    this.onMeshAddedFromUrl(meshOptions, mesh);
    this.addMesh(mesh);
    return mesh;
  }
  /**
   * Add mesh and notify subscribers
   */
  async addMeshesFromUrl(meshOptions) {
    const promises = meshOptions.map(async (meshItem) => {
      const ext = this.getFileExt(meshItem.name || meshItem.url);
      if (this.loaders[ext]) {
        let itemToLoad = meshItem.url;
        const toExt = this.loaders[ext].toExt;
        let name = meshItem.name || meshItem.url;
        name = name.split("/").pop();
        if (typeof meshItem.url === "string") {
          const url = meshItem.url;
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to load file: ${response.statusText}`);
            }
            itemToLoad = await response.arrayBuffer();
          } catch (error) {
            throw new Error(`Failed to load url ${url}: ${error}`);
          }
        }
        const { positions, indices, colors = null } = await this.loaders[ext].loader(itemToLoad);
        meshItem.name = `${name}.${toExt}`;
        const mz3 = await NVMeshUtilities.createMZ3Async(positions, indices, false, colors);
        meshItem.buffer = mz3;
      }
      if (ext === "JCON" || ext === "JSON") {
        const response = await fetch(meshItem.url, {});
        const json = await response.json();
        const mesh2 = this.loadConnectomeAsMesh(json);
        this.mediaUrlMap.set(mesh2, meshItem.url);
        this.onMeshAddedFromUrl(meshItem, mesh2);
        return mesh2;
      }
      const mesh = await NVMesh3.loadFromUrl({ ...meshItem, gl: this.gl });
      this.mediaUrlMap.set(mesh, meshItem.url);
      this.onMeshAddedFromUrl(meshItem, mesh);
      return mesh;
    });
    const meshes = await Promise.all(promises);
    for (let i = 0; i < meshes.length; i++) {
      this.addMesh(meshes[i]);
    }
    return meshes;
  }
  /**
   * load an array of meshes
   * @param meshList - the array of objects to load. each object must have a resolvable "url" property at a minimum
   * @returns Niivue instance
   * @example
   * niivue = new Niivue()
   * niivue.loadMeshes([{url: 'someMesh.gii'}])
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  async loadMeshes(meshList) {
    this.drawScene();
    if (this.thumbnailVisible) {
      this.deferredMeshes = meshList;
      return this;
    }
    if (!this.initialized) {
    }
    this.meshes = [];
    this.gl.clearColor(0, 0, 0, 1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    await this.addMeshesFromUrl(meshList);
    this.updateGLVolume();
    this.drawScene();
    return this;
  }
  /**
   * load a connectome specified by url
   * @returns Niivue instance
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  async loadConnectomeFromUrl(url, headers = {}) {
    const response = await fetch(url, { headers });
    const json = await response.json();
    return this.loadConnectome(json);
  }
  /**
   * load a connectome specified by url
   * @returns Niivue instance
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  async loadFreeSurferConnectomeFromUrl(url, headers = {}) {
    const response = await fetch(url, { headers });
    const json = await response.json();
    return this.loadFreeSurferConnectome(json);
  }
  /**
   * load a connectome specified by json
   * @param connectome - freesurfer model
   * @returns Niivue instance
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  async loadFreeSurferConnectome(json) {
    const connectome = NVConnectome.convertFreeSurferConnectome(json);
    return this.loadConnectome(connectome);
  }
  handleNodeAdded(event) {
    const node = event.detail.node;
    const rgba = [1, 1, 1, 1];
    this.addLabel(
      node.name,
      {
        textColor: rgba,
        bulletScale: 1,
        bulletColor: rgba,
        lineWidth: 0,
        lineColor: rgba,
        lineTerminator: "none" /* NONE */,
        textScale: 1
      },
      [node.x, node.y, node.z]
    );
    this.drawScene();
  }
  loadConnectomeAsMesh(json) {
    let connectome = json;
    if ("data_type" in json && json.data_type === "fs_pointset") {
      connectome = NVConnectome.convertFreeSurferConnectome(json);
      log.warn("converted FreeSurfer connectome", connectome);
    } else if ("nodes" in json) {
      const nodes = json.nodes;
      if ("names" in nodes && "X" in nodes && "Y" in nodes && "Z" in nodes && "Color" in nodes && "Size" in nodes) {
        connectome = NVConnectome.convertLegacyConnectome(json);
        log.warn("converted legacy connectome", connectome);
      }
    } else {
      throw new Error("not a known connectome format");
    }
    return new NVConnectome(this.gl, connectome);
  }
  /**
   * load a connectome specified by json
   * @param connectome - model
   * @returns Niivue instance
   * @see {@link https://niivue.github.io/niivue/features/connectome.html | live demo usage}
   */
  loadConnectome(json) {
    this.drawScene();
    this.meshes = [];
    this.gl.clearColor(0, 0, 0, 1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    const mesh = this.loadConnectomeAsMesh(json);
    this.addMesh(mesh);
    this.drawScene();
    return this;
  }
  /**
   * generate a blank canvas for the pen tool
   * @example niivue.createEmptyDrawing()
   * @see {@link https://niivue.github.io/niivue/features/cactus.html | live demo usage}
   */
  createEmptyDrawing() {
    if (this.back === null || !this.back.dims) {
      return;
    }
    const mn = Math.min(Math.min(this.back.dims[1], this.back.dims[2]), this.back.dims[3]);
    if (mn < 1) {
      return;
    }
    const vx = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
    this.drawBitmap = new Uint8Array(vx);
    this.clickToSegmentGrowingBitmap = new Uint8Array(vx);
    this.drawClearAllUndoBitmaps();
    this.drawAddUndoBitmap();
    this.drawTexture = this.r8Tex(this.drawTexture, TEXTURE7_DRAW, this.back.dims, true);
    this.refreshDrawing(false);
  }
  // not included in public docs
  // create a 1-component (red) 16-bit signed integer texture on the GPU
  r16Tex(texID, activeID, dims, img16) {
    if (texID) {
      this.gl.deleteTexture(texID);
    }
    texID = this.gl.createTexture();
    this.gl.activeTexture(activeID);
    this.gl.bindTexture(this.gl.TEXTURE_3D, texID);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, dims[1], dims[2], dims[3]);
    const nv = dims[1] * dims[2] * dims[3];
    if (img16.length !== nv) {
      img16 = new Int16Array(nv);
    }
    this.gl.texSubImage3D(
      this.gl.TEXTURE_3D,
      0,
      0,
      0,
      0,
      dims[1],
      dims[2],
      dims[3],
      this.gl.RED_INTEGER,
      this.gl.SHORT,
      img16
    );
    return texID;
  }
  /**
   * dilate drawing so all voxels are colored.
   * works on drawing with multiple colors
   * @example niivue.drawGrowCut();
   * @see {@link https://niivue.github.io/niivue/features/draw2.html | live demo usage}
   */
  drawGrowCut() {
    if (!this.back || !this.back.dims) {
      throw new Error("back not defined");
    }
    const hdr = this.back.hdr;
    const gl = this.gl;
    const nv = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
    if (!this.drawBitmap || this.drawBitmap.length !== nv) {
      log.debug("bitmap dims are wrong");
      return;
    }
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.disable(gl.CULL_FACE);
    gl.viewport(0, 0, this.back.dims[1], this.back.dims[2]);
    gl.disable(gl.BLEND);
    let img16 = img2ras16(this.back);
    const background = this.r16Tex(null, TEXTURE11_GC_BACK, this.back.dims, img16);
    for (let i = 1; i < nv; i++) {
      img16[i] = this.drawBitmap[i];
    }
    const label0 = this.r16Tex(null, TEXTURE14_GC_LABEL0, this.back.dims, img16);
    const label1 = this.r16Tex(null, TEXTURE15_GC_LABEL1, this.back.dims, img16);
    const kMAX_STRENGTH = 1e4;
    for (let i = 1; i < nv; i++) {
      if (img16[i] > 0) {
        img16[i] = kMAX_STRENGTH;
      }
    }
    const strength0 = this.r16Tex(null, TEXTURE12_GC_STRENGTH0, this.back.dims, img16);
    const strength1 = this.r16Tex(null, TEXTURE13_GC_STRENGTH1, this.back.dims, img16);
    gl.bindVertexArray(this.genericVAO);
    const shader = this.growCutShader;
    shader.use(gl);
    const iterations = 128;
    gl.uniform1i(shader.uniforms.finalPass, 0);
    gl.uniform1i(shader.uniforms.backTex, 11);
    for (let j = 0; j < iterations; j++) {
      gl.uniform1i(shader.uniforms.labelTex, 14);
      gl.uniform1i(shader.uniforms.strengthTex, 12);
      for (let i = 0; i < this.back.dims[3]; i++) {
        const coordZ = 1 / this.back.dims[3] * (i + 0.5);
        gl.uniform1f(shader.uniforms.coordZ, coordZ);
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, label1, 0, i);
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, strength1, 0, i);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
          log.error("Incomplete framebuffer");
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
      if (j === iterations - 1) {
        gl.uniform1i(shader.uniforms.finalPass, 1);
      }
      gl.uniform1i(shader.uniforms.labelTex, 15);
      gl.uniform1i(shader.uniforms.strengthTex, 13);
      for (let i = 0; i < this.back.dims[3]; i++) {
        const coordZ = 1 / this.back.dims[3] * (i + 0.5);
        gl.uniform1f(shader.uniforms.coordZ, coordZ);
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, label0, 0, i);
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, strength0, 0, i);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
          log.error("Incomplete framebuffer");
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    const readAttach = gl.COLOR_ATTACHMENT1;
    const readTex = label0;
    gl.readBuffer(readAttach);
    const format = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);
    const type = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
    if (format !== gl.RED_INTEGER || type !== gl.SHORT) {
      log.debug("readPixels will fail.");
    }
    img16 = new Int16Array();
    const nv2D = this.back.dims[1] * this.back.dims[2];
    const slice16 = new Int16Array(nv2D);
    for (let i = 0; i < this.back.dims[3]; i++) {
      gl.framebufferTextureLayer(
        gl.FRAMEBUFFER,
        readAttach,
        // gl.COLOR_ATTACHMENT1,//COLOR_ATTACHMENT1
        readTex,
        // strength1,//strength0
        0,
        i
      );
      gl.readPixels(0, 0, this.back.dims[1], this.back.dims[2], format, type, slice16);
      img16 = Int16Array.from([...img16, ...slice16]);
    }
    let mx = img16[0];
    for (let i = 0; i < img16.length; i++) {
      mx = Math.max(mx, img16[i]);
    }
    for (let i = 1; i < nv; i++) {
      this.drawBitmap[i] = img16[i];
    }
    gl.deleteTexture(background);
    gl.deleteTexture(strength0);
    gl.deleteTexture(strength1);
    gl.deleteTexture(label0);
    gl.deleteTexture(label1);
    gl.bindVertexArray(this.unusedVAO);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(fb);
    this.drawAddUndoBitmap();
    this.refreshDrawing(true);
  }
  // not included in public docs
  // set color of single voxel in drawing
  drawPt(x, y, z, penValue) {
    if (!this.back?.dims) {
      throw new Error("back.dims not set");
    }
    const dx = this.back.dims[1];
    const dy = this.back.dims[2];
    const dz = this.back.dims[3];
    x = Math.min(Math.max(x, 0), dx - 1);
    y = Math.min(Math.max(y, 0), dy - 1);
    z = Math.min(Math.max(z, 0), dz - 1);
    this.drawBitmap[x + y * dx + z * dx * dy] = penValue;
    const isAx = this.drawPenAxCorSag === 0;
    const isCor = this.drawPenAxCorSag === 1;
    const isSag = this.drawPenAxCorSag === 2;
    if (this.opts.penSize > 1) {
      const halfPenSize = Math.floor(this.opts.penSize / 2);
      for (let i = -halfPenSize; i <= halfPenSize; i++) {
        for (let j = -halfPenSize; j <= halfPenSize; j++) {
          if (isAx) {
            this.drawBitmap[x + i + (y + j) * dx + z * dx * dy] = penValue;
          } else if (isCor) {
            this.drawBitmap[x + i + y * dx + (z + j) * dx * dy] = penValue;
          } else if (isSag) {
            this.drawBitmap[x + (y + j) * dx + (z + i) * dx * dy] = penValue;
          }
        }
      }
    }
  }
  // not included in public docs
  // create line between to voxels in drawing
  // https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
  // https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/
  // ptA, ptB are start and end points of line (each XYZ)
  drawPenLine(ptA, ptB, penValue) {
    const dx = Math.abs(ptA[0] - ptB[0]);
    const dy = Math.abs(ptA[1] - ptB[1]);
    const dz = Math.abs(ptA[2] - ptB[2]);
    let xs = -1;
    let ys = -1;
    let zs = -1;
    if (ptB[0] > ptA[0]) {
      xs = 1;
    }
    if (ptB[1] > ptA[1]) {
      ys = 1;
    }
    if (ptB[2] > ptA[2]) {
      zs = 1;
    }
    let x1 = ptA[0];
    let y1 = ptA[1];
    let z1 = ptA[2];
    const x2 = ptB[0];
    const y2 = ptB[1];
    const z2 = ptB[2];
    if (dx >= dy && dx >= dz) {
      let p1 = 2 * dy - dx;
      let p2 = 2 * dz - dx;
      while (x1 !== x2) {
        x1 += xs;
        if (p1 >= 0) {
          y1 += ys;
          p1 -= 2 * dx;
        }
        if (p2 >= 0) {
          z1 += zs;
          p2 -= 2 * dx;
        }
        p1 += 2 * dy;
        p2 += 2 * dz;
        this.drawPt(x1, y1, z1, penValue);
      }
    } else if (dy >= dx && dy >= dz) {
      let p1 = 2 * dx - dy;
      let p2 = 2 * dz - dy;
      while (y1 !== y2) {
        y1 += ys;
        if (p1 >= 0) {
          x1 += xs;
          p1 -= 2 * dy;
        }
        if (p2 >= 0) {
          z1 += zs;
          p2 -= 2 * dy;
        }
        p1 += 2 * dx;
        p2 += 2 * dz;
        this.drawPt(x1, y1, z1, penValue);
      }
    } else {
      let p1 = 2 * dy - dz;
      let p2 = 2 * dx - dz;
      while (z1 !== z2) {
        z1 += zs;
        if (p1 >= 0) {
          y1 += ys;
          p1 -= 2 * dz;
        }
        if (p2 >= 0) {
          x1 += xs;
          p2 -= 2 * dz;
        }
        p1 += 2 * dy;
        p2 += 2 * dx;
        this.drawPt(x1, y1, z1, penValue);
      }
    }
  }
  /**
   * Performs a 1-voxel binary dilation on a connected cluster within the drawing mask using the drawFloodFillCore function.
   *
   * @param seedXYZ -  voxel index of the seed voxel in the mask array.
   * @param neighbors - Number of neighbors to consider for connectivity and dilation (6, 18, or 26).
   */
  drawingBinaryDilationWithSeed(seedXYZ, neighbors = 6) {
    try {
      let xyz2vx = function(pt) {
        return pt[0] + pt[1] * nx + pt[2] * nxy;
      };
      const mask = this.drawBitmap;
      const xDim = this.back.dims[1];
      const yDim = this.back.dims[2];
      const zDim = this.back.dims[3];
      const nx = xDim;
      const nxy = xDim * yDim;
      const totalVoxels = nxy * zDim;
      const seedIndex = xyz2vx(seedXYZ);
      if (seedIndex < 0 || seedIndex >= totalVoxels) {
        throw new Error("Seed index is out of bounds.");
      }
      const seedValue = mask[seedIndex];
      if (seedValue === 0) {
        throw new Error("Seed voxel is not part of a filled cluster.");
      }
      const img = mask.slice();
      for (let i = 0; i < totalVoxels; i++) {
        img[i] = img[i] === seedValue ? 1 : 0;
      }
      this.drawFloodFillCore(img, seedIndex, neighbors);
      const outputMask = mask.slice();
      const neighborOffsets = [];
      const offsets6 = [-nxy, nxy, -xDim, xDim, -1, 1];
      neighborOffsets.push(...offsets6);
      if (neighbors > 6) {
        neighborOffsets.push(
          -xDim - 1,
          -xDim + 1,
          xDim - 1,
          xDim + 1,
          -nxy - xDim,
          -nxy + xDim,
          -nxy - 1,
          -nxy + 1,
          nxy - xDim,
          nxy + xDim,
          nxy - 1,
          nxy + 1
        );
      }
      if (neighbors > 18) {
        neighborOffsets.push(
          -nxy - xDim - 1,
          -nxy - xDim + 1,
          -nxy + xDim - 1,
          -nxy + xDim + 1,
          nxy - xDim - 1,
          nxy - xDim + 1,
          nxy + xDim - 1,
          nxy + xDim + 1
        );
      }
      for (let idx = 0; idx < totalVoxels; idx++) {
        if (img[idx] === 2) {
          const x = idx % xDim;
          const y = Math.floor(idx % nxy / xDim);
          const z = Math.floor(idx / nxy);
          for (const offset of neighborOffsets) {
            const neighborIdx = idx + offset;
            if (neighborIdx < 0 || neighborIdx >= totalVoxels) {
              continue;
            }
            const nx2 = neighborIdx % xDim;
            const ny = Math.floor(neighborIdx % nxy / xDim);
            const nz = Math.floor(neighborIdx / nxy);
            if (Math.abs(nx2 - x) > 1 || Math.abs(ny - y) > 1 || Math.abs(nz - z) > 1) {
              continue;
            }
            if (mask[neighborIdx] === 0) {
              outputMask[neighborIdx] = seedValue;
            }
          }
        }
      }
      this.drawBitmap = outputMask;
      this.drawAddUndoBitmap();
      this.refreshDrawing(true);
    } catch (error) {
      log.error("Error in drawingBinaryDilationWithSeed:", error);
    }
  }
  // a voxel can be defined as having 6, 18 or 26 neighbors:
  //   6: neighbors share faces (distance=1)
  //  18: neighbors share faces (distance=1) or edges (1.4)
  //  26: neighbors share faces (distance=1), edges (1.4) or corners (1.7)
  drawFloodFillCore(img, seedVx, neighbors = 6) {
    if (!this.back?.dims) {
      throw new Error("back.dims undefined");
    }
    const dims = [this.back.dims[1], this.back.dims[2], this.back.dims[3]];
    const nx = dims[0];
    const nxy = nx * dims[1];
    function xyz2vx(pt) {
      return pt[0] + pt[1] * nx + pt[2] * nxy;
    }
    function vx2xyz(vx) {
      const Z = Math.floor(vx / nxy);
      const Y = Math.floor((vx - Z * nxy) / nx);
      const X = Math.floor(vx % nx);
      return [X, Y, Z];
    }
    const Q = [];
    Q.push(seedVx);
    img[seedVx] = 2;
    while (Q.length > 0) {
      let testNeighbor = function(offset) {
        const xyzN = xyz.slice();
        xyzN[0] += offset[0];
        xyzN[1] += offset[1];
        xyzN[2] += offset[2];
        if (xyzN[0] < 0 || xyzN[1] < 0 || xyzN[2] < 0) {
          return;
        }
        if (xyzN[0] >= dims[0] || xyzN[1] >= dims[1] || xyzN[2] >= dims[2]) {
          return;
        }
        const vxT = xyz2vx(xyzN);
        if (img[vxT] !== 1) {
          return;
        }
        img[vxT] = 2;
        Q.push(vxT);
      };
      const vx = Q[0];
      Q.shift();
      const xyz = vx2xyz(vx);
      testNeighbor([0, 0, -1]);
      testNeighbor([0, 0, 1]);
      testNeighbor([0, -1, 0]);
      testNeighbor([0, 1, 0]);
      testNeighbor([-1, 0, 0]);
      testNeighbor([1, 0, 0]);
      if (neighbors <= 6) {
        continue;
      }
      testNeighbor([-1, -1, 0]);
      testNeighbor([1, 1, 0]);
      testNeighbor([-1, 1, 0]);
      testNeighbor([1, 1, 0]);
      testNeighbor([0, -1, -1]);
      testNeighbor([0, 1, -1]);
      testNeighbor([-1, 0, -1]);
      testNeighbor([1, 0, -1]);
      testNeighbor([0, -1, 1]);
      testNeighbor([0, 1, 1]);
      testNeighbor([-1, 0, 1]);
      testNeighbor([1, 0, 1]);
      if (neighbors <= 18) {
        continue;
      }
      testNeighbor([-1, -1, -1]);
      testNeighbor([1, -1, -1]);
      testNeighbor([-1, 1, -1]);
      testNeighbor([1, 1, -1]);
      testNeighbor([-1, -1, 1]);
      testNeighbor([1, -1, 1]);
      testNeighbor([-1, 1, 1]);
      testNeighbor([1, 1, 1]);
    }
  }
  // not included in public docs
  // set all connected voxels in drawing to new color
  drawFloodFill(seedXYZ, newColor = 0, growSelectedCluster = 0, forceMin = NaN, forceMax = NaN, neighbors = 6, maxDistanceMM = Number.POSITIVE_INFINITY, is2D = false) {
    if (!this.drawBitmap) {
      throw new Error("drawBitmap undefined");
    }
    if (!this.back?.dims) {
      throw new Error("back.dims undefined");
    }
    newColor = Math.abs(newColor);
    const dims = [this.back.dims[1], this.back.dims[2], this.back.dims[3]];
    if (seedXYZ[0] < 0 || seedXYZ[1] < 0 || seedXYZ[2] < 0) {
      return;
    }
    if (seedXYZ[0] >= dims[0] || seedXYZ[1] >= dims[1] || seedXYZ[2] >= dims[2]) {
      return;
    }
    const nx = dims[0];
    const nxy = nx * dims[1];
    const nxyz = nxy * dims[2];
    let img = this.drawBitmap.slice();
    let drawBitmap = this.drawBitmap;
    if (this.clickToSegmentIsGrowing) {
      img = this.clickToSegmentGrowingBitmap.slice();
      drawBitmap = this.clickToSegmentGrowingBitmap;
    }
    if (img.length !== nxy * dims[2]) {
      return;
    }
    let constrainXYZ = -1;
    if (is2D && this.drawPenAxCorSag === 0 /* AXIAL */) {
      constrainXYZ = 2;
    } else if (is2D && this.drawPenAxCorSag === 1 /* CORONAL */) {
      constrainXYZ = 1;
    } else if (is2D && this.drawPenAxCorSag === 2 /* SAGITTAL */) {
      constrainXYZ = 0;
    }
    function vx2xyz(vx) {
      const Z = Math.floor(vx / nxy);
      const Y = Math.floor((vx - Z * nxy) / nx);
      const X = Math.floor(vx % nx);
      return [X, Y, Z];
    }
    function xyz2vx(pt) {
      return pt[0] + pt[1] * nx + pt[2] * nxy;
    }
    const vx2mm = (xyz) => {
      return this.vox2mm(xyz, this.back.matRAS);
    };
    const seedMM = vx2mm(seedXYZ);
    const maxDistanceMM2 = maxDistanceMM ** 2;
    function isWithinDistance(vx) {
      const xzyVox = vx2xyz(vx);
      if (constrainXYZ >= 0 && xzyVox[constrainXYZ] !== seedXYZ[constrainXYZ]) {
        return false;
      }
      const xyzMM = vx2mm(xzyVox);
      const dist22 = (xyzMM[0] - seedMM[0]) ** 2 + (xyzMM[1] - seedMM[1]) ** 2 + (xyzMM[2] - seedMM[2]) ** 2;
      return dist22 <= maxDistanceMM2;
    }
    const seedVx = xyz2vx(seedXYZ);
    const seedColor = img[seedVx];
    if (seedColor === newColor) {
      if (growSelectedCluster !== 0) {
        log.debug("drawFloodFill selected voxel is not part of a drawing");
      } else {
        log.debug("drawFloodFill selected voxel is already desired color");
      }
      return;
    }
    for (let i = 1; i < nxyz; i++) {
      img[i] = 0;
      if (drawBitmap[i] === seedColor) {
        if (!isWithinDistance(i)) {
          continue;
        }
        img[i] = 1;
      }
    }
    this.drawFloodFillCore(img, seedVx, neighbors);
    if (growSelectedCluster !== 0) {
      const backImg = this.volumes[0].img2RAS();
      let mx = backImg[seedVx];
      let mn = mx;
      if (isFinite(forceMax) && isFinite(forceMin)) {
        mx = forceMax;
        mn = forceMin;
      } else {
        for (let i = 1; i < nxyz; i++) {
          if (img[i] === 2) {
            mx = Math.max(mx, backImg[i]);
            mn = Math.min(mn, backImg[i]);
          }
        }
        if (growSelectedCluster === Number.POSITIVE_INFINITY) {
          mx = growSelectedCluster;
        }
        if (growSelectedCluster === Number.NEGATIVE_INFINITY) {
          mn = growSelectedCluster;
        }
      }
      log.debug("Intensity range of selected cluster :", mn, mx);
      for (let i = 1; i < nxyz; i++) {
        img[i] = 0;
        if (backImg[i] >= mn && backImg[i] <= mx) {
          if (!isWithinDistance(i)) {
            continue;
          }
          img[i] = 1;
        }
      }
      this.drawFloodFillCore(img, seedVx, neighbors);
      newColor = seedColor;
    }
    for (let i = 1; i < nxyz; i++) {
      if (img[i] === 2) {
        drawBitmap[i] = newColor;
      }
    }
    if (!this.clickToSegmentIsGrowing) {
      this.drawBitmap = drawBitmap.slice();
      if (!this.opts.clickToSegment) {
        this.drawAddUndoBitmap();
      }
      this.refreshDrawing(true, this.clickToSegmentIsGrowing);
    } else {
      this.clickToSegmentGrowingBitmap = drawBitmap;
      this.refreshDrawing(true, this.clickToSegmentIsGrowing);
    }
  }
  // not included in public docs
  // given series of line segments, connect first and last
  // voxel and fill the interior of the line segments
  drawPenFilled() {
    const nPts = this.drawPenFillPts.length;
    if (nPts < 2) {
      this.drawPenFillPts = [];
      return;
    }
    const axCorSag = this.drawPenAxCorSag;
    let h = 0;
    let v = 1;
    if (axCorSag === 1) {
      v = 2;
    }
    if (axCorSag === 2) {
      h = 1;
      v = 2;
    }
    if (!this.back?.dims) {
      throw new Error("back.dims undefined");
    }
    const dims2D = [this.back.dims[h + 1], this.back.dims[v + 1]];
    const img2D = new Uint8Array(dims2D[0] * dims2D[1]);
    let pen = 1;
    function drawLine2D(ptA, ptB) {
      const dx = Math.abs(ptA[0] - ptB[0]);
      const dy = Math.abs(ptA[1] - ptB[1]);
      img2D[ptA[0] + ptA[1] * dims2D[0]] = pen;
      img2D[ptB[0] + ptB[1] * dims2D[0]] = pen;
      let xs = -1;
      let ys = -1;
      if (ptB[0] > ptA[0]) {
        xs = 1;
      }
      if (ptB[1] > ptA[1]) {
        ys = 1;
      }
      let x1 = ptA[0];
      let y1 = ptA[1];
      const x2 = ptB[0];
      const y2 = ptB[1];
      if (dx >= dy) {
        let p1 = 2 * dy - dx;
        while (x1 !== x2) {
          x1 += xs;
          if (p1 >= 0) {
            y1 += ys;
            p1 -= 2 * dx;
          }
          p1 += 2 * dy;
          img2D[x1 + y1 * dims2D[0]] = pen;
        }
      } else {
        let p1 = 2 * dx - dy;
        while (y1 !== y2) {
          y1 += ys;
          if (p1 >= 0) {
            x1 += xs;
            p1 -= 2 * dy;
          }
          p1 += 2 * dx;
          img2D[x1 + y1 * dims2D[0]] = pen;
        }
      }
    }
    const startPt = [this.drawPenFillPts[0][h], this.drawPenFillPts[0][v]];
    let prevPt = startPt;
    for (let i = 1; i < nPts; i++) {
      const pt = [this.drawPenFillPts[i][h], this.drawPenFillPts[i][v]];
      drawLine2D(prevPt, pt);
      prevPt = pt;
    }
    drawLine2D(startPt, prevPt);
    const seeds = [];
    function setSeed(pt) {
      if (pt[0] < 0 || pt[1] < 0 || pt[0] >= dims2D[0] || pt[1] >= dims2D[1]) {
        return;
      }
      const pxl = pt[0] + pt[1] * dims2D[0];
      if (img2D[pxl] !== 0) {
        return;
      }
      seeds.push(pt);
      img2D[pxl] = 2;
    }
    for (let i = 0; i < dims2D[0]; i++) {
      setSeed([i, 0]);
    }
    for (let i = 0; i < dims2D[0]; i++) {
      setSeed([i, dims2D[1] - 1]);
    }
    for (let i = 0; i < dims2D[1]; i++) {
      setSeed([0, i]);
    }
    for (let i = 0; i < dims2D[1]; i++) {
      setSeed([dims2D[0] - 1, i]);
    }
    while (seeds.length > 0) {
      const seed = seeds.shift();
      setSeed([seed[0] - 1, seed[1]]);
      setSeed([seed[0] + 1, seed[1]]);
      setSeed([seed[0], seed[1] - 1]);
      setSeed([seed[0], seed[1] + 1]);
    }
    pen = this.opts.penValue;
    const slice = this.drawPenFillPts[0][3 - (h + v)];
    if (!this.drawBitmap) {
      throw new Error("drawBitmap undefined");
    }
    if (axCorSag === 0) {
      const offset = slice * dims2D[0] * dims2D[1];
      for (let i = 0; i < dims2D[0] * dims2D[1]; i++) {
        if (img2D[i] !== 2) {
          this.drawBitmap[i + offset] = pen;
        }
      }
    } else {
      let xStride = 1;
      const yStride = this.back.dims[1] * this.back.dims[2];
      let zOffset = slice * this.back.dims[1];
      if (axCorSag === 2) {
        xStride = this.back.dims[1];
        zOffset = slice;
      }
      let i = 0;
      for (let y = 0; y < dims2D[1]; y++) {
        for (let x = 0; x < dims2D[0]; x++) {
          if (img2D[i] !== 2) {
            this.drawBitmap[x * xStride + y * yStride + zOffset] = pen;
          }
          i++;
        }
      }
    }
    if (!this.drawFillOverwrites && this.drawUndoBitmaps[this.currentDrawUndoBitmap].length > 0) {
      const nv = this.drawBitmap.length;
      const bmp = decodeRLE(this.drawUndoBitmaps[this.currentDrawUndoBitmap], nv);
      for (let i = 0; i < nv; i++) {
        if (bmp[i] === 0) {
          continue;
        }
        this.drawBitmap[i] = bmp[i];
      }
    }
    this.drawPenFillPts = [];
    this.drawAddUndoBitmap();
    this.refreshDrawing(false);
  }
  /**
   * close drawing: make sure you have saved any changes before calling this!
   * @example niivue.closeDrawing();
   * @see {@link https://niivue.github.io/niivue/features/draw.ui.html | live demo usage}
   */
  closeDrawing() {
    this.drawClearAllUndoBitmaps();
    this.rgbaTex(this.drawTexture, TEXTURE7_DRAW, [2, 2, 2, 2], true);
    this.drawBitmap = null;
    this.clickToSegmentGrowingBitmap = null;
    this.drawScene();
  }
  /**
   * copy drawing bitmap from CPU to GPU storage and redraw the screen
   * @param isForceRedraw - refreshes scene immediately (default true)
   * @example niivue.refreshDrawing();
   * @see {@link https://niivue.github.io/niivue/features/cactus.html | live demo usage}
   */
  refreshDrawing(isForceRedraw = true, useClickToSegmentBitmap = false) {
    if (!this.back?.dims) {
      throw new Error("back.dims undefined");
    }
    if (!this.drawBitmap) {
      throw new Error("drawBitmap undefined");
    }
    const dims = this.back.dims.slice();
    const vx = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
    if (this.drawBitmap.length === 8) {
      dims[1] = 2;
      dims[2] = 2;
      dims[3] = 2;
    } else if (vx !== this.drawBitmap.length) {
      log.warn("Drawing bitmap must match the background image");
    }
    this.gl.activeTexture(TEXTURE7_DRAW);
    this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture);
    this.gl.texSubImage3D(
      this.gl.TEXTURE_3D,
      0,
      0,
      0,
      0,
      dims[1],
      dims[2],
      dims[3],
      this.gl.RED,
      this.gl.UNSIGNED_BYTE,
      useClickToSegmentBitmap ? this.clickToSegmentGrowingBitmap : this.drawBitmap
    );
    if (isForceRedraw) {
      this.drawScene();
    }
  }
  // not included in public docs
  // create 3D 1-component (red) uint8 texture on GPU
  r8Tex(texID, activeID, dims, isInit = false) {
    if (texID) {
      this.gl.deleteTexture(texID);
    }
    texID = this.gl.createTexture();
    this.gl.activeTexture(activeID);
    this.gl.bindTexture(this.gl.TEXTURE_3D, texID);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8, dims[1], dims[2], dims[3]);
    if (isInit) {
      const img8 = new Uint8Array(dims[1] * dims[2] * dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        dims[1],
        dims[2],
        dims[3],
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        img8
      );
    }
    return texID;
  }
  // not included in public docs
  // create 3D 4-component (red,green,blue,alpha) uint8 texture on GPU
  rgbaTex(texID, activeID, dims, isInit = false) {
    if (texID) {
      this.gl.deleteTexture(texID);
    }
    texID = this.gl.createTexture();
    this.gl.activeTexture(activeID);
    this.gl.bindTexture(this.gl.TEXTURE_3D, texID);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8, dims[1], dims[2], dims[3]);
    if (isInit) {
      const img8 = new Uint8Array(dims[1] * dims[2] * dims[3] * 4);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        dims[1],
        dims[2],
        dims[3],
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        img8
      );
    }
    return texID;
  }
  // not included in public docs
  // create 3D 4-component (red,green,blue,alpha) uint16 texture on GPU
  rgba16Tex(texID, activeID, dims, isInit = false) {
    if (texID) {
      this.gl.deleteTexture(texID);
    }
    texID = this.gl.createTexture();
    this.gl.activeTexture(activeID);
    this.gl.bindTexture(this.gl.TEXTURE_3D, texID);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2);
    this.gl.pixelStorei(this.gl.PACK_ALIGNMENT, 2);
    this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA16UI, dims[1], dims[2], dims[3]);
    if (isInit) {
      const img16 = new Uint16Array(dims[1] * dims[2] * dims[3] * 4);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        dims[1],
        dims[2],
        dims[3],
        this.gl.RGBA_INTEGER,
        this.gl.UNSIGNED_SHORT,
        img16
      );
    }
    return texID;
  }
  // not included in public docs
  // remove cross origin if not from same domain. From https://webglfundamentals.org/webgl/lessons/webgl-cors-permission.html
  requestCORSIfNotSameOrigin(img, url) {
    if (new URL(url, window.location.href).origin !== window.location.origin) {
      img.crossOrigin = "";
    }
  }
  // not included in public docs
  // creates 4-component (red,green,blue,alpha) uint8 texture on GPU
  async loadPngAsTexture(pngUrl, textureNum) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        if (!this.bmpShader) {
          return;
        }
        let pngTexture;
        if (textureNum === 4) {
          if (this.bmpTexture !== null) {
            this.gl.deleteTexture(this.bmpTexture);
          }
          this.bmpTexture = this.gl.createTexture();
          pngTexture = this.bmpTexture;
          this.bmpTextureWH = img.width / img.height;
          this.gl.activeTexture(TEXTURE4_THUMBNAIL);
          this.bmpShader.use(this.gl);
          this.gl.uniform1i(this.bmpShader.uniforms.bmpTexture, 4);
        } else if (textureNum === 5) {
          this.gl.activeTexture(TEXTURE5_MATCAP);
          if (this.matCapTexture !== null) {
            this.gl.deleteTexture(this.matCapTexture);
          }
          this.matCapTexture = this.gl.createTexture();
          pngTexture = this.matCapTexture;
        } else {
          this.fontShader.use(this.gl);
          this.gl.activeTexture(TEXTURE3_FONT);
          this.gl.uniform1i(this.fontShader.uniforms.fontTexture, 3);
          if (this.fontTexture !== null) {
            this.gl.deleteTexture(this.fontTexture);
          }
          this.fontTexture = this.gl.createTexture();
          pngTexture = this.fontTexture;
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, pngTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
        resolve(pngTexture);
        if (textureNum !== 4) {
          this.drawScene();
        }
      };
      img.onerror = reject;
      this.requestCORSIfNotSameOrigin(img, pngUrl);
      img.src = pngUrl;
    });
  }
  // not included in public docs
  // load font stored as PNG bitmap with texture unit 3
  async loadFontTexture(fontUrl) {
    return this.loadPngAsTexture(fontUrl, 3);
  }
  // not included in public docs
  // load PNG bitmap with texture unit 4
  async loadBmpTexture(bmpUrl) {
    return this.loadPngAsTexture(bmpUrl, 4);
  }
  /**
   * Load matcap for illumination model.
   * @param name - name of matcap to load ("Shiny", "Cortex", "Cream")
   * @example
   * niivue.loadMatCapTexture("Cortex");
   * @see {@link https://niivue.github.io/niivue/features/shiny.volumes.html | live demo usage}
   */
  async loadMatCapTexture(bmpUrl) {
    return this.loadPngAsTexture(bmpUrl, 5);
  }
  // not included in public docs
  // load font bitmap and metrics
  initFontMets() {
    if (!this.fontMetrics) {
      throw new Error("fontMetrics undefined");
    }
    this.fontMets = {
      distanceRange: this.fontMetrics.atlas.distanceRange,
      size: this.fontMetrics.atlas.size,
      mets: {}
    };
    for (let id = 0; id < 256; id++) {
      this.fontMets.mets[id] = {
        xadv: 0,
        uv_lbwh: [0, 0, 0, 0],
        lbwh: [0, 0, 0, 0]
      };
    }
    const scaleW = this.fontMetrics.atlas.width;
    const scaleH = this.fontMetrics.atlas.height;
    for (let i = 0; i < this.fontMetrics.glyphs.length; i++) {
      const glyph = this.fontMetrics.glyphs[i];
      const id = glyph.unicode;
      this.fontMets.mets[id].xadv = glyph.advance;
      if (glyph.planeBounds === void 0) {
        continue;
      }
      let l = glyph.atlasBounds.left / scaleW;
      let b = (scaleH - glyph.atlasBounds.top) / scaleH;
      let w = (glyph.atlasBounds.right - glyph.atlasBounds.left) / scaleW;
      let h = (glyph.atlasBounds.top - glyph.atlasBounds.bottom) / scaleH;
      this.fontMets.mets[id].uv_lbwh = [l, b, w, h];
      l = glyph.planeBounds.left;
      b = glyph.planeBounds.bottom;
      w = glyph.planeBounds.right - glyph.planeBounds.left;
      h = glyph.planeBounds.top - glyph.planeBounds.bottom;
      this.fontMets.mets[id].lbwh = [l, b, w, h];
    }
  }
  /**
   * Load typeface for colorbars, measurements and orientation text.
   * @param name - name of matcap to load ("Roboto", "Garamond", "Ubuntu")
   * @example
   * niivue.loadMatCapTexture("Cortex");
   * @see {@link https://niivue.github.io/niivue/features/selectfont.html | live demo usage}
   */
  async loadFont(fontSheetUrl = Roboto_Regular_default, metricsUrl = Roboto_Regular_default2) {
    await this.loadFontTexture(fontSheetUrl);
    const response = await fetch(metricsUrl);
    if (!response.ok) {
      throw Error(response.statusText);
    }
    const jsonText = await response.text();
    this.fontMetrics = JSON.parse(jsonText);
    this.initFontMets();
    this.fontShader.use(this.gl);
    this.drawScene();
  }
  // not included in public docs
  async loadDefaultMatCap() {
    return this.loadMatCapTexture(Shiny_default);
  }
  // not included in public docs
  async loadDefaultFont() {
    await this.loadFontTexture(this.DEFAULT_FONT_GLYPH_SHEET);
    this.fontMetrics = this.DEFAULT_FONT_METRICS;
    this.initFontMets();
  }
  // not included in public docs
  async initText() {
    this.fontShader = new Shader(this.gl, vertFontShader, fragFontShader);
    this.fontShader.use(this.gl);
    await this.loadDefaultFont();
    await this.loadDefaultMatCap();
    this.drawLoadingText(this.opts.loadingText);
  }
  // not included in public docs
  meshShaderNameToNumber(meshShaderName = "Phong") {
    const name = meshShaderName.toLowerCase();
    for (let i = 0; i < this.meshShaders.length; i++) {
      if (this.meshShaders[i].Name.toLowerCase() === name) {
        return i;
      }
    }
  }
  /**
   * select new shader for triangulated meshes and connectomes. Note that this function requires the mesh is fully loaded: you may want use `await` with loadMeshes (as seen in live demo).
   * @param id - id of mesh to change
   * @param meshShaderNameOrNumber - identify shader for usage
   * @example niivue.setMeshShader('toon');
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  setMeshShader(id, meshShaderNameOrNumber = 2) {
    let shaderIndex = 0;
    if (typeof meshShaderNameOrNumber === "number") {
      shaderIndex = meshShaderNameOrNumber;
    } else {
      shaderIndex = this.meshShaderNameToNumber(meshShaderNameOrNumber);
    }
    if (shaderIndex === void 0) {
      throw new Error("shaderIndex undefined");
    }
    shaderIndex = Math.min(shaderIndex, this.meshShaders.length - 1);
    shaderIndex = Math.max(shaderIndex, 0);
    const index = this.getMeshIndexByID(id);
    if (index >= this.meshes.length) {
      log.debug("Unable to change shader until mesh is loaded (maybe you need async)");
      return;
    }
    this.meshes[index].meshShaderIndex = shaderIndex;
    this.updateGLVolume();
    this.onMeshShaderChanged(index, shaderIndex);
  }
  /**
   *
   * @param fragmentShaderText - custom fragment shader.
   * @param name - title for new shader.
   * @returns created custom mesh shader
   */
  createCustomMeshShader(fragmentShaderText, name = "Custom") {
    if (!fragmentShaderText) {
      throw new Error("Need fragment shader");
    }
    const num = this.meshShaderNameToNumber(name);
    if (num >= 0) {
      this.gl.deleteProgram(this.meshShaders[num].shader.program);
      this.meshShaders.splice(num, 1);
    }
    const shader = new Shader(this.gl, vertMeshShader, fragmentShaderText);
    shader.use(this.gl);
    return {
      Name: name,
      Frag: fragmentShaderText,
      shader
    };
  }
  /**
   * Define a new GLSL shader program to influence mesh coloration
   * @param fragmentShaderText - custom fragment shader.
   * @param ame - title for new shader.
   * @returns index of the new shader (for setMeshShader)
   * @see {@link https://niivue.github.io/niivue/features/mesh.atlas.html | live demo usage}
   */
  setCustomMeshShader(fragmentShaderText = "", name = "Custom") {
    const m = this.createCustomMeshShader(fragmentShaderText, name);
    this.meshShaders.push(m);
    this.onCustomMeshShaderAdded(fragmentShaderText, name);
    return this.meshShaders.length - 1;
  }
  /**
   * retrieve all currently loaded meshes
   * @param sort - sort output alphabetically
   * @returns list of available mesh shader names
   * @example niivue.meshShaderNames();
   * @see {@link https://niivue.github.io/niivue/features/meshes.html | live demo usage}
   */
  meshShaderNames(sort = true) {
    const cm = [];
    for (let i = 0; i < this.meshShaders.length; i++) {
      cm.push(this.meshShaders[i].Name);
    }
    return sort === true ? cm.sort() : cm;
  }
  // not included in public docs
  initRenderShader(shader, gradientAmount = 0) {
    shader.use(this.gl);
    this.gl.uniform1i(shader.uniforms.volume, 0);
    this.gl.uniform1i(shader.uniforms.colormap, 1);
    this.gl.uniform1i(shader.uniforms.overlay, 2);
    this.gl.uniform1i(shader.uniforms.drawing, 7);
    this.gl.uniform1fv(shader.uniforms.renderDrawAmbientOcclusion, [this.renderDrawAmbientOcclusion, 1]);
    this.gl.uniform1f(shader.uniforms.gradientAmount, gradientAmount);
    const gradientOpacityLut = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
      if (this.opts.gradientOpacity === 0) {
        gradientOpacityLut[i] = 1;
      } else {
        gradientOpacityLut[i] = Math.pow(i / 255, this.opts.gradientOpacity * 8);
      }
    }
    this.gl.uniform1fv(this.gl.getUniformLocation(shader.program, "gradientOpacity"), gradientOpacityLut);
  }
  // not included in public docs
  async init() {
    const rendererInfo = this.gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo) {
      const vendor = this.gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
      const renderer = this.gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      log.info("renderer vendor: ", vendor);
      log.info("renderer: ", renderer);
    } else {
      log.info("debug_renderer_info unavailable");
    }
    const glInfo = this.gl.getParameter(this.gl.RENDERER);
    log.info("firefox renderer: ", glInfo);
    this.gl.clearDepth(0);
    this.gl.enable(this.gl.CULL_FACE);
    this.gl.cullFace(this.gl.FRONT);
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
    this.volumeTexture = this.rgbaTex(this.volumeTexture, TEXTURE0_BACK_VOL, [2, 2, 2, 2], true);
    this.overlayTexture = this.rgbaTex(this.overlayTexture, TEXTURE2_OVERLAY_VOL, [2, 2, 2, 2], true);
    this.drawTexture = this.r8Tex(this.drawTexture, TEXTURE7_DRAW, [2, 2, 2, 2], true);
    const rectStrip = [
      1,
      1,
      0,
      // RAI
      1,
      0,
      0,
      // RPI
      0,
      1,
      0,
      // LAI
      0,
      0,
      0
      // LPI
    ];
    const gl = this.gl;
    this.cuboidVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.cuboidVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rectStrip), gl.STATIC_DRAW);
    this.genericVAO = gl.createVertexArray();
    gl.bindVertexArray(this.genericVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.cuboidVertexBuffer);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(this.unusedVAO);
    this.pickingMeshShader = new Shader(gl, vertMeshShader, fragMeshDepthShader);
    this.pickingMeshShader.use(gl);
    this.pickingImageShader = new Shader(gl, vertRenderShader, fragVolumePickingShader);
    this.pickingImageShader.use(gl);
    gl.uniform1i(this.pickingImageShader.uniforms.volume, 0);
    gl.uniform1i(this.pickingImageShader.uniforms.colormap, 1);
    gl.uniform1i(this.pickingImageShader.uniforms.overlay, 2);
    gl.uniform1i(this.pickingImageShader.uniforms.drawing, 7);
    this.sliceMMShader = new Shader(gl, vertSliceMMShader, fragSliceMMShader);
    this.sliceMMShader.use(gl);
    gl.uniform1i(this.sliceMMShader.uniforms.volume, 0);
    gl.uniform1i(this.sliceMMShader.uniforms.colormap, 1);
    gl.uniform1i(this.sliceMMShader.uniforms.overlay, 2);
    gl.uniform1i(this.sliceMMShader.uniforms.drawing, 7);
    gl.uniform1f(this.sliceMMShader.uniforms.drawOpacity, this.drawOpacity);
    this.sliceV1Shader = new Shader(gl, vertSliceMMShader, fragSliceV1Shader);
    this.sliceV1Shader.use(gl);
    gl.uniform1i(this.sliceV1Shader.uniforms.volume, 0);
    gl.uniform1i(this.sliceV1Shader.uniforms.colormap, 1);
    gl.uniform1i(this.sliceV1Shader.uniforms.overlay, 2);
    gl.uniform1i(this.sliceV1Shader.uniforms.drawing, 7);
    gl.uniform1f(this.sliceV1Shader.uniforms.drawOpacity, this.drawOpacity);
    this.orientCubeShader = new Shader(gl, vertOrientCubeShader, fragOrientCubeShader);
    this.orientCubeShaderVAO = gl.createVertexArray();
    gl.bindVertexArray(this.orientCubeShaderVAO);
    const positionBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, orientCube, gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);
    gl.bindVertexArray(this.unusedVAO);
    this.rectShader = new Shader(gl, vertRectShader, fragRectShader);
    this.rectShader.use(gl);
    this.rectOutlineShader = new Shader(gl, vertRectShader, fragRectOutlineShader);
    this.rectOutlineShader.use(gl);
    this.lineShader = new Shader(gl, vertLineShader, fragRectShader);
    this.lineShader.use(gl);
    this.line3DShader = new Shader(gl, vertLine3DShader, fragRectShader);
    this.line3DShader.use(gl);
    this.circleShader = new Shader(gl, vertCircleShader, fragCircleShader);
    this.circleShader.use(gl);
    this.renderVolumeShader = new Shader(gl, vertRenderShader, fragRenderShader);
    this.initRenderShader(this.renderVolumeShader);
    this.renderSliceShader = new Shader(gl, vertRenderShader, fragRenderSliceShader);
    this.initRenderShader(this.renderSliceShader);
    this.renderGradientShader = new Shader(gl, vertRenderShader, fragRenderGradientShader);
    this.initRenderShader(this.renderGradientShader, 0.3);
    gl.uniform1i(this.renderGradientShader.uniforms.matCap, 5);
    gl.uniform1i(this.renderGradientShader.uniforms.gradient, 6);
    this.renderGradientValuesShader = new Shader(gl, vertRenderShader, fragRenderGradientValuesShader);
    this.initRenderShader(this.renderGradientValuesShader);
    gl.uniform1i(this.renderGradientValuesShader.uniforms.matCap, 5);
    gl.uniform1i(this.renderGradientValuesShader.uniforms.gradient, 6);
    this.renderShader = this.renderVolumeShader;
    this.colorbarShader = new Shader(gl, vertColorbarShader, fragColorbarShader);
    this.colorbarShader.use(gl);
    gl.uniform1i(this.colorbarShader.uniforms.colormap, 1);
    this.blurShader = new Shader(gl, blurVertShader, blurFragShader);
    this.sobelBlurShader = new Shader(gl, blurVertShader, sobelBlurFragShader);
    this.sobelFirstOrderShader = new Shader(gl, blurVertShader, sobelFirstOrderFragShader);
    this.sobelSecondOrderShader = new Shader(gl, blurVertShader, sobelSecondOrderFragShader);
    this.growCutShader = new Shader(gl, vertGrowCutShader, fragGrowCutShader);
    this.passThroughShader = new Shader(gl, vertPassThroughShader, fragPassThroughShader);
    this.orientShaderAtlasU = new Shader(gl, vertOrientShader, fragOrientShaderU.concat(fragOrientShaderAtlas));
    this.orientShaderAtlasI = new Shader(gl, vertOrientShader, fragOrientShaderI.concat(fragOrientShaderAtlas));
    this.orientShaderU = new Shader(gl, vertOrientShader, fragOrientShaderU.concat(fragOrientShader));
    this.orientShaderI = new Shader(gl, vertOrientShader, fragOrientShaderI.concat(fragOrientShader));
    this.orientShaderF = new Shader(gl, vertOrientShader, fragOrientShaderF.concat(fragOrientShader));
    this.orientShaderRGBU = new Shader(gl, vertOrientShader, fragOrientShaderU.concat(fragRGBOrientShader));
    this.surfaceShader = new Shader(gl, vertSurfaceShader, fragSurfaceShader);
    this.surfaceShader.use(gl);
    this.fiberShader = new Shader(gl, vertFiberShader, fragFiberShader);
    this.pickingImageShader.use(gl);
    for (let i = 0; i < this.meshShaders.length; i++) {
      const m = this.meshShaders[i];
      if (m.Name === "Flat") {
        m.shader = new Shader(gl, vertFlatMeshShader, fragFlatMeshShader);
      } else {
        m.shader = new Shader(gl, vertMeshShader, m.Frag);
      }
      m.shader.use(gl);
      m.shader.isMatcap = m.Name === "Matcap";
      if (m.shader.isMatcap) {
        gl.uniform1i(m.shader.uniforms.matCap, 5);
      }
    }
    this.bmpShader = new Shader(gl, vertBmpShader, fragBmpShader);
    await this.initText();
    if (this.opts.thumbnail.length > 0) {
      await this.loadBmpTexture(this.opts.thumbnail);
      this.thumbnailVisible = true;
    }
    this.updateGLVolume();
    this.initialized = true;
    this.resizeListener();
    this.drawScene();
    return this;
  }
  gradientGL(hdr) {
    const gl = this.gl;
    const faceStrip = [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0];
    const vao2 = gl.createVertexArray();
    gl.bindVertexArray(vao2);
    const vbo2 = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceStrip), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.disable(gl.CULL_FACE);
    gl.viewport(0, 0, hdr.dims[1], hdr.dims[2]);
    gl.disable(gl.BLEND);
    const tempTex3D = this.rgbaTex(null, TEXTURE8_GRADIENT_TEMP, hdr.dims, true);
    const blurShader = this.opts.gradientOrder === 2 ? this.sobelBlurShader : this.blurShader;
    blurShader.use(gl);
    gl.activeTexture(TEXTURE0_BACK_VOL);
    gl.bindTexture(gl.TEXTURE_3D, this.volumeTexture);
    const blurRadius = 0.7;
    gl.uniform1i(blurShader.uniforms.intensityVol, 0);
    gl.uniform1f(blurShader.uniforms.dX, blurRadius / hdr.dims[1]);
    gl.uniform1f(blurShader.uniforms.dY, blurRadius / hdr.dims[2]);
    gl.uniform1f(blurShader.uniforms.dZ, blurRadius / hdr.dims[3]);
    gl.bindVertexArray(vao2);
    for (let i = 0; i < hdr.dims[3] - 1; i++) {
      const coordZ = 1 / hdr.dims[3] * (i + 0.5);
      gl.uniform1f(blurShader.uniforms.coordZ, coordZ);
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, tempTex3D, 0, i);
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        log.error("framebuffer status: ", status);
      }
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, faceStrip.length / 3);
    }
    const sobelShader = this.opts.gradientOrder === 2 ? this.sobelSecondOrderShader : this.sobelFirstOrderShader;
    sobelShader.use(gl);
    gl.activeTexture(TEXTURE8_GRADIENT_TEMP);
    gl.bindTexture(gl.TEXTURE_3D, tempTex3D);
    gl.uniform1i(sobelShader.uniforms.intensityVol, 8);
    const sobelRadius = 0.7;
    gl.uniform1f(sobelShader.uniforms.dX, sobelRadius / hdr.dims[1]);
    gl.uniform1f(sobelShader.uniforms.dY, sobelRadius / hdr.dims[2]);
    gl.uniform1f(sobelShader.uniforms.dZ, sobelRadius / hdr.dims[3]);
    if (this.opts.gradientOrder === 2) {
      gl.uniform1f(sobelShader.uniforms.dX2, 2 * sobelRadius / hdr.dims[1]);
      gl.uniform1f(sobelShader.uniforms.dY2, 2 * sobelRadius / hdr.dims[2]);
      gl.uniform1f(sobelShader.uniforms.dZ2, 2 * sobelRadius / hdr.dims[3]);
    }
    gl.uniform1f(sobelShader.uniforms.coordZ, 0.5);
    gl.bindVertexArray(vao2);
    if (this.gradientTexture !== null) {
      gl.deleteTexture(this.gradientTexture);
    }
    this.gradientTexture = this.rgbaTex(this.gradientTexture, TEXTURE6_GRADIENT, hdr.dims);
    for (let i = 0; i < hdr.dims[3] - 1; i++) {
      const coordZ = 1 / hdr.dims[3] * (i + 0.5);
      gl.uniform1f(sobelShader.uniforms.coordZ, coordZ);
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.gradientTexture, 0, i);
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        log.error("framebuffer status: ", status);
      }
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, faceStrip.length / 3);
    }
    gl.deleteFramebuffer(fb);
    gl.deleteTexture(tempTex3D);
    gl.deleteBuffer(vbo2);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  /**
   * update the webGL 2.0 scene after making changes to the array of volumes. It's always good to call this method after altering one or more volumes manually (outside of Niivue setter methods)
   * @example
   * niivue = new Niivue()
   * niivue.updateGLVolume()
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  updateGLVolume() {
    let visibleLayers = 0;
    const numLayers = this.volumes.length;
    this.refreshColormaps();
    for (let i = 0; i < numLayers; i++) {
      if (!this.volumes[i].toRAS) {
        continue;
      }
      this.refreshLayers(this.volumes[i], visibleLayers);
      visibleLayers++;
    }
    this.furthestVertexFromOrigin = 0;
    if (numLayers > 0) {
      this.furthestVertexFromOrigin = this.volumeObject3D?.furthestVertexFromOrigin ?? 0;
    }
    if (this.meshes) {
      for (let i = 0; i < this.meshes.length; i++) {
        this.furthestVertexFromOrigin = Math.max(this.furthestVertexFromOrigin, this.meshes[i].furthestVertexFromOrigin);
      }
    }
    if (this.onVolumeUpdated) {
      this.onVolumeUpdated();
    }
    this.drawScene();
  }
  /**
   * basic statistics for selected voxel-based image
   * @param options - an object containing the following properties:
   *   - layer: selects image to describe
   *   - masks: optional binary images to filter voxels
   *   - drawingIsMask: a boolean indicating if the drawing is used as a mask
   *   - roiIsMask: a boolean indicating if the ROI is used as a mask
   *   - startVox: the starting voxel coordinates
   *   - endVox: the ending voxel coordinates
   * @returns numeric values to describe image or regions of images
   * @example
   * niivue.getDescriptives({
   *   layer: 0,
   *   masks: [],
   *   drawingIsMask: true, // drawingIsMask and roiIsMask are mutually exclusive
   *   roiIsMask: false,
   *   startVox: [10, 20, 30], // ignored if roiIsMask is false
   *   endVox: [40, 50, 60] // ignored if roiIsMask is false
   * });
   * @see {@link https://niivue.github.io/niivue/features/draw2.html | live demo usage}
   */
  getDescriptives(options) {
    const {
      layer = 0,
      masks = [],
      drawingIsMask = false,
      roiIsMask = false,
      startVox = [0, 0, 0],
      endVox = [0, 0, 0]
    } = options;
    let area = null;
    const hdr = this.volumes[layer].hdr;
    const pixDimsRAS = this.volumes[layer].pixDimsRAS;
    let slope = hdr.scl_slope;
    if (isNaN(slope)) {
      slope = 1;
    }
    let inter = hdr.scl_inter;
    if (isNaN(inter)) {
      inter = 1;
    }
    const imgRaw = this.volumes[layer].img;
    const nv = imgRaw.length;
    const img = new Float32Array(nv);
    for (let i = 0; i < nv; i++) {
      img[i] = imgRaw[i] * slope + inter;
    }
    const mask = new Uint8Array(nv);
    for (let i = 0; i < nv; i++) {
      mask[i] = 1;
    }
    if (masks.length > 0) {
      for (let m = 0; m < masks.length; m++) {
        const imgMask = this.volumes[masks[m]].img;
        if (imgMask.length !== nv) {
          log.debug("Mask resolution does not match image. Skipping masking layer " + masks[m]);
          continue;
        }
        for (let i = 0; i < nv; i++) {
          if (imgMask[i] === 0 || isNaN(imgMask[i])) {
            mask[i] = 0;
          }
        }
      }
    } else if (masks.length < 1 && drawingIsMask) {
      for (let i = 0; i < nv; i++) {
        if (this.drawBitmap[i] === 0 || isNaN(this.drawBitmap[i])) {
          mask[i] = 0;
        }
      }
    } else if (masks.length < 1 && roiIsMask) {
      mask.fill(0);
      console.log("startVox", startVox);
      console.log("endVox", endVox);
      let constantDim = -1;
      if (startVox[0] === endVox[0]) {
        constantDim = 0;
      } else if (startVox[1] === endVox[1]) {
        constantDim = 1;
      } else if (startVox[2] === endVox[2]) {
        constantDim = 2;
      } else {
        console.error("Error: No constant dimension found.");
        return;
      }
      const dims = [0, 1, 2];
      const varDims = dims.filter((dim) => dim !== constantDim);
      const centerVox = [];
      centerVox[constantDim] = startVox[constantDim];
      centerVox[varDims[0]] = (startVox[varDims[0]] + endVox[varDims[0]]) / 2;
      centerVox[varDims[1]] = (startVox[varDims[1]] + endVox[varDims[1]]) / 2;
      const radiusX = Math.abs(endVox[varDims[0]] - startVox[varDims[0]]) / 2;
      const radiusY = Math.abs(endVox[varDims[1]] - startVox[varDims[1]]) / 2;
      const xdim = hdr.dims[1];
      const ydim = hdr.dims[2];
      const minVarDim0 = Math.max(0, Math.floor(centerVox[varDims[0]] - radiusX));
      const maxVarDim0 = Math.min(hdr.dims[varDims[0] + 1] - 1, Math.ceil(centerVox[varDims[0]] + radiusX));
      const minVarDim1 = Math.max(0, Math.floor(centerVox[varDims[1]] - radiusY));
      const maxVarDim1 = Math.min(hdr.dims[varDims[1] + 1] - 1, Math.ceil(centerVox[varDims[1]] + radiusY));
      const constDimVal = centerVox[constantDim];
      if (constDimVal < 0 || constDimVal >= hdr.dims[constantDim + 1]) {
        console.error("Error: Constant dimension value is out of bounds.");
        return;
      }
      for (let i = minVarDim0; i <= maxVarDim0; i++) {
        for (let j = minVarDim1; j <= maxVarDim1; j++) {
          const voxel = [];
          voxel[constantDim] = constDimVal;
          voxel[varDims[0]] = i;
          voxel[varDims[1]] = j;
          const di = (voxel[varDims[0]] - centerVox[varDims[0]]) / radiusX;
          const dj = (voxel[varDims[1]] - centerVox[varDims[1]]) / radiusY;
          const distSq = di * di + dj * dj;
          if (distSq <= 1) {
            const x = voxel[0];
            const y = voxel[1];
            const z = voxel[2];
            const index = z * xdim * ydim + y * xdim + x;
            mask[index] = 1;
          }
        }
      }
      const voxelArea = pixDimsRAS[varDims[0] + 1] * pixDimsRAS[varDims[1] + 1];
      const numMaskedVoxels = mask.reduce((count, value) => count + (value === 1 ? 1 : 0), 0);
      area = numMaskedVoxels * voxelArea;
      const radiusX_mm = radiusX * pixDimsRAS[varDims[0] + 1];
      const radiusY_mm = radiusY * pixDimsRAS[varDims[1] + 1];
      const areaEllipse = Math.PI * radiusX_mm * radiusY_mm;
      area = areaEllipse;
    }
    let k = 0;
    let M = 0;
    let S = 0;
    let mx = Number.NEGATIVE_INFINITY;
    let mn = Number.POSITIVE_INFINITY;
    let kNot0 = 0;
    let MNot0 = 0;
    let SNot0 = 0;
    for (let i = 0; i < nv; i++) {
      if (mask[i] < 1) {
        continue;
      }
      const x = img[i];
      k++;
      let Mnext = M + (x - M) / k;
      S = S + (x - M) * (x - Mnext);
      M = Mnext;
      if (x === 0) {
        continue;
      }
      kNot0++;
      Mnext = MNot0 + (x - MNot0) / kNot0;
      SNot0 = SNot0 + (x - MNot0) * (x - Mnext);
      MNot0 = Mnext;
      mn = Math.min(x, mx);
      mx = Math.max(x, mx);
    }
    const stdev = Math.sqrt(S / (k - 1));
    const stdevNot0 = Math.sqrt(SNot0 / (kNot0 - 1));
    const mnNot0 = mn;
    const mxNot0 = mx;
    if (k !== kNot0) {
      mn = Math.min(0, mx);
      mx = Math.max(0, mx);
    }
    return {
      mean: M,
      stdev,
      nvox: k,
      volumeMM3: k * hdr.pixDims[1] * hdr.pixDims[2] * hdr.pixDims[3],
      // volume also in milliliters
      volumeML: k * hdr.pixDims[1] * hdr.pixDims[2] * hdr.pixDims[3] * 1e-3,
      min: mn,
      max: mx,
      meanNot0: MNot0,
      stdevNot0,
      nvoxNot0: kNot0,
      minNot0: mnNot0,
      maxNot0: mxNot0,
      cal_min: this.volumes[layer].cal_min,
      cal_max: this.volumes[layer].cal_max,
      robust_min: this.volumes[layer].robust_min,
      robust_max: this.volumes[layer].robust_max,
      area
    };
  }
  // not included in public docs
  // apply slow computations when image properties have changed
  refreshLayers(overlayItem, layer) {
    if (this.volumes.length < 1) {
      return;
    }
    this.refreshColormaps();
    const hdr = overlayItem.hdr;
    let img = overlayItem.img;
    if (overlayItem.frame4D > 0 && overlayItem.frame4D < overlayItem.nFrame4D) {
      img = overlayItem.img.slice(
        overlayItem.frame4D * overlayItem.nVox3D,
        (overlayItem.frame4D + 1) * overlayItem.nVox3D
      );
    }
    const opacity = overlayItem.opacity;
    if (layer > 1 && opacity === 0) {
      return;
    }
    let outTexture = null;
    if (!this.back) {
      throw new Error("back undefined");
    }
    this.gl.bindVertexArray(this.unusedVAO);
    if (this.crosshairs3D) {
      this.crosshairs3D.mm[0] = NaN;
    }
    let mtx = mat4_exports.clone(overlayItem.toRAS);
    if (layer === 0) {
      this.volumeObject3D = overlayItem.toNiivueObject3D(this.VOLUME_ID, this.gl);
      mat4_exports.invert(mtx, mtx);
      this.back.matRAS = overlayItem.matRAS;
      this.back.dims = overlayItem.dimsRAS;
      this.back.pixDims = overlayItem.pixDimsRAS;
      outTexture = this.rgbaTex(this.volumeTexture, TEXTURE0_BACK_VOL, overlayItem.dimsRAS);
      const { volScale: volScale2, vox: vox2 } = this.sliceScale(true);
      this.volScale = volScale2;
      this.vox = vox2;
      this.volumeObject3D.scale = volScale2;
      if (!this.renderShader) {
        throw new Error("renderShader undefined");
      }
      this.renderShader.use(this.gl);
      this.gl.uniform3fv(this.renderShader.uniforms.texVox, vox2);
      this.gl.uniform3fv(this.renderShader.uniforms.volScale, volScale2);
      const pickingShader = this.pickingImageShader;
      pickingShader.use(this.gl);
      this.gl.uniform1i(pickingShader.uniforms.volume, 0);
      this.gl.uniform1i(pickingShader.uniforms.colormap, 1);
      this.gl.uniform1i(pickingShader.uniforms.overlay, 2);
      this.gl.uniform3fv(pickingShader.uniforms.volScale, volScale2);
      log.debug(this.volumeObject3D);
    } else {
      if (this.back?.dims === void 0) {
        log.error("Fatal error: Unable to render overlay: background dimensions not defined!");
      }
      const f000 = this.mm2frac(overlayItem.mm000, 0, true);
      let f100 = this.mm2frac(overlayItem.mm100, 0, true);
      let f010 = this.mm2frac(overlayItem.mm010, 0, true);
      let f001 = this.mm2frac(overlayItem.mm001, 0, true);
      f100 = vec3_exports.subtract(f100, f100, f000);
      f010 = vec3_exports.subtract(f010, f010, f000);
      f001 = vec3_exports.subtract(f001, f001, f000);
      mtx = mat4_exports.fromValues(
        f100[0],
        f010[0],
        f001[0],
        f000[0],
        f100[1],
        f010[1],
        f001[1],
        f000[1],
        f100[2],
        f010[2],
        f001[2],
        f000[2],
        0,
        0,
        0,
        1
      );
      mat4_exports.invert(mtx, mtx);
      if (layer === 1) {
        outTexture = this.rgbaTex(this.overlayTexture, TEXTURE2_OVERLAY_VOL, this.back.dims);
        this.overlayTexture = outTexture;
        this.overlayTextureID = outTexture;
      } else {
        outTexture = this.overlayTextureID;
      }
    }
    const fb = this.gl.createFramebuffer();
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
    this.gl.disable(this.gl.CULL_FACE);
    this.gl.viewport(0, 0, this.back.dims[1], this.back.dims[2]);
    this.gl.disable(this.gl.BLEND);
    const tempTex3D = this.gl.createTexture();
    this.gl.activeTexture(TEXTURE9_ORIENT);
    this.gl.bindTexture(this.gl.TEXTURE_3D, tempTex3D);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    let orientShader = this.orientShaderU;
    if (!hdr) {
      throw new Error("hdr undefined");
    }
    if (!img) {
      throw new Error("img undefined");
    }
    if (hdr.datatypeCode === 2 /* DT_UINT8 */) {
      if (hdr.intent_code === 1002 /* NIFTI_INTENT_LABEL */) {
        orientShader = this.orientShaderAtlasU;
      }
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8UI, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RED_INTEGER,
        this.gl.UNSIGNED_BYTE,
        img
      );
    } else if (hdr.datatypeCode === 4 /* DT_INT16 */) {
      orientShader = this.orientShaderI;
      if (hdr.intent_code === 1002 /* NIFTI_INTENT_LABEL */) {
        orientShader = this.orientShaderAtlasI;
      }
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RED_INTEGER,
        this.gl.SHORT,
        img
      );
    } else if (hdr.datatypeCode === 16 /* DT_FLOAT32 */) {
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RED,
        this.gl.FLOAT,
        img
      );
      orientShader = this.orientShaderF;
    } else if (hdr.datatypeCode === 64 /* DT_FLOAT64 */) {
      let img32f = new Float32Array();
      img32f = Float32Array.from(img);
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RED,
        this.gl.FLOAT,
        img32f
      );
      orientShader = this.orientShaderF;
    } else if (hdr.datatypeCode === 128 /* DT_RGB24 */) {
      orientShader = this.orientShaderRGBU;
      orientShader.use(this.gl);
      this.gl.uniform1i(orientShader.uniforms.hasAlpha, 0);
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGB8UI, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RGB_INTEGER,
        this.gl.UNSIGNED_BYTE,
        img
      );
    } else if (hdr.datatypeCode === 512 /* DT_UINT16 */) {
      if (hdr.intent_code === 1002 /* NIFTI_INTENT_LABEL */) {
        orientShader = this.orientShaderAtlasU;
      }
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16UI, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RED_INTEGER,
        this.gl.UNSIGNED_SHORT,
        img
      );
    } else if (hdr.datatypeCode === 2304 /* DT_RGBA32 */) {
      orientShader = this.orientShaderRGBU;
      orientShader.use(this.gl);
      this.gl.uniform1i(orientShader.uniforms.hasAlpha, 1);
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8UI, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        hdr.dims[1],
        hdr.dims[2],
        hdr.dims[3],
        this.gl.RGBA_INTEGER,
        this.gl.UNSIGNED_BYTE,
        img
      );
    }
    if (overlayItem.global_min === void 0) {
      overlayItem.calMinMax();
    }
    let blendTexture = null;
    this.gl.bindVertexArray(this.genericVAO);
    const isUseCopyTexSubImage3D = false;
    if (isUseCopyTexSubImage3D) {
      if (layer > 1) {
        blendTexture = this.rgbaTex(blendTexture, TEXTURE10_BLEND, this.back.dims, true);
        this.gl.bindTexture(this.gl.TEXTURE_3D, blendTexture);
        for (let i = 0; i < this.back.dims[3]; i++) {
          this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.overlayTexture, 0, i);
          this.gl.activeTexture(TEXTURE10_BLEND);
          this.gl.copyTexSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, i, 0, 0, this.back.dims[1], this.back.dims[2]);
        }
      } else {
        blendTexture = this.rgbaTex(blendTexture, TEXTURE10_BLEND, [2, 2, 2, 2], true);
      }
    } else {
      if (layer > 1) {
        if (!this.back.dims) {
          throw new Error("back.dims undefined");
        }
        blendTexture = this.rgbaTex(blendTexture, TEXTURE10_BLEND, this.back.dims);
        this.gl.bindTexture(this.gl.TEXTURE_3D, blendTexture);
        const passShader = this.passThroughShader;
        passShader.use(this.gl);
        this.gl.uniform1i(passShader.uniforms.in3D, 2);
        for (let i = 0; i < this.back.dims[3]; i++) {
          const coordZ = 1 / this.back.dims[3] * (i + 0.5);
          this.gl.uniform1f(passShader.uniforms.coordZ, coordZ);
          this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, blendTexture, 0, i);
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        }
      } else {
        blendTexture = this.rgbaTex(blendTexture, TEXTURE10_BLEND, [2, 2, 2, 2]);
      }
    }
    orientShader.use(this.gl);
    this.gl.activeTexture(TEXTURE1_COLORMAPS);
    let colormapLabelTexture = null;
    if (overlayItem.colormapLabel !== null && overlayItem.colormapLabel.lut.length > 7) {
      const nLabel = overlayItem.colormapLabel.max - overlayItem.colormapLabel.min + 1;
      colormapLabelTexture = this.createColormapTexture(colormapLabelTexture, 1, nLabel);
      this.gl.texSubImage2D(
        this.gl.TEXTURE_2D,
        0,
        0,
        0,
        nLabel,
        1,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        overlayItem.colormapLabel.lut
      );
      this.gl.uniform1f(orientShader.uniforms.cal_min, overlayItem.colormapLabel.min - 0.5);
      this.gl.uniform1f(orientShader.uniforms.cal_max, overlayItem.colormapLabel.max + 0.5);
      this.gl.bindTexture(this.gl.TEXTURE_2D, colormapLabelTexture);
    } else {
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture);
      this.gl.uniform1f(orientShader.uniforms.cal_min, overlayItem.cal_min);
      this.gl.uniform1f(orientShader.uniforms.cal_max, overlayItem.cal_max);
    }
    if ("alphaThreshold" in overlayItem) {
      log.warn("alphaThreshold is deprecated: use colormapType");
      if (overlayItem.alphaThreshold === true) {
        overlayItem.colormapType = 2 /* ZERO_TO_MAX_TRANSLUCENT_BELOW_MIN */;
      }
      if (overlayItem.alphaThreshold === false) {
        overlayItem.colormapType = 1 /* ZERO_TO_MAX_TRANSPARENT_BELOW_MIN */;
      }
      delete overlayItem.alphaThreshold;
    }
    const isColorbarFromZero = overlayItem.colormapType !== 0 /* MIN_TO_MAX */ ? 1 : 0;
    const isAlphaThreshold = overlayItem.colormapType === 2 /* ZERO_TO_MAX_TRANSLUCENT_BELOW_MIN */ ? 1 : 0;
    this.gl.uniform1i(orientShader.uniforms.isAlphaThreshold, isAlphaThreshold);
    this.gl.uniform1i(orientShader.uniforms.isColorbarFromZero, isColorbarFromZero);
    this.gl.uniform1i(orientShader.uniforms.isAdditiveBlend, this.opts.isAdditiveBlend ? 1 : 0);
    let mnNeg = Number.POSITIVE_INFINITY;
    let mxNeg = Number.NEGATIVE_INFINITY;
    if (overlayItem.colormapNegative.length > 0) {
      mnNeg = Math.min(-overlayItem.cal_min, -overlayItem.cal_max);
      mxNeg = Math.max(-overlayItem.cal_min, -overlayItem.cal_max);
      if (isFinite(overlayItem.cal_minNeg) && isFinite(overlayItem.cal_maxNeg)) {
        mnNeg = Math.min(overlayItem.cal_minNeg, overlayItem.cal_maxNeg);
        mxNeg = Math.max(overlayItem.cal_minNeg, overlayItem.cal_maxNeg);
      }
    }
    if (layer > 0 && this.overlayOutlineWidth > 0) {
      const A = overlayItem.cal_min;
      const B = overlayItem.cal_max;
      let isZeroCrossing = Math.min(A, B) <= 0 && Math.max(A, B) >= 0;
      if (!isZeroCrossing && mnNeg < mxNeg) {
        isZeroCrossing = mnNeg <= 0 && mxNeg >= 0;
      }
      if (isZeroCrossing) {
        log.error("issue1139: do not use overlayOutlineWidth when thresholds cross or touch zero");
      }
    }
    if (!orientShader) {
      throw new Error("orientShader undefined");
    }
    this.gl.uniform1f(orientShader.uniforms.layer ?? null, layer);
    this.gl.uniform1f(orientShader.uniforms.cal_minNeg ?? null, mnNeg);
    this.gl.uniform1f(orientShader.uniforms.cal_maxNeg ?? null, mxNeg);
    this.gl.bindTexture(this.gl.TEXTURE_3D, tempTex3D);
    this.gl.uniform1i(orientShader.uniforms.intensityVol ?? null, 9);
    this.gl.uniform1i(orientShader.uniforms.blend3D ?? null, 10);
    this.gl.uniform1i(orientShader.uniforms.colormap ?? null, 1);
    this.gl.uniform1f(orientShader.uniforms.scl_inter ?? null, hdr.scl_inter);
    this.gl.uniform1f(orientShader.uniforms.scl_slope ?? null, hdr.scl_slope);
    this.gl.uniform1f(orientShader.uniforms.opacity ?? null, opacity);
    this.gl.uniform1i(orientShader.uniforms.modulationVol ?? null, 7);
    let modulateTexture = null;
    if (overlayItem.modulationImage !== null && overlayItem.modulationImage >= 0 && overlayItem.modulationImage < this.volumes.length) {
      log.debug("modulating", this.volumes);
      const mhdr = this.volumes[overlayItem.modulationImage].hdr;
      if (mhdr.dims[1] === hdr.dims[1] && mhdr.dims[2] === hdr.dims[2] && mhdr.dims[3] === hdr.dims[3]) {
        if (overlayItem.modulateAlpha) {
          this.gl.uniform1i(orientShader.uniforms.modulation, 2);
          this.gl.uniform1f(orientShader.uniforms.opacity, 1);
        } else {
          this.gl.uniform1i(orientShader.uniforms.modulation, 1);
        }
        modulateTexture = this.r8Tex(modulateTexture, this.gl.TEXTURE7, hdr.dims, true);
        this.gl.activeTexture(this.gl.TEXTURE7);
        this.gl.bindTexture(this.gl.TEXTURE_3D, modulateTexture);
        const vx = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
        const modulateVolume = new Uint8Array(vx);
        const mn = this.volumes[overlayItem.modulationImage].cal_min;
        const scale6 = 1 / (this.volumes[overlayItem.modulationImage].cal_max - mn);
        const imgRaw = this.volumes[overlayItem.modulationImage].img.buffer;
        let img2 = new Uint8Array(
          imgRaw
        );
        switch (mhdr.datatypeCode) {
          case 4 /* DT_INT16 */:
            img2 = new Int16Array(imgRaw);
            break;
          case 16 /* DT_FLOAT32 */:
            img2 = new Float32Array(imgRaw);
            break;
          case 64 /* DT_FLOAT64 */:
            img2 = new Float64Array(imgRaw);
            break;
          case 128 /* DT_RGB24 */:
            img2 = new Uint8Array(imgRaw);
            break;
          case 512 /* DT_UINT16 */:
            img2 = new Uint16Array(imgRaw);
            break;
        }
        log.debug(this.volumes[overlayItem.modulationImage]);
        const isColormapNegative = this.volumes[overlayItem.modulationImage].colormapNegative.length > 0;
        let mnNeg2 = this.volumes[overlayItem.modulationImage].cal_min;
        let mxNeg2 = this.volumes[overlayItem.modulationImage].cal_max;
        if (isFinite(this.volumes[overlayItem.modulationImage].cal_minNeg) && isFinite(this.volumes[overlayItem.modulationImage].cal_maxNeg)) {
          mnNeg2 = this.volumes[overlayItem.modulationImage].cal_minNeg;
          mxNeg2 = this.volumes[overlayItem.modulationImage].cal_minNeg;
        }
        mnNeg2 = Math.abs(mnNeg2);
        mxNeg2 = Math.abs(mxNeg2);
        if (mnNeg2 > mxNeg2) {
          ;
          [mnNeg2, mxNeg2] = [mxNeg2, mnNeg2];
        }
        const scaleNeg = 1 / (mxNeg2 - mnNeg2);
        let mpow = Math.abs(overlayItem.modulateAlpha);
        mpow = Math.max(mpow, 1);
        const volOffset = this.volumes[overlayItem.modulationImage].frame4D * vx;
        for (let i = 0; i < vx; i++) {
          const vRaw = img2[i + volOffset] * mhdr.scl_slope + mhdr.scl_inter;
          let v = (vRaw - mn) * scale6;
          if (isColormapNegative && vRaw < 0) {
            v = (Math.abs(vRaw) - mnNeg2) * scaleNeg;
          }
          v = Math.min(Math.max(v, 0), 1);
          v = Math.pow(v, mpow) * 255;
          modulateVolume[i] = v;
        }
        this.gl.texSubImage3D(
          this.gl.TEXTURE_3D,
          0,
          0,
          0,
          0,
          hdr.dims[1],
          hdr.dims[2],
          hdr.dims[3],
          this.gl.RED,
          this.gl.UNSIGNED_BYTE,
          modulateVolume
        );
      } else {
        log.debug("Modulation image dimensions do not match target");
      }
    } else {
      this.gl.uniform1i(orientShader.uniforms.modulation, 0);
    }
    this.gl.uniformMatrix4fv(orientShader.uniforms.mtx, false, mtx);
    if (!this.back.dims) {
      throw new Error("back.dims undefined");
    }
    let outline = 0;
    if (hdr.intent_code === 1002 /* NIFTI_INTENT_LABEL */) {
      outline = this.opts.atlasOutline;
    }
    this.gl.uniform4fv(orientShader.uniforms.xyzaFrac, [
      1 / this.back.dims[1],
      1 / this.back.dims[2],
      1 / this.back.dims[3],
      outline
    ]);
    log.debug("back dims: ", this.back.dims);
    for (let i = 0; i < this.back.dims[3]; i++) {
      const coordZ = 1 / this.back.dims[3] * (i + 0.5);
      this.gl.uniform1f(orientShader.uniforms.coordZ, coordZ);
      this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, outTexture, 0, i);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    this.gl.bindVertexArray(this.unusedVAO);
    this.gl.deleteTexture(tempTex3D);
    this.gl.deleteTexture(modulateTexture);
    this.gl.deleteTexture(blendTexture);
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.deleteFramebuffer(fb);
    if (layer === 0) {
      this.volumeTexture = outTexture;
      if (this.gradientTextureAmount > 0) {
        this.gradientGL(hdr);
      } else {
        if (this.gradientTexture !== null) {
          this.gl.deleteTexture(this.gradientTexture);
        }
        this.gradientTexture = null;
      }
    }
    if (!this.renderShader) {
      throw new Error("renderShader undefined");
    }
    this.renderShader.use(this.gl);
    const slicescl = this.sliceScale(true);
    const vox = slicescl.vox;
    const volScale = slicescl.volScale;
    this.gl.uniform1f(this.renderShader.uniforms.overlays, this.overlays);
    this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor);
    this.gl.uniform1f(this.renderShader.uniforms.clipThick, this.opts.clipThick);
    this.gl.uniform3fv(this.renderShader.uniforms.clipLo, this.opts.clipVolumeLow);
    this.gl.uniform3fv(this.renderShader.uniforms.clipHi, this.opts.clipVolumeHigh);
    this.gl.uniform1f(this.renderShader.uniforms.backOpacity, this.volumes[0].opacity);
    this.gl.uniform1f(this.renderShader.uniforms.renderOverlayBlend, this.opts.renderOverlayBlend);
    this.gl.uniform4fv(this.renderShader.uniforms.clipPlane, this.scene.clipPlane);
    this.gl.uniform3fv(this.renderShader.uniforms.texVox, vox);
    this.gl.uniform3fv(this.renderShader.uniforms.volScale, volScale);
    if (!this.pickingImageShader) {
      throw new Error("pickingImageShader undefined");
    }
    this.pickingImageShader.use(this.gl);
    this.gl.uniform1f(this.pickingImageShader.uniforms.overlays, this.overlays.length);
    this.gl.uniform3fv(this.pickingImageShader.uniforms.texVox, vox);
    this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo, this.opts.clipVolumeLow);
    this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi, this.opts.clipVolumeHigh);
    let shader = this.sliceMMShader;
    if (this.opts.isV1SliceShader) {
      shader = this.sliceV1Shader;
    }
    if (!shader) {
      throw new Error("slice shader undefined");
    }
    shader.use(this.gl);
    this.gl.uniform1f(shader.uniforms.overlays, this.overlays.length);
    this.gl.uniform1f(shader.uniforms.drawOpacity, this.drawOpacity);
    if (colormapLabelTexture !== null) {
      this.gl.deleteTexture(colormapLabelTexture);
      this.gl.activeTexture(TEXTURE1_COLORMAPS);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture);
    }
    this.gl.uniform1i(shader.uniforms.drawing, 7);
    this.gl.activeTexture(TEXTURE7_DRAW);
    this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture);
    this.updateInterpolation(layer);
  }
  /**
   * query all available color maps that can be applied to volumes
   * @param sort - whether or not to sort the returned array
   * @returns an array of colormap strings
   * @example
   * niivue = new Niivue()
   * colormaps = niivue.colormaps()
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  colormaps() {
    return cmapper.colormaps();
  }
  /**
   * create a new colormap
   * @param key - name of new colormap
   * @param colormap - properties (Red, Green, Blue, Alpha and Indices)
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  addColormap(key, cmap) {
    cmapper.addColormap(key, cmap);
  }
  /**
   * update the colormap of an image given its ID
   * @param id - the ID of the NVImage
   * @param colormap - the name of the colormap to use
   * @example
   * niivue.setColormap(niivue.volumes[0].id,, 'red')
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  setColormap(id, colormap) {
    const idx = this.getVolumeIndexByID(id);
    this.volumes[idx].colormap = colormap;
    this.updateGLVolume();
  }
  // port of https://github.com/rordenlab/niimath/blob/master/src/bwlabel.c
  // return voxel address given row A, column B, and slice C
  idx(A, B, C, DIM) {
    return C * DIM[0] * DIM[1] + B * DIM[0] + A;
  }
  // idx()
  // determine if voxels below candidate voxel have already been assigned a label
  check_previous_slice(bw, il, r, c, sl, dim, conn, tt) {
    const nabo = new Uint32Array(27);
    let nr_set = 0;
    if (!sl) {
      return 0;
    }
    const val = bw[this.idx(r, c, sl, dim)];
    if (conn >= 6) {
      const idx = this.idx(r, c, sl - 1, dim);
      if (val === bw[idx]) {
        nabo[nr_set++] = il[idx];
      }
    }
    if (conn >= 18) {
      if (r) {
        const idx = this.idx(r - 1, c, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (c) {
        const idx = this.idx(r, c - 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (r < dim[0] - 1) {
        const idx = this.idx(r + 1, c, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (c < dim[1] - 1) {
        const idx = this.idx(r, c + 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
    }
    if (conn === 26) {
      if (r && c) {
        const idx = this.idx(r - 1, c - 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (r < dim[0] - 1 && c) {
        const idx = this.idx(r + 1, c - 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (r && c < dim[1] - 1) {
        const idx = this.idx(r - 1, c + 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
      if (r < dim[0] - 1 && c < dim[1] - 1) {
        const idx = this.idx(r + 1, c + 1, sl - 1, dim);
        if (val === bw[idx]) {
          nabo[nr_set++] = il[idx];
        }
      }
    }
    if (nr_set) {
      this.fill_tratab(tt, nabo, nr_set);
      return nabo[0];
    } else {
      return 0;
    }
  }
  // check_previous_slice()
  // provisionally label all voxels in volume
  do_initial_labelling(bw, dim, conn) {
    let label = 1;
    const kGrowArrayBy = 8192;
    let ttn = kGrowArrayBy;
    let tt = new Uint32Array(ttn).fill(0);
    const il = new Uint32Array(dim[0] * dim[1] * dim[2]).fill(0);
    const nabo = new Uint32Array(27);
    for (let sl = 0; sl < dim[2]; sl++) {
      for (let c = 0; c < dim[1]; c++) {
        for (let r = 0; r < dim[0]; r++) {
          let nr_set = 0;
          const val = bw[this.idx(r, c, sl, dim)];
          if (val === 0) {
            continue;
          }
          nabo[0] = this.check_previous_slice(bw, il, r, c, sl, dim, conn, tt);
          if (nabo[0]) {
            nr_set += 1;
          }
          if (conn >= 6) {
            if (r) {
              const idx = this.idx(r - 1, c, sl, dim);
              if (val === bw[idx]) {
                nabo[nr_set++] = il[idx];
              }
            }
            if (c) {
              const idx = this.idx(r, c - 1, sl, dim);
              if (val === bw[idx]) {
                nabo[nr_set++] = il[idx];
              }
            }
          }
          if (conn >= 18) {
            if (c && r) {
              const idx = this.idx(r - 1, c - 1, sl, dim);
              if (val === bw[idx]) {
                nabo[nr_set++] = il[idx];
              }
            }
            if (c && r < dim[0] - 1) {
              const idx = this.idx(r + 1, c - 1, sl, dim);
              if (val === bw[idx]) {
                nabo[nr_set++] = il[idx];
              }
            }
          }
          if (nr_set) {
            il[this.idx(r, c, sl, dim)] = nabo[0];
            this.fill_tratab(tt, nabo, nr_set);
          } else {
            il[this.idx(r, c, sl, dim)] = label;
            if (label >= ttn) {
              ttn += kGrowArrayBy;
              const ext = new Uint32Array(ttn);
              ext.set(tt);
              tt = ext;
            }
            tt[label - 1] = label;
            label++;
          }
        }
      }
    }
    for (let i = 0; i < label - 1; i++) {
      let j = i;
      while (tt[j] !== j + 1) {
        j = tt[j] - 1;
      }
      tt[i] = j + 1;
    }
    return [label - 1, tt, il];
  }
  // do_initial_labelling()
  // translation table unifies a region that has been assigned multiple classes
  fill_tratab(tt, nabo, nr_set) {
    let cntr = 0;
    const tn = new Uint32Array(nr_set + 5).fill(0);
    const INT_MAX = 2147483647;
    let ltn = INT_MAX;
    for (let i = 0; i < nr_set; i++) {
      let j = nabo[i];
      cntr = 0;
      while (tt[j - 1] !== j) {
        j = tt[j - 1];
        cntr++;
        if (cntr > 100) {
          log.info("\nOoh no!!");
          break;
        }
      }
      tn[i] = j;
      ltn = Math.min(ltn, j);
    }
    for (let i = 0; i < nr_set; i++) {
      tt[tn[i] - 1] = ltn;
    }
  }
  // fill_tratab()
  // remove any residual gaps so label numbers are dense rather than sparse
  translate_labels(il, dim, tt, ttn) {
    const nvox = dim[0] * dim[1] * dim[2];
    let ml = 0;
    const l = new Uint32Array(nvox).fill(0);
    for (let i = 0; i < ttn; i++) {
      ml = Math.max(ml, tt[i]);
    }
    const fl2 = new Uint32Array(ml).fill(0);
    let cl = 0;
    for (let i = 0; i < nvox; i++) {
      if (il[i]) {
        if (!fl2[tt[il[i] - 1] - 1]) {
          cl += 1;
          fl2[tt[il[i] - 1] - 1] = cl;
        }
        l[i] = fl2[tt[il[i] - 1] - 1];
      }
    }
    return [cl, l];
  }
  // translate_labels()
  // retain only the largest cluster for each region
  largest_original_cluster_labels(bw, cl, ls) {
    const nvox = bw.length;
    const ls2bw = new Uint32Array(cl + 1).fill(0);
    const sumls = new Uint32Array(cl + 1).fill(0);
    for (let i = 0; i < nvox; i++) {
      const bwVal = bw[i];
      const lsVal = ls[i];
      ls2bw[lsVal] = bwVal;
      sumls[lsVal]++;
    }
    let mxbw = 0;
    for (let i = 0; i < cl + 1; i++) {
      const bwVal = ls2bw[i];
      mxbw = Math.max(mxbw, bwVal);
      for (let j = 0; j < cl + 1; j++) {
        if (j === i) {
          continue;
        }
        if (bwVal !== ls2bw[j]) {
          continue;
        }
        if (sumls[i] < sumls[j]) {
          ls2bw[i] = 0;
        } else if (sumls[i] === sumls[j] && i < j) {
          ls2bw[i] = 0;
        }
      }
    }
    const vxs = new Uint32Array(nvox).fill(0);
    for (let i = 0; i < nvox; i++) {
      vxs[i] = ls2bw[ls[i]];
    }
    return [mxbw, vxs];
  }
  // given a 3D image, return a clustered label map
  // for an explanation and optimized C code see
  // https://github.com/seung-lab/connected-components-3d
  bwlabel(img, dim, conn = 26, binarize = false, onlyLargestClusterPerClass = false) {
    const start = Date.now();
    const nvox = dim[0] * dim[1] * dim[2];
    const bw = new Uint32Array(nvox).fill(0);
    if (![6, 18, 26].includes(conn)) {
      log.info("bwlabel: conn must be 6, 18 or 26.");
      return [0, bw];
    }
    if (dim[0] < 2 || dim[1] < 2 || dim[2] < 1) {
      log.info("bwlabel: img must be 2 or 3-dimensional");
      return [0, bw];
    }
    if (binarize) {
      for (let i = 0; i < nvox; i++) {
        if (img[i] !== 0) {
          bw[i] = 1;
        }
      }
    } else {
      bw.set(img);
    }
    let [ttn, tt, il] = this.do_initial_labelling(bw, dim, conn);
    if (tt === void 0) {
      tt = new Uint32Array();
    }
    const [cl, ls] = this.translate_labels(il, dim, tt, ttn);
    log.info(conn + " neighbor clustering into " + cl + " regions in " + (Date.now() - start) + "ms");
    if (onlyLargestClusterPerClass) {
      const [nbw, bwMx] = this.largest_original_cluster_labels(bw, cl, ls);
      return [nbw, bwMx];
    }
    return [cl, ls];
  }
  // bwlabel()
  async createConnectedLabelImage(id, conn = 26, binarize = false, onlyLargestClusterPerClass = false) {
    const idx = this.getVolumeIndexByID(id);
    const dim = Uint32Array.from(this.volumes[idx].dims?.slice(1, 4) ?? []);
    const img = Uint32Array.from(this.volumes[idx].img?.slice() ?? []);
    const [mx, clusterImg] = this.bwlabel(img, dim, conn, binarize, onlyLargestClusterPerClass);
    const nii = this.volumes[idx].clone();
    nii.opacity = 0.5;
    nii.colormap = "random";
    for (let i = 0; i < nii.img.length; i++) {
      nii.img[i] = clusterImg[i];
    }
    nii.cal_min = 0;
    nii.cal_max = mx;
    return nii;
  }
  // conform.py functions follow
  // https://github.com/Deep-MI/FastSurfer/blob/4e76bed7b11fd7e6403ddac729059ad3842b56de/FastSurferCNN/data_loader/conform.py
  // Licensed under the Apache License, Version 2.0 (the "License")
  // Crop the intensity ranges to specific min and max values.
  async scalecropUint8(img32, dst_min = 0, dst_max = 255, src_min, scale6) {
    const voxnum = img32.length;
    const img8 = new Uint8Array(voxnum);
    for (let i = 0; i < voxnum; i++) {
      let val = img32[i];
      val = dst_min + scale6 * (val - src_min);
      val = Math.max(val, dst_min);
      val = Math.min(val, dst_max);
      img8[i] = val;
    }
    return img8;
  }
  async scalecropFloat32(img32, dst_min = 0, dst_max = 1, src_min, scale6) {
    const voxnum = img32.length;
    const img = new Float32Array(voxnum);
    for (let i = 0; i < voxnum; i++) {
      let val = img32[i];
      val = dst_min + scale6 * (val - src_min);
      val = Math.max(val, dst_min);
      val = Math.min(val, dst_max);
      img[i] = val;
    }
    return img;
  }
  // Get offset and scale of image intensities to robustly rescale to range dst_min..dst_max.
  // Equivalent to how mri_convert conforms images.
  getScale(volume, dst_min = 0, dst_max = 255, f_low = 0, f_high = 0.999) {
    let src_min = volume.global_min;
    let src_max = volume.global_max;
    if (volume.hdr.datatypeCode === 2 /* DT_UINT8 */) {
      return [src_min, 1];
    }
    if (!isFinite(f_low) || !isFinite(f_high)) {
      if (isFinite(volume.cal_min) && isFinite(volume.cal_max) && volume.cal_max > volume.cal_min) {
        src_min = volume.cal_min;
        src_max = volume.cal_max;
        const scale7 = (dst_max - dst_min) / (src_max - src_min);
        log.info(" Robust Rescale:  min: " + src_min + "  max: " + src_max + " scale: " + scale7);
        console.log("Robust Rescale:  min: " + src_min + "  max: " + src_max + " scale: " + scale7);
        return [src_min, scale7];
      }
    }
    const img = volume.img;
    const voxnum = volume.hdr.dims[1] * volume.hdr.dims[2] * volume.hdr.dims[3];
    if (volume.hdr.scl_slope !== 1 || volume.hdr.scl_inter !== 0) {
      const srcimg = volume.img;
      const img2 = new Float32Array(volume.img.length);
      for (let i = 0; i < voxnum; i++) {
        img2[i] = srcimg[i] * volume.hdr.scl_slope + volume.hdr.scl_inter;
      }
    }
    if (src_min < 0) {
      log.warn("WARNING: Input image has value(s) below 0.0 !");
    }
    log.info(" Input:    min: " + src_min + "  max: " + src_max);
    if (f_low === 0 && f_high === 1) {
      return [src_min, 1];
    }
    let nz = 0;
    for (let i = 0; i < voxnum; i++) {
      if (Math.abs(img[i]) >= 1e-15) {
        nz++;
      }
    }
    const histosize = 1e3;
    const bin_size = (src_max - src_min) / histosize;
    const hist = new Array(histosize).fill(0);
    for (let i = 0; i < voxnum; i++) {
      const val = img[i];
      let bin = Math.floor((val - src_min) / bin_size);
      bin = Math.min(bin, histosize - 1);
      hist[bin]++;
    }
    const cs = new Array(histosize).fill(0);
    cs[0] = hist[0];
    for (let i = 1; i < histosize; i++) {
      cs[i] = cs[i - 1] + hist[i];
    }
    let nth = Math.floor(f_low * voxnum);
    let idx = 0;
    while (idx < histosize) {
      if (cs[idx] >= nth) {
        break;
      }
      idx++;
    }
    const global_min = src_min;
    src_min = idx * bin_size + global_min;
    nth = voxnum - Math.floor((1 - f_high) * nz);
    idx = 0;
    while (idx < histosize - 1) {
      if (cs[idx + 1] >= nth) {
        break;
      }
      idx++;
    }
    src_max = idx * bin_size + global_min;
    let scale6 = 1;
    if (src_min !== src_max) {
      scale6 = (dst_max - dst_min) / (src_max - src_min);
    }
    log.info(" Rescale:  min: " + src_min + "  max: " + src_max + " scale: " + scale6);
    return [src_min, scale6];
  }
  // Translation of nibabel mghformat.py (MIT License 2009-2019) and FastSurfer conform.py (Apache License)
  // https://github.com/nipy/nibabel/blob/a2e5dee05cf374c22670ff9fd0d385ce366eb495/nibabel/freesurfer/mghformat.py#L30
  conformVox2Vox(inDims, inAffine, outDim = 256, outMM = 1, toRAS = false) {
    const a = inAffine.flat();
    const affine = mat4_exports.fromValues(
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8],
      a[9],
      a[10],
      a[11],
      a[12],
      a[13],
      a[14],
      a[15]
    );
    const half = vec4_exports.fromValues(inDims[1] / 2, inDims[2] / 2, inDims[3] / 2, 1);
    const Pxyz_c4 = vec4_exports.create();
    const affineT = mat4_exports.create();
    mat4_exports.transpose(affineT, affine);
    vec4_exports.transformMat4(Pxyz_c4, half, affineT);
    const Pxyz_c = vec3_exports.fromValues(Pxyz_c4[0], Pxyz_c4[1], Pxyz_c4[2]);
    const delta = vec3_exports.fromValues(outMM, outMM, outMM);
    let Mdc = mat4_exports.fromValues(-1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
    if (toRAS) {
      Mdc = mat4_exports.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    mat4_exports.transpose(Mdc, Mdc);
    const dims = vec4_exports.fromValues(outDim, outDim, outDim, 1);
    const MdcD = mat4_exports.create();
    mat4_exports.scale(MdcD, Mdc, delta);
    const vol_center = vec4_exports.fromValues(dims[0], dims[1], dims[2], 1);
    vec4_exports.transformMat4(vol_center, vol_center, MdcD);
    vec4_exports.scale(vol_center, vol_center, 0.5);
    const translate3 = vec3_exports.create();
    vec3_exports.subtract(translate3, Pxyz_c, vec3_exports.fromValues(vol_center[0], vol_center[1], vol_center[2]));
    const out_affine = mat4_exports.create();
    mat4_exports.transpose(out_affine, MdcD);
    out_affine[3] = translate3[0];
    out_affine[7] = translate3[1];
    out_affine[11] = translate3[2];
    const inv_out_affine = mat4_exports.create();
    mat4_exports.invert(inv_out_affine, out_affine);
    const vox2vox = mat4_exports.create();
    mat4_exports.mul(vox2vox, affine, inv_out_affine);
    const inv_vox2vox = mat4_exports.create();
    mat4_exports.invert(inv_vox2vox, vox2vox);
    return [out_affine, vox2vox, inv_vox2vox];
  }
  // Create a binary byte array with a NIfTI format header as well as image data
  async createNiftiArray(dims = [256, 256, 256], pixDims = [1, 1, 1], affine = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], datatypeCode = 2 /* DT_UINT8 */, img = new Uint8Array()) {
    return await NVImage.createNiftiArray(dims, pixDims, affine, datatypeCode, img);
  }
  // Convert a binary byte array with a NIfTI image to NiiVue's internal NVImage object
  async niftiArray2NVImage(bytes = new Uint8Array()) {
    return await NVImage.loadFromUrl({ url: bytes });
  }
  // Read a NIfTI file and convert as NiiVue internal NVImage: AddVolume this does not load image to GPU
  async loadFromUrl(fnm) {
    return await NVImage.loadFromUrl({ url: fnm });
  }
  // Translation of FastSurfer conform.py (Apache License)
  // Reslice an image to an isotropic 1mm with dimensions of 1x1x1mm
  // The original volume is translated to be in the center of the new volume
  // Interpolation is linear (default) or nearest neighbor
  // asFloat32 determines if output is Float32 with range 0..255 or Uint8 with range 0..255
  /**
   * FreeSurfer-style conform reslices any image to a 256x256x256 volume with 1mm voxels
   * @param volume - input volume to be re-oriented, intensity-scaled and resliced
   * @param toRAS - reslice to row, column slices to right-anterior-superior not left-inferior-anterior (default false).
   * @param isLinear - reslice with linear rather than nearest-neighbor interpolation (default true).
   * @param asFloat32 - use Float32 datatype rather than Uint8 (default false).
   * @param isRobustMinMax - clamp intensity with robust min max (~2%..98%) instead of FreeSurfer (0%..99.99%) (default false).
   * @see {@link https://niivue.github.io/niivue/features/torso.html | live demo usage}
   */
  async conform(volume, toRAS = false, isLinear = true, asFloat32 = false, isRobustMinMax = false) {
    const outDim = 256;
    const outMM = 1;
    const obj = this.conformVox2Vox(volume.hdr.dims, volume.hdr.affine.flat(), outDim, outMM, toRAS);
    const out_affine = obj[0];
    const inv_vox2vox = obj[2];
    const out_nvox = outDim * outDim * outDim;
    const out_img = new Float32Array(out_nvox);
    const in_img = new Float32Array(volume.img);
    const in_nvox = volume.hdr.dims[1] * volume.hdr.dims[2] * volume.hdr.dims[3];
    if (volume.hdr.scl_slope !== 1 || volume.hdr.scl_inter !== 0) {
      for (let i2 = 0; i2 < in_nvox; i2++) {
        in_img[i2] = in_img[i2] * volume.hdr.scl_slope + volume.hdr.scl_inter;
      }
    }
    const dimX = volume.hdr.dims[1];
    const dimY = volume.hdr.dims[2];
    const dimZ = volume.hdr.dims[3];
    const dimXY = dimX * dimY;
    let i = -1;
    function voxidx(vx, vy, vz) {
      return vx + vy * dimX + vz * dimXY;
    }
    const inv_vox2vox0 = inv_vox2vox[0];
    const inv_vox2vox4 = inv_vox2vox[4];
    const inv_vox2vox8 = inv_vox2vox[8];
    if (isLinear) {
      for (let z = 0; z < outDim; z++) {
        for (let y = 0; y < outDim; y++) {
          const ixYZ = y * inv_vox2vox[1] + z * inv_vox2vox[2] + inv_vox2vox[3];
          const iyYZ = y * inv_vox2vox[5] + z * inv_vox2vox[6] + inv_vox2vox[7];
          const izYZ = y * inv_vox2vox[9] + z * inv_vox2vox[10] + inv_vox2vox[11];
          for (let x = 0; x < outDim; x++) {
            const ix = x * inv_vox2vox0 + ixYZ;
            const iy = x * inv_vox2vox4 + iyYZ;
            const iz = x * inv_vox2vox8 + izYZ;
            const fx = Math.floor(ix);
            const fy = Math.floor(iy);
            const fz = Math.floor(iz);
            i++;
            if (fx < 0 || fy < 0 || fz < 0) {
              continue;
            }
            const cx = Math.ceil(ix);
            const cy = Math.ceil(iy);
            const cz = Math.ceil(iz);
            if (cx >= dimX || cy >= dimY || cz >= dimZ) {
              continue;
            }
            const rcx = ix - fx;
            const rcy = iy - fy;
            const rcz = iz - fz;
            const rfx = 1 - rcx;
            const rfy = 1 - rcy;
            const rfz = 1 - rcz;
            const fff = voxidx(fx, fy, fz);
            let vx = 0;
            vx += in_img[fff] * rfx * rfy * rfz;
            vx += in_img[fff + dimXY] * rfx * rfy * rcz;
            vx += in_img[fff + dimX] * rfx * rcy * rfz;
            vx += in_img[fff + dimX + dimXY] * rfx * rcy * rcz;
            vx += in_img[fff + 1] * rcx * rfy * rfz;
            vx += in_img[fff + 1 + dimXY] * rcx * rfy * rcz;
            vx += in_img[fff + 1 + dimX] * rcx * rcy * rfz;
            vx += in_img[fff + 1 + dimX + dimXY] * rcx * rcy * rcz;
            out_img[i] = vx;
          }
        }
      }
    } else {
      for (let z = 0; z < outDim; z++) {
        for (let y = 0; y < outDim; y++) {
          const ixYZ = y * inv_vox2vox[1] + z * inv_vox2vox[2] + inv_vox2vox[3];
          const iyYZ = y * inv_vox2vox[5] + z * inv_vox2vox[6] + inv_vox2vox[7];
          const izYZ = y * inv_vox2vox[9] + z * inv_vox2vox[10] + inv_vox2vox[11];
          for (let x = 0; x < outDim; x++) {
            const ix = Math.round(x * inv_vox2vox0 + ixYZ);
            const iy = Math.round(x * inv_vox2vox4 + iyYZ);
            const iz = Math.round(x * inv_vox2vox8 + izYZ);
            i++;
            if (ix < 0 || iy < 0 || iz < 0) {
              continue;
            }
            if (ix >= dimX || iy >= dimY || iz >= dimZ) {
              continue;
            }
            out_img[i] = in_img[voxidx(ix, iy, iz)];
          }
        }
      }
    }
    const src_min = 0;
    const scale6 = 0;
    let f_low = 0;
    if (isRobustMinMax) {
      f_low = NaN;
    }
    let bytes = new Uint8Array();
    if (asFloat32) {
      const gs = await this.getScale(volume, 0, 1, f_low);
      const out_img32 = await this.scalecropFloat32(out_img, 0, 1, gs[0], gs[1]);
      bytes = await this.createNiftiArray(
        [outDim, outDim, outDim],
        [outMM, outMM, outMM],
        Array.from(out_affine),
        16 /* DT_FLOAT32 */,
        new Uint8Array(out_img32.buffer)
      );
    } else {
      const gs = await this.getScale(volume, 0, 255, f_low);
      const out_img8 = await this.scalecropUint8(out_img, 0, 255, gs[0], gs[1]);
      bytes = await this.createNiftiArray(
        [outDim, outDim, outDim],
        [outMM, outMM, outMM],
        Array.from(out_affine),
        2,
        out_img8
      );
    }
    const nii = await this.niftiArray2NVImage(bytes);
    return nii;
  }
  /**
   * darken crevices and brighten corners when 3D rendering drawings.
   * @param amount - amount of ambient occlusion (default 0.4)
   * @see {@link https://niivue.github.io/niivue/features/torso.html | live demo usage}
   */
  setRenderDrawAmbientOcclusion(ao) {
    if (!this.renderShader) {
      throw new Error("renderShader undefined");
    }
    this.renderDrawAmbientOcclusion = ao;
    this.renderShader.use(this.gl);
    this.gl.uniform1fv(this.renderShader.uniforms.renderDrawAmbientOcclusion, [this.renderDrawAmbientOcclusion, 1]);
    this.drawScene();
  }
  // compatibility alias for NiiVue < 0.35
  setColorMap(id, colormap) {
    this.setColormap(id, colormap);
  }
  /**
   * use given color map for negative voxels in image
   * @param id - the ID of the NVImage
   * @param colormapNegative - the name of the colormap to use
   * @example
   * niivue = new Niivue()
   * niivue.setColormapNegative(niivue.volumes[1].id,"winter");
   * @see {@link https://niivue.github.io/niivue/features/mosaics2.html | live demo usage}
   */
  setColormapNegative(id, colormapNegative) {
    const idx = this.getVolumeIndexByID(id);
    this.volumes[idx].colormapNegative = colormapNegative;
    this.updateGLVolume();
  }
  /**
   * modulate intensity of one image based on intensity of another
   * @param idTarget - the ID of the NVImage to be biased
   * @param idModulation - the ID of the NVImage that controls bias (empty string to disable modulation)
   * @param modulateAlpha - does the modulation influence alpha transparency (values greater than 1).
   * @example niivue.setModulationImage(niivue.volumes[0].id, niivue.volumes[1].id);
   * @see {@link https://niivue.github.io/niivue/features/modulate.html | live demo scalar usage}
   * @see {@link https://niivue.github.io/niivue/features/modulateAfni.html | live demo usage}
   */
  setModulationImage(idTarget, idModulation, modulateAlpha = 0) {
    const idxTarget = this.getVolumeIndexByID(idTarget);
    let idxModulation = null;
    if (idModulation.length > 0) {
      idxModulation = this.getVolumeIndexByID(idModulation);
    }
    this.volumes[idxTarget].modulationImage = idxModulation;
    this.volumes[idxTarget].modulateAlpha = modulateAlpha;
    this.updateGLVolume();
  }
  /**
   * adjust screen gamma. Low values emphasize shadows but can appear flat, high gamma hides shadow details.
   * @param gamma - selects luminance, default is 1
   * @example niivue.setGamma(1.0);
   * @see {@link https://niivue.github.io/niivue/features/colormaps.html | live demo usage}
   */
  setGamma(gamma = 1) {
    this.scene.gamma = gamma;
    cmapper.gamma = gamma;
    this.updateGLVolume();
  }
  /** Load all volumes for image opened with `limitFrames4D`, the user can also click the `...` on a 4D timeline to load deferred volumes
   * @param id - the ID of the 4D NVImage
   **/
  async loadDeferred4DVolumes(id) {
    const idx = this.getVolumeIndexByID(id);
    const volume = this.volumes[idx];
    if (volume.nTotalFrame4D <= volume.nFrame4D) {
      return;
    }
    volume.nTotalFrame4D = volume.nFrame4D;
    let v;
    if (volume.fileObject) {
      v = await NVImage.loadFromFile({ file: volume.fileObject });
    } else {
      v = await NVImage.loadFromUrl({ url: volume.url });
    }
    if (v) {
      volume.img = v.img.slice();
      volume.nTotalFrame4D = v.nTotalFrame4D;
      volume.nFrame4D = v.nFrame4D;
      this.updateGLVolume();
    }
  }
  /**
   * show desired 3D volume from 4D time series
   * @param id - the ID of the 4D NVImage
   * @param frame4D - frame to display (indexed from zero)
   * @example nv1.setFrame4D(nv1.volumes[0].id, 42);
   * @see {@link https://niivue.github.io/niivue/features/timeseries.html | live demo usage}
   */
  setFrame4D(id, frame4D) {
    const idx = this.getVolumeIndexByID(id);
    const volume = this.volumes[idx];
    if (frame4D > volume.nFrame4D - 1) {
      frame4D = volume.nFrame4D - 1;
    }
    if (frame4D < 0) {
      frame4D = 0;
    }
    if (frame4D === volume.frame4D) {
      return;
    }
    volume.frame4D = frame4D;
    this.updateGLVolume();
    this.onFrameChange(volume, frame4D);
    this.createOnLocationChange();
  }
  /**
   * determine active 3D volume from 4D time series
   * @param id - the ID of the 4D NVImage
   * @returns currently selected volume (indexed from 0)
   * @example nv1.getFrame4D(nv1.volumes[0].id);
   * @see {@link https://niivue.github.io/niivue/features/timeseries.html | live demo usage}
   */
  getFrame4D(id) {
    const idx = this.getVolumeIndexByID(id);
    return this.volumes[idx].frame4D;
  }
  // not included in public docs
  colormapFromKey(name) {
    return cmapper.colormapFromKey(name);
  }
  // not included in public docs
  colormap(lutName = "", isInvert = false) {
    return cmapper.colormap(lutName, isInvert);
  }
  // create TEXTURE1 a 2D bitmap with a nCol columns RGBA and nRow rows
  // note a single volume can have two colormaps (positive and negative)
  // https://github.com/niivue/niivue/blob/main/docs/development-notes/webgl.md
  createColormapTexture(texture = null, nRow = 0, nCol = 256) {
    if (texture !== null) {
      this.gl.deleteTexture(texture);
    }
    if (nRow < 1 || nCol < 1) {
      return null;
    }
    texture = this.gl.createTexture();
    this.gl.activeTexture(TEXTURE1_COLORMAPS);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, nCol, nRow);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    return texture;
  }
  addColormapList(nm = "", mn = NaN, mx = NaN, alpha = false, neg = false, vis = true, inv = false) {
    if (nm.length < 1) {
      vis = false;
    }
    this.colormapLists.push({
      name: nm,
      min: mn,
      max: mx,
      isColorbarFromZero: alpha,
      negative: neg,
      visible: vis,
      invert: inv
    });
  }
  // not included in public docs
  refreshColormaps() {
    this.colormapLists = [];
    if (this.volumes.length < 1 && this.meshes.length < 1) {
      return;
    }
    const nVol = this.volumes.length;
    if (nVol > 0) {
      for (let i = 0; i < nVol; i++) {
        const volume = this.volumes[i];
        const neg = negMinMax(volume.cal_min, volume.cal_max, volume.cal_minNeg, volume.cal_maxNeg);
        const isColorbarFromZero = volume.colormapType !== 0 /* MIN_TO_MAX */;
        this.addColormapList(
          volume.colormapNegative,
          neg[0],
          neg[1],
          isColorbarFromZero,
          true,
          volume.colorbarVisible,
          volume.colormapInvert
        );
        this.addColormapList(
          volume.colormap,
          volume.cal_min,
          volume.cal_max,
          isColorbarFromZero,
          false,
          volume.colorbarVisible,
          volume.colormapInvert
        );
      }
    }
    const nmesh = this.meshes.length;
    if (nmesh > 0) {
      for (let i = 0; i < nmesh; i++) {
        const mesh = this.meshes[i];
        if (!mesh.colorbarVisible) {
          continue;
        }
        const nlayers = mesh.layers.length;
        if ("edgeColormap" in mesh && "edges" in mesh && mesh.edges !== void 0) {
          const neg = negMinMax(mesh.edgeMin, mesh.edgeMax, NaN, NaN);
          this.addColormapList(mesh.edgeColormapNegative, neg[0], neg[1], false, true, true, mesh.colormapInvert);
          this.addColormapList(mesh.edgeColormap, mesh.edgeMin, mesh.edgeMax, false, false, true, mesh.colormapInvert);
        }
        if (nlayers < 1) {
          continue;
        }
        for (let j = 0; j < nlayers; j++) {
          const layer = this.meshes[i].layers[j];
          if (!layer.colorbarVisible) {
            continue;
          }
          if (layer.colormap.length < 1) {
            continue;
          }
          const isColorbarFromZero = layer.colormapType !== 0 /* MIN_TO_MAX */;
          const neg = negMinMax(layer.cal_min, layer.cal_max, layer.cal_minNeg, layer.cal_maxNeg);
          this.addColormapList(
            layer.colormapNegative,
            neg[0],
            neg[1],
            isColorbarFromZero,
            true,
            // neg
            true,
            // vis
            layer.colormapInvert
          );
          this.addColormapList(
            layer.colormap,
            layer.cal_min,
            layer.cal_max,
            isColorbarFromZero,
            false,
            // neg
            true,
            // vis
            layer.colormapInvert
          );
        }
      }
    }
    const nMaps = this.colormapLists.length;
    if (nMaps < 1) {
      return;
    }
    this.colormapTexture = this.createColormapTexture(this.colormapTexture, nMaps + 1);
    let luts = new Uint8ClampedArray();
    function addColormap(lut) {
      const c = new Uint8ClampedArray(luts.length + lut.length);
      c.set(luts);
      c.set(lut, luts.length);
      luts = c;
    }
    for (let i = 0; i < nMaps; i++) {
      addColormap(Array.from(this.colormap(this.colormapLists[i].name, this.colormapLists[i].invert)));
    }
    addColormap(Array.from(this.drawLut.lut));
    this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, 256, nMaps + 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, luts);
    return this;
  }
  // not included in public docs
  sliceScale(forceVox = false) {
    let dimsMM = this.screenFieldOfViewMM(0 /* AXIAL */);
    if (forceVox) {
      dimsMM = this.screenFieldOfViewVox(0 /* AXIAL */);
    }
    const longestAxis = Math.max(dimsMM[0], Math.max(dimsMM[1], dimsMM[2]));
    const volScale = [dimsMM[0] / longestAxis, dimsMM[1] / longestAxis, dimsMM[2] / longestAxis];
    if (!this.back?.dims) {
      throw new Error("back.dims undefined");
    }
    const vox = [this.back.dims[1], this.back.dims[2], this.back.dims[3]];
    return { volScale, vox, longestAxis, dimsMM };
  }
  // return tile at canvas coordinate(x,y)
  tileIndex(x, y) {
    for (let i = 0; i < this.screenSlices.length; i++) {
      const ltwh = this.screenSlices[i].leftTopWidthHeight;
      if (x > ltwh[0] && y > ltwh[1] && x < ltwh[0] + ltwh[2] && y < ltwh[1] + ltwh[3]) {
        return i;
      }
    }
    return -1;
  }
  // not included in public docs
  // report if screen space coordinates correspond with a 3D rendering
  inRenderTile(x, y) {
    const idx = this.tileIndex(x, y);
    if (idx >= 0 && this.screenSlices[idx].axCorSag === 4 /* RENDER */) {
      return idx;
    }
    return -1;
  }
  // not included in public docs
  // if clip plane is active, change depth of clip plane
  // otherwise, set zoom factor for rendering size
  sliceScroll3D(posChange = 0) {
    if (posChange === 0) {
      return;
    }
    if (this.volumes.length > 0 && this.scene.clipPlaneDepthAziElev[0] < 1.8) {
      const depthAziElev = this.scene.clipPlaneDepthAziElev.slice();
      if (posChange > 0) {
        depthAziElev[0] = Math.min(1.5, depthAziElev[0] + 0.025);
      }
      if (posChange < 0) {
        depthAziElev[0] = Math.max(-1.5, depthAziElev[0] - 0.025);
      }
      if (depthAziElev[0] !== this.scene.clipPlaneDepthAziElev[0]) {
        this.scene.clipPlaneDepthAziElev = depthAziElev;
        return this.setClipPlane(this.scene.clipPlaneDepthAziElev);
      }
      return;
    }
    if (posChange > 0) {
      this.scene.volScaleMultiplier = Math.min(2, this.scene.volScaleMultiplier * 1.1);
    }
    if (posChange < 0) {
      this.scene.volScaleMultiplier = Math.max(0.5, this.scene.volScaleMultiplier * 0.9);
    }
    this.drawScene();
  }
  // not included in public docs
  // if a thumbnail is loaded: close thumbnail and release memory
  deleteThumbnail() {
    if (!this.bmpTexture) {
      return;
    }
    this.gl.deleteTexture(this.bmpTexture);
    this.bmpTexture = null;
    this.thumbnailVisible = false;
  }
  // not included in public docs
  inGraphTile(x, y) {
    if (this.graph.opacity <= 0 || this.volumes.length < 1 || this.volumes[0].nFrame4D < 1 || !this.graph.plotLTWH) {
      return false;
    }
    if (this.graph.plotLTWH[2] < 1 || this.graph.plotLTWH[3] < 1) {
      return false;
    }
    const pos = [(x - this.graph.LTWH[0]) / this.graph.LTWH[2], (y - this.graph.LTWH[1]) / this.graph.LTWH[3]];
    return pos[0] > 0 && pos[1] > 0 && pos[0] <= 1 && pos[1] <= 1;
  }
  // update drawBitmap if it differs from clickTosegmentBitmap
  updateBitmapFromClickToSegment() {
    if (this.clickToSegmentGrowingBitmap === null) {
      return;
    }
    if (this.drawBitmap === null) {
      return;
    }
    if (this.clickToSegmentGrowingBitmap.length !== this.drawBitmap.length) {
      return;
    }
    const nvx = this.drawBitmap.length;
    for (let i = 0; i < nvx; i++) {
      this.drawBitmap[i] = this.clickToSegmentGrowingBitmap[i];
    }
  }
  sumBitmap(img) {
    let sum = 0;
    for (let i = 0; i < img.length; i++) {
      sum += img[i];
    }
    return sum;
  }
  // not included in public docs
  // handle mouse click event on canvas
  mouseClick(x, y, posChange = 0, isDelta = true) {
    x *= this.uiData.dpr;
    y *= this.uiData.dpr;
    this.canvas.focus();
    if (this.thumbnailVisible) {
      this.thumbnailVisible = false;
      Promise.all([this.loadVolumes(this.deferredVolumes), this.loadMeshes(this.deferredMeshes)]).catch((e) => {
        throw e;
      });
      return;
    }
    if (this.inGraphTile(x, y)) {
      if (!this.graph.plotLTWH) {
        throw new Error("plotLTWH undefined");
      }
      const pos = [
        (x - this.graph.plotLTWH[0]) / this.graph.plotLTWH[2],
        (y - this.graph.plotLTWH[1]) / this.graph.plotLTWH[3]
      ];
      if (pos[0] > 0 && pos[1] > 0 && pos[0] <= 1 && pos[1] <= 1) {
        const vol = Math.round(pos[0] * (this.volumes[0].nFrame4D - 1));
        this.setFrame4D(this.volumes[0].id, vol);
        return;
      }
      if (pos[0] > 0.5 && pos[1] > 1) {
        this.loadDeferred4DVolumes(this.volumes[0].id).catch((e) => {
          throw e;
        });
      }
      return;
    }
    if (this.inRenderTile(x, y) >= 0) {
      this.sliceScroll3D(posChange);
      this.drawScene();
      return;
    }
    if (this.screenSlices.length < 1 || this.gl.canvas.height < 1 || this.gl.canvas.width < 1) {
      return;
    }
    for (let i = 0; i < this.screenSlices.length; i++) {
      const axCorSag = this.screenSlices[i].axCorSag;
      if (this.drawPenAxCorSag >= 0 && this.drawPenAxCorSag !== axCorSag) {
        continue;
      }
      if (axCorSag > 2 /* SAGITTAL */) {
        continue;
      }
      let texFrac = this.screenXY2TextureFrac(x, y, i, false);
      if (texFrac[0] < 0) {
        continue;
      }
      if (!isDelta) {
        this.scene.crosshairPos[2 - axCorSag] = posChange;
        this.drawScene();
        return;
      }
      if (posChange !== 0) {
        let posNeg = 1;
        if (posChange < 0) {
          posNeg = -1;
        }
        const xyz = [0, 0, 0];
        xyz[2 - axCorSag] = posNeg;
        this.moveCrosshairInVox(xyz[0], xyz[1], xyz[2]);
        this.drawScene();
        this.createOnLocationChange(axCorSag);
        return;
      }
      if (this.opts.isForceMouseClickToVoxelCenters) {
        this.scene.crosshairPos = vec3_exports.clone(this.vox2frac(this.frac2vox(texFrac)));
      } else {
        this.scene.crosshairPos = vec3_exports.clone(texFrac);
      }
      if (this.opts.drawingEnabled) {
        let pt = this.frac2vox(this.scene.crosshairPos);
        if (this.opts.clickToSegment) {
          texFrac = this.screenXY2TextureFrac(this.clickToSegmentXY[0], this.clickToSegmentXY[1], i, false);
          pt = this.frac2vox(texFrac);
          let diff = 0;
          let threshold = this.opts.clickToSegmentPercent + diff;
          if (this.uiData.mousedown) {
            const xDiff = (this.clickToSegmentXY[0] - x) / this.gl.canvas.width;
            const yDiff = (this.clickToSegmentXY[1] - y) / this.gl.canvas.height;
            diff = Math.max(Math.abs(xDiff), Math.abs(yDiff));
            threshold = this.opts.clickToSegmentPercent + diff;
          }
          let voxelIntensity = this.back.getValue(pt[0], pt[1], pt[2]);
          if (this.opts.clickToSegmentAutoIntensity) {
            if (threshold !== 0) {
              if (voxelIntensity === 0) {
                voxelIntensity = 0.01;
              }
              this.opts.clickToSegmentIntensityMax = voxelIntensity * (1 + threshold);
              this.opts.clickToSegmentIntensityMin = voxelIntensity * (1 - threshold);
            }
            if (voxelIntensity > (this.back.cal_min + this.back.cal_max) * 0.5) {
              this.opts.clickToSegmentBright = true;
            } else {
              this.opts.clickToSegmentBright = false;
            }
          }
          const brightOrDark = this.opts.clickToSegmentBright ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          this.drawPenAxCorSag = axCorSag;
          if (this.drawPenAxCorSag === 0 /* AXIAL */) {
            const pixDims = [this.back.pixDimsRAS[0], this.back.pixDimsRAS[1]];
            const minPixDim = Math.min(...pixDims);
            this.opts.penSize = Math.ceil(this.opts.clickToSegmentRadius / minPixDim);
          } else if (this.drawPenAxCorSag === 1 /* CORONAL */) {
            const pixDims = [this.back.pixDimsRAS[0], this.back.pixDimsRAS[2]];
            const minPixDim = Math.min(...pixDims);
            this.opts.penSize = Math.ceil(this.opts.clickToSegmentRadius / minPixDim);
          } else if (this.drawPenAxCorSag === 2 /* SAGITTAL */) {
            const pixDims = [this.back.pixDimsRAS[1], this.back.pixDimsRAS[2]];
            const minPixDim = Math.min(...pixDims);
            this.opts.penSize = Math.ceil(this.opts.clickToSegmentRadius / minPixDim);
          }
          this.drawPt(pt[0], pt[1], pt[2], this.opts.penValue);
          if (diff !== 0) {
            this.clickToSegmentIsGrowing = true;
            this.clickToSegmentGrowingBitmap = this.drawBitmap.slice();
          } else {
            this.clickToSegmentIsGrowing = false;
          }
          this.drawFloodFill(
            [pt[0], pt[1], pt[2]],
            0,
            brightOrDark,
            this.opts.clickToSegmentIntensityMin,
            this.opts.clickToSegmentIntensityMax,
            this.opts.floodFillNeighbors,
            this.opts.clickToSegmentMaxDistanceMM,
            this.opts.clickToSegmentIs2D
          );
          this.drawScene();
          this.createOnLocationChange(axCorSag);
          if (this.clickToSegmentIsGrowing) {
            return;
          }
          const info = this.getDescriptives({
            layer: 0,
            masks: [],
            drawingIsMask: true
          });
          this.onClickToSegment({ mL: info.volumeML, mm3: info.volumeMM3 });
          return;
        }
        if (!isFinite(this.opts.penValue) || this.opts.penValue < 0 || Object.is(this.opts.penValue, -0)) {
          if (!isFinite(this.opts.penValue)) {
            this.drawFloodFill(pt, 0, this.opts.penValue, NaN, NaN, this.opts.floodFillNeighbors);
          } else {
            this.drawFloodFill(
              pt,
              Math.abs(this.opts.penValue),
              this.opts.penValue,
              NaN,
              NaN,
              this.opts.floodFillNeighbors
            );
          }
          return;
        }
        if (isNaN(this.drawPenLocation[0])) {
          this.drawPenAxCorSag = axCorSag;
          this.drawPenFillPts = [];
          this.drawPt(...pt, this.opts.penValue);
        } else {
          if (pt[0] === this.drawPenLocation[0] && pt[1] === this.drawPenLocation[1] && pt[2] === this.drawPenLocation[2]) {
            return;
          }
          this.drawPenLine(pt, this.drawPenLocation, this.opts.penValue);
        }
        this.drawPenLocation = pt;
        if (this.opts.isFilledPen) {
          this.drawPenFillPts.push(pt);
        }
        this.refreshDrawing(false);
      }
      this.drawScene();
      this.createOnLocationChange(axCorSag);
      return;
    }
  }
  // not included in public docs
  // draw 10cm ruler on a 2D tile
  drawRuler() {
    let fovMM = [];
    let ltwh = [];
    for (let i = 0; i < this.screenSlices.length; i++) {
      if (this.screenSlices[i].axCorSag === 4 /* RENDER */) {
        continue;
      }
      if (this.screenSlices[i].fovMM.length > 1) {
        ltwh = this.screenSlices[i].leftTopWidthHeight;
        fovMM = this.screenSlices[i].fovMM;
        break;
      }
    }
    if (ltwh.length < 4) {
      return;
    }
    const frac10cm = 100 / fovMM[0];
    const pix10cm = frac10cm * ltwh[2];
    const pix1cm = Math.max(Math.round(pix10cm * 0.1), 2);
    const pixLeft = Math.floor(ltwh[0] + 0.5 * ltwh[2] - 0.5 * pix10cm);
    const thick = Number(this.opts.rulerWidth);
    const pixTop = Math.floor(ltwh[1] + ltwh[3] - pix1cm) + 0.5 * thick;
    const startXYendXY = [pixLeft, pixTop, pixLeft + pix10cm, pixTop];
    let outlineColor = [0, 0, 0, 1];
    if (this.opts.rulerColor[0] + this.opts.rulerColor[1] + this.opts.rulerColor[2] < 0.8) {
      outlineColor = [1, 1, 1, 1];
    }
    this.drawRuler10cm(startXYendXY, outlineColor, thick + 1);
    this.drawRuler10cm(startXYendXY, this.opts.rulerColor, thick);
  }
  // not included in public docs
  // draw 10cm ruler at desired coordinates
  drawRuler10cm(startXYendXY, rulerColor, rulerWidth = 1) {
    if (!this.lineShader) {
      throw new Error("lineShader undefined");
    }
    this.gl.bindVertexArray(this.genericVAO);
    this.lineShader.use(this.gl);
    this.gl.uniform4fv(this.lineShader.uniforms.lineColor, rulerColor);
    this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.uniform1f(this.lineShader.uniforms.thickness, rulerWidth);
    this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, startXYendXY);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    const w1cm = -0.1 * (startXYendXY[0] - startXYendXY[2]);
    const b = startXYendXY[1] - Math.floor(0.5 * this.opts.rulerWidth);
    const t = Math.floor(b - 0.35 * w1cm);
    const t2 = Math.floor(b - 0.7 * w1cm);
    for (let i = 0; i < 11; i++) {
      let l = startXYendXY[0] + i * w1cm;
      l = Math.max(l, startXYendXY[0] + 0.5 * rulerWidth);
      l = Math.min(l, startXYendXY[2] - 0.5 * rulerWidth);
      const xyxy = [l, b, l, t];
      if (i % 5 === 0) {
        xyxy[3] = t2;
      }
      this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, xyxy);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  // returns vec4: XYZi where XYZ is location in millimeters, and i tile index
  screenXY2mm(x, y, forceSlice = -1) {
    let texFrac;
    for (let s = 0; s < this.screenSlices.length; s++) {
      let i = s;
      if (forceSlice >= 0) {
        i = forceSlice;
      }
      const axCorSag = this.screenSlices[i].axCorSag;
      if (axCorSag > 2 /* SAGITTAL */) {
        continue;
      }
      const ltwh = this.screenSlices[i].leftTopWidthHeight;
      if (x < ltwh[0] || y < ltwh[1] || x > ltwh[0] + ltwh[2] || y > ltwh[1] + ltwh[3]) {
        continue;
      }
      texFrac = this.screenXY2TextureFrac(x, y, i, false);
      if (texFrac[0] < 0) {
        continue;
      }
      const mm = this.frac2mm(texFrac);
      return vec4_exports.fromValues(mm[0], mm[1], mm[2], i);
    }
    return vec4_exports.fromValues(NaN, NaN, NaN, NaN);
  }
  // not included in public docs
  dragForPanZoom(startXYendXY) {
    const endMM = this.screenXY2mm(startXYendXY[2], startXYendXY[3]);
    if (isNaN(endMM[0])) {
      return;
    }
    const startMM = this.screenXY2mm(startXYendXY[0], startXYendXY[1], endMM[3]);
    if (isNaN(startMM[0]) || isNaN(endMM[0]) || isNaN(endMM[3])) {
      return;
    }
    const v = vec4_exports.create();
    const zoom = this.uiData.pan2DxyzmmAtMouseDown[3];
    vec4_exports.sub(v, endMM, startMM);
    this.scene.pan2Dxyzmm[0] = this.uiData.pan2DxyzmmAtMouseDown[0] + zoom * v[0];
    this.scene.pan2Dxyzmm[1] = this.uiData.pan2DxyzmmAtMouseDown[1] + zoom * v[1];
    this.scene.pan2Dxyzmm[2] = this.uiData.pan2DxyzmmAtMouseDown[2] + zoom * v[2];
    this.canvas.focus();
  }
  dragForCenterButton(startXYendXY) {
    this.dragForPanZoom(startXYendXY);
  }
  // for slicer3D vertical dragging adjusts zoom
  dragForSlicer3D(startXYendXY) {
    let zoom = this.uiData.pan2DxyzmmAtMouseDown[3];
    const y = startXYendXY[3] - startXYendXY[1];
    const pixelScale = 0.01;
    zoom += y * pixelScale;
    zoom = Math.max(zoom, 0.1);
    zoom = Math.min(zoom, 10);
    const zoomChange = this.scene.pan2Dxyzmm[3] - zoom;
    if (this.opts.yoke3Dto2DZoom) {
      this.scene.volScaleMultiplier = zoom;
    }
    this.scene.pan2Dxyzmm[3] = zoom;
    const mm = this.frac2mm(this.scene.crosshairPos);
    this.scene.pan2Dxyzmm[0] += zoomChange * mm[0];
    this.scene.pan2Dxyzmm[1] += zoomChange * mm[1];
    this.scene.pan2Dxyzmm[2] += zoomChange * mm[2];
  }
  // not included in public docs
  // draw line between start/end points and text to report length
  drawMeasurementTool(startXYendXY) {
    function extendTo(x0, y0, x1, y1, distance4) {
      const x = x0 - x1;
      const y = y0 - y1;
      if (x === 0 && y === 0) {
        return {
          origin: [x1 + distance4, y1],
          terminus: [x1 + distance4, y1]
        };
      }
      const c = Math.sqrt(x * x + y * y);
      const dX = distance4 * x / c;
      const dY = distance4 * y / c;
      return {
        origin: [x0 + dX, y0 + dY],
        // next to start point
        terminus: [x1 - dX, y1 - dY]
      };
    }
    const gl = this.gl;
    gl.bindVertexArray(this.genericVAO);
    gl.depthFunc(gl.ALWAYS);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    if (!this.lineShader) {
      throw new Error("lineShader undefined");
    }
    this.lineShader.use(this.gl);
    gl.uniform4fv(this.lineShader.uniforms.lineColor, this.opts.rulerColor);
    gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [gl.canvas.width, gl.canvas.height]);
    gl.uniform1f(this.lineShader.uniforms.thickness, this.opts.rulerWidth);
    gl.uniform4fv(this.lineShader.uniforms.startXYendXY, startXYendXY);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    const measureLineColor = this.opts.measureLineColor;
    measureLineColor[3] = 1;
    gl.uniform4fv(this.lineShader.uniforms.lineColor, measureLineColor);
    const w = this.opts.rulerWidth;
    gl.uniform1f(this.lineShader.uniforms.thickness, w * 2);
    let sXYeXY = [startXYendXY[0], startXYendXY[1] - w, startXYendXY[0], startXYendXY[1] + w];
    gl.uniform4fv(this.lineShader.uniforms.startXYendXY, sXYeXY);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    sXYeXY = [startXYendXY[2], startXYendXY[3] - w, startXYendXY[2], startXYendXY[3] + w];
    gl.uniform4fv(this.lineShader.uniforms.startXYendXY, sXYeXY);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    let startXY = this.canvasPos2frac([startXYendXY[0], startXYendXY[1]]);
    let endXY = this.canvasPos2frac([startXYendXY[2], startXYendXY[3]]);
    if (startXY[0] >= 0 && endXY[0] >= 0) {
      const startMm = this.frac2mm(startXY);
      startXY = vec3_exports.fromValues(startMm[0], startMm[1], startMm[2]);
      const endMm = this.frac2mm(endXY);
      endXY = vec3_exports.fromValues(endMm[0], endMm[1], endMm[2]);
      const v = vec3_exports.create();
      vec3_exports.sub(v, startXY, endXY);
      const lenMM = vec3_exports.len(v);
      let decimals = 2;
      if (lenMM > 9) {
        decimals = 1;
      }
      if (lenMM > 99) {
        decimals = 0;
      }
      let stringMM = lenMM.toFixed(decimals);
      if (this.opts.showMeasureUnits) {
        stringMM = `${stringMM} mm`;
      }
      let textCoords = startXYendXY;
      const [x0, y0, x1, y1] = startXYendXY;
      const { origin, terminus } = extendTo(x0, y0, x1, y1, 30);
      switch (this.opts.measureTextJustify) {
        case "start":
          textCoords = [...origin, ...origin.map((point) => point + 1)];
          break;
        case "end":
          textCoords = textCoords = [...terminus, ...terminus.map((point) => point + 1)];
          break;
        default:
          textCoords = startXYendXY;
          break;
      }
      this.drawTextBetween(
        textCoords,
        stringMM,
        this.opts.measureTextHeight / this.opts.textHeight,
        this.opts.measureTextColor
      );
    }
    gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  // draw a rectangle at specified location
  // unless Alpha is > 0, default color is opts.crosshairColor
  drawRect(leftTopWidthHeight, lineColor = [1, 0, 0, -1]) {
    if (lineColor[3] < 0) {
      lineColor = this.opts.crosshairColor;
    }
    if (!this.rectShader) {
      throw new Error("rectShader undefined");
    }
    if (!this.opts.selectionBoxIsOutline) {
      this.rectShader.use(this.gl);
      this.gl.enable(this.gl.BLEND);
      this.gl.uniform4fv(this.rectShader.uniforms.lineColor, lineColor);
      this.gl.uniform2fv(this.rectShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
      this.gl.uniform4f(
        this.rectShader.uniforms.leftTopWidthHeight,
        leftTopWidthHeight[0],
        leftTopWidthHeight[1],
        leftTopWidthHeight[2],
        leftTopWidthHeight[3]
      );
      this.gl.bindVertexArray(this.genericVAO);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      this.gl.bindVertexArray(this.unusedVAO);
    } else {
      this.drawCircle(leftTopWidthHeight, lineColor, 0.1);
      this.rectOutlineShader.use(this.gl);
      this.gl.enable(this.gl.BLEND);
      this.gl.uniform1f(this.rectOutlineShader.uniforms.thickness, this.opts.selectionBoxLineThickness);
      this.gl.uniform4fv(this.rectOutlineShader.uniforms.lineColor, lineColor);
      this.gl.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]);
      this.gl.uniform4f(
        this.rectOutlineShader.uniforms.leftTopWidthHeight,
        leftTopWidthHeight[0],
        leftTopWidthHeight[1],
        leftTopWidthHeight[2],
        leftTopWidthHeight[3]
      );
      this.gl.bindVertexArray(this.genericVAO);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      this.gl.bindVertexArray(this.unusedVAO);
    }
  }
  drawCircle(leftTopWidthHeight, circleColor = this.opts.fontColor, fillPercent = 1) {
    if (!this.circleShader) {
      throw new Error("circleShader undefined");
    }
    this.circleShader.use(this.gl);
    this.gl.enable(this.gl.BLEND);
    this.gl.uniform4fv(this.circleShader.uniforms.circleColor, circleColor);
    this.gl.uniform2fv(this.circleShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.uniform4f(
      this.circleShader.uniforms.leftTopWidthHeight,
      leftTopWidthHeight[0],
      leftTopWidthHeight[1],
      leftTopWidthHeight[2],
      leftTopWidthHeight[3]
    );
    this.gl.uniform1f(this.circleShader.uniforms.fillPercent, fillPercent);
    this.gl.uniform4fv(this.circleShader.uniforms.circleColor, circleColor);
    this.gl.bindVertexArray(this.genericVAO);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  // draw a rectangle at desired location
  drawSelectionBox(leftTopWidthHeight) {
    if (this.opts.dragMode === 6 /* roiSelection */) {
      this.drawCircle(leftTopWidthHeight, this.opts.selectionBoxColor, 0.1);
      return;
    }
    this.drawRect(leftTopWidthHeight, this.opts.selectionBoxColor);
  }
  // not included in public docs
  // return canvas pixels available for tiles (e.g without colorbar)
  effectiveCanvasHeight() {
    return this.gl.canvas.height - this.colorbarHeight;
  }
  effectiveCanvasWidth() {
    return this.gl.canvas.width - this.getLegendPanelWidth();
  }
  getAllLabels() {
    const connectomes = this.meshes.filter((m) => m.type === "connectome" /* CONNECTOME */);
    const meshNodes = connectomes.flatMap((m) => m.nodes);
    const meshLabels = meshNodes.map((n) => n.label);
    const definedMeshLabels = meshLabels.filter((l) => l !== void 0);
    const labels = [...this.document.labels, ...definedMeshLabels];
    return labels;
  }
  getConnectomeLabels() {
    const connectomes = this.meshes.filter((m) => m.type === "connectome" /* CONNECTOME */);
    const meshNodes = connectomes.flatMap((m) => m.nodes);
    const meshLabels = meshNodes.map((n) => n.label);
    const definedMeshLabels = meshLabels.filter((l) => l !== void 0);
    const nonAnchoredLabels = this.document.labels.filter((l) => l.anchor == null || l.anchor === 0 /* NONE */);
    const nonAnchoredLabelSet = new Set(definedMeshLabels);
    for (const label of nonAnchoredLabels) {
      nonAnchoredLabelSet.add(label);
    }
    return Array.from(nonAnchoredLabelSet);
  }
  getBulletMarginWidth() {
    let bulletMargin = 0;
    const labels = this.getConnectomeLabels();
    if (labels.length === 0) {
      return 0;
    }
    const widestBulletScale = labels.length === 1 ? labels[0].style.bulletScale : labels.reduce((a, b) => a.style.bulletScale > b.style.bulletScale ? a : b).style.bulletScale;
    const tallestLabel = labels.length === 1 ? labels[0] : labels.reduce((a, b) => {
      const aSize = this.opts.textHeight * this.gl.canvas.height * a.style.textScale;
      const bSize = this.opts.textHeight * this.gl.canvas.height * b.style.textScale;
      const taller = this.textHeight(aSize, a.text) > this.textHeight(bSize, b.text) ? a : b;
      return taller;
    });
    const size = this.opts.textHeight * this.gl.canvas.height * tallestLabel.style.textScale;
    bulletMargin = this.textHeight(size, tallestLabel.text) * widestBulletScale;
    bulletMargin += size;
    return bulletMargin;
  }
  getLegendPanelWidth() {
    const labels = this.getConnectomeLabels();
    if (!this.opts.showLegend || labels.length === 0) {
      return 0;
    }
    const scale6 = 1;
    const horizontalMargin = this.opts.textHeight * this.gl.canvas.height * scale6;
    let width = 0;
    const longestLabel = labels.reduce((a, b) => {
      const aSize = this.opts.textHeight * this.gl.canvas.height * a.style.textScale;
      const bSize = this.opts.textHeight * this.gl.canvas.height * b.style.textScale;
      const longer = this.textWidth(aSize, a.text) > this.textWidth(bSize, b.text) ? a : b;
      return longer;
    });
    const longestTextSize = this.opts.textHeight * this.gl.canvas.height * longestLabel.style.textScale;
    const longestTextLength = this.textWidth(longestTextSize, longestLabel.text);
    const bulletMargin = this.getBulletMarginWidth();
    if (longestTextLength) {
      width = bulletMargin + longestTextLength;
      width += horizontalMargin * 2;
    }
    if (width >= this.gl.canvas.width) {
      return 0;
    }
    return width;
  }
  getLegendPanelHeight() {
    const labels = this.getConnectomeLabels();
    let height = 0;
    const scale6 = 1;
    const verticalMargin = this.opts.textHeight * this.gl.canvas.height * scale6;
    for (const label of labels) {
      const labelSize = this.opts.textHeight * this.gl.canvas.height * label.style.textScale;
      const textHeight = this.textHeight(labelSize, label.text);
      height += textHeight;
    }
    if (height) {
      height += verticalMargin / 2 * (labels.length + 1);
    }
    return height;
  }
  // not included in public docs
  // determine canvas pixels required for colorbar
  reserveColorbarPanel() {
    let txtHt = Math.max(this.opts.textHeight, 0.01);
    txtHt = txtHt * Math.min(this.gl.canvas.height, this.gl.canvas.width);
    const fullHt = 3 * txtHt;
    const leftTopWidthHeight = [0, this.gl.canvas.height - fullHt, this.gl.canvas.width, fullHt];
    this.colorbarHeight = leftTopWidthHeight[3] + 1;
    return leftTopWidthHeight;
  }
  // not included in public docs
  // low level code to draw a single colorbar
  drawColorbarCore(layer = 0, leftTopWidthHeight = [0, 0, 0, 0], isNegativeColor = false, min4 = 0, max5 = 1, isAlphaThreshold) {
    if (leftTopWidthHeight[2] <= 0 || leftTopWidthHeight[3] <= 0) {
      return;
    }
    let txtHt = Math.max(this.opts.textHeight, 0.01);
    txtHt = txtHt * Math.min(this.gl.canvas.height, this.gl.canvas.width);
    let margin = txtHt;
    const fullHt = 3 * txtHt;
    let barHt = txtHt;
    if (leftTopWidthHeight[3] < fullHt) {
      if (leftTopWidthHeight[3] < 3) {
        return;
      }
      margin = 1;
      barHt = leftTopWidthHeight[3] - 2;
    }
    this.gl.disable(this.gl.DEPTH_TEST);
    this.colorbarHeight = leftTopWidthHeight[3] + 1;
    const barLTWH = [leftTopWidthHeight[0] + margin, leftTopWidthHeight[1], leftTopWidthHeight[2] - 2 * margin, barHt];
    const rimLTWH = [barLTWH[0] - 1, barLTWH[1] - 1, barLTWH[2] + 2, barLTWH[3] + 2];
    this.drawRect(rimLTWH, this.opts.crosshairColor);
    if (!this.colorbarShader) {
      throw new Error("colorbarShader undefined");
    }
    this.colorbarShader.use(this.gl);
    this.gl.activeTexture(TEXTURE1_COLORMAPS);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    const lx = layer;
    this.gl.uniform1f(this.colorbarShader.uniforms.layer, lx);
    this.gl.uniform2fv(this.colorbarShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.disable(this.gl.CULL_FACE);
    if (isNegativeColor) {
      const flip = [barLTWH[0] + barLTWH[2], barLTWH[1], -barLTWH[2], barLTWH[3]];
      this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, flip);
    } else {
      this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, barLTWH);
    }
    this.gl.bindVertexArray(this.genericVAO);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.bindVertexArray(this.unusedVAO);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    let thresholdTic = 0;
    if (isAlphaThreshold && max5 < 0 && isNegativeColor) {
      thresholdTic = max5;
      max5 = 0;
    } else if (isAlphaThreshold && min4 > 0) {
      thresholdTic = min4;
      min4 = 0;
    }
    if (min4 === max5 || txtHt < 1) {
      return;
    }
    const range = Math.abs(max5 - min4);
    let [spacing, ticMin] = tickSpacing(min4, max5);
    if (ticMin < min4) {
      ticMin += spacing;
    }
    function humanize(x) {
      return x.toFixed(6).replace(/\.?0*$/, "");
    }
    let tic = ticMin;
    const ticLTWH = [0, barLTWH[1] + barLTWH[3] - txtHt * 0.5, 2, txtHt * 0.75];
    const txtTop = ticLTWH[1] + ticLTWH[3];
    const isNeg = 1;
    while (tic <= max5) {
      ticLTWH[0] = barLTWH[0] + (tic - min4) / range * barLTWH[2];
      this.drawRect(ticLTWH);
      const str6 = humanize(isNeg * tic);
      this.drawTextBelow([ticLTWH[0], txtTop], str6);
      tic += spacing;
    }
    if (thresholdTic !== 0) {
      const tticLTWH = [
        barLTWH[0] + (thresholdTic - min4) / range * barLTWH[2],
        barLTWH[1] - barLTWH[3] * 0.25,
        2,
        barLTWH[3] * 1.5
      ];
      this.drawRect(tticLTWH);
    }
  }
  // not included in public docs
  // high level code to draw colorbar(s)
  drawColorbar() {
    const maps = this.colormapLists;
    const nmaps = maps.length;
    if (nmaps < 1) {
      return;
    }
    let nVisible = 0;
    for (let i = 0; i < nmaps; i++) {
      if (maps[i].visible) {
        nVisible++;
      }
    }
    if (nVisible < 1) {
      return;
    }
    let leftTopWidthHeight = this.reserveColorbarPanel();
    let txtHt = Math.max(this.opts.textHeight, 0.01);
    txtHt = txtHt * Math.min(this.gl.canvas.height, this.gl.canvas.width);
    const fullHt = 3 * txtHt;
    let wid = leftTopWidthHeight[2] / nVisible;
    if (leftTopWidthHeight[2] <= 0 || leftTopWidthHeight[3] <= 0) {
      wid = this.gl.canvas.width / nVisible;
      leftTopWidthHeight = [0, this.gl.canvas.height - fullHt, wid, fullHt];
    }
    leftTopWidthHeight[2] = wid;
    for (let i = 0; i < nmaps; i++) {
      if (!maps[i].visible) {
        continue;
      }
      this.drawColorbarCore(
        i,
        leftTopWidthHeight,
        maps[i].negative,
        maps[i].min,
        maps[i].max,
        maps[i].isColorbarFromZero
      );
      leftTopWidthHeight[0] += wid;
    }
  }
  // not included in public docs
  textWidth(scale6, str6) {
    if (!str6) {
      return 0;
    }
    let w = 0;
    const bytes = new TextEncoder().encode(str6);
    for (let i = 0; i < str6.length; i++) {
      w += scale6 * this.fontMets.mets[bytes[i]].xadv;
    }
    return w;
  }
  textHeight(scale6, str6) {
    if (!str6) {
      return 0;
    }
    const byteSet = new Set(Array.from(str6));
    const bytes = new TextEncoder().encode(Array.from(byteSet).join(""));
    const tallest = Object.values(this.fontMets.mets).filter((_, index) => bytes.includes(index)).reduce((a, b) => a.lbwh[3] > b.lbwh[3] ? a : b);
    const height = tallest.lbwh[3];
    return scale6 * height;
  }
  // not included in public docs
  drawChar(xy, scale6, char) {
    if (!this.fontShader) {
      throw new Error("fontShader undefined");
    }
    const metrics = this.fontMets.mets[char];
    const l = xy[0] + scale6 * metrics.lbwh[0];
    const b = -(scale6 * metrics.lbwh[1]);
    const w = scale6 * metrics.lbwh[2];
    const h = scale6 * metrics.lbwh[3];
    const t = xy[1] + (b - h) + scale6;
    this.gl.uniform4f(this.fontShader.uniforms.leftTopWidthHeight, l, t, w, h);
    this.gl.uniform4fv(this.fontShader.uniforms.uvLeftTopWidthHeight, metrics.uv_lbwh);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    return scale6 * metrics.xadv;
  }
  // not included in public docs
  drawLoadingText(text) {
    if (!text) {
      return;
    }
    if (!this.canvas) {
      throw new Error("canvas undefined");
    }
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    this.gl.enable(this.gl.CULL_FACE);
    this.gl.enable(this.gl.BLEND);
    this.drawTextBelow([this.canvas.width / 2, this.canvas.height / 2], text, 3);
  }
  // not included in public docs
  drawText(xy, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    if (!this.fontShader) {
      throw new Error("fontShader undefined");
    }
    this.fontShader.use(this.gl);
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * scale6;
    this.gl.enable(this.gl.BLEND);
    this.gl.uniform2f(this.fontShader.uniforms.canvasWidthHeight, this.gl.canvas.width, this.gl.canvas.height);
    if (color === null) {
      color = this.opts.fontColor;
    }
    this.gl.uniform4fv(this.fontShader.uniforms.fontColor, color);
    let screenPxRange = size / this.fontMets.size * this.fontMets.distanceRange;
    screenPxRange = Math.max(screenPxRange, 1);
    this.gl.uniform1f(this.fontShader.uniforms.screenPxRange, screenPxRange);
    const bytes = new TextEncoder().encode(str6);
    this.gl.bindVertexArray(this.genericVAO);
    for (let i = 0; i < str6.length; i++) {
      xy[0] += this.drawChar(xy, size, bytes[i]);
    }
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  drawTextRight(xy, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    xy[1] -= 0.5 * this.opts.textHeight * this.gl.canvas.height;
    this.drawText(xy, str6, scale6, color);
  }
  // not included in public docs
  drawTextLeft(xy, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    const size = this.opts.textHeight * this.gl.canvas.height * scale6;
    xy[0] -= this.textWidth(size, str6);
    xy[1] -= 0.5 * size;
    this.drawText(xy, str6, scale6, color);
  }
  // not included in public docs
  drawTextRightBelow(xy, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    this.drawText(xy, str6, scale6, color);
  }
  // not included in public docs
  drawTextBetween(startXYendXY, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    const xy = [(startXYendXY[0] + startXYendXY[2]) * 0.5, (startXYendXY[1] + startXYendXY[3]) * 0.5];
    const size = this.opts.textHeight * this.gl.canvas.height * scale6;
    const w = this.textWidth(size, str6);
    xy[0] -= 0.5 * w;
    xy[1] -= 0.5 * size;
    const LTWH = [xy[0] - 1, xy[1] - 1, w + 2, size + 2];
    let clr = color;
    if (clr === null) {
      clr = this.opts.crosshairColor;
    }
    if (clr && clr[0] + clr[1] + clr[2] > 0.8) {
      clr = [0, 0, 0, 0.5];
    } else {
      clr = [1, 1, 1, 0.5];
    }
    this.drawRect(LTWH, clr);
    this.drawText(xy, str6, scale6, color);
  }
  // not included in public docs
  drawTextBelow(xy, str6, scale6 = 1, color = null) {
    if (this.opts.textHeight <= 0) {
      return;
    }
    if (!this.canvas) {
      throw new Error("canvas undefined");
    }
    let size = this.opts.textHeight * this.gl.canvas.height * scale6;
    let width = this.textWidth(size, str6);
    if (width > this.canvas.width) {
      scale6 *= (this.canvas.width - 2) / width;
      size = this.opts.textHeight * this.gl.canvas.height * scale6;
      width = this.textWidth(size, str6);
    }
    xy[0] -= 0.5 * this.textWidth(size, str6);
    xy[0] = Math.max(xy[0], 1);
    xy[0] = Math.min(xy[0], this.canvas.width - width - 1);
    this.drawText(xy, str6, scale6, color);
  }
  // not included in public docs
  updateInterpolation(layer, isForceLinear = false) {
    let interp = this.gl.LINEAR;
    if (!isForceLinear && this.opts.isNearestInterpolation) {
      interp = this.gl.NEAREST;
    }
    if (layer === 0) {
      this.gl.activeTexture(TEXTURE0_BACK_VOL);
    } else {
      this.gl.activeTexture(TEXTURE2_OVERLAY_VOL);
    }
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, interp);
    this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, interp);
  }
  // not included in public docs
  setAtlasOutline(isOutline) {
    this.opts.atlasOutline = isOutline;
    this.updateGLVolume();
    this.drawScene();
  }
  /**
   * select between nearest and linear interpolation for voxel based images
   * @param isNearest - whether nearest neighbor interpolation is used, else linear interpolation
   * @example niivue.setInterpolation(true);
   * @see {@link https://niivue.github.io/niivue/features/draw2.html | live demo usage}
   */
  setInterpolation(isNearest) {
    this.opts.isNearestInterpolation = isNearest;
    const numLayers = this.volumes.length;
    if (numLayers < 1) {
      return;
    }
    for (let i = 0; i < numLayers; i++) {
      this.updateInterpolation(i);
    }
    this.drawScene();
  }
  // not included in public docs
  calculateMvpMatrix2D(leftTopWidthHeight, mn, mx, clipTolerance = Infinity, clipDepth = 0, azimuth = 0, elevation = 0, isRadiolgical) {
    const gl = this.gl;
    gl.viewport(
      leftTopWidthHeight[0],
      this.gl.canvas.height - (leftTopWidthHeight[1] + leftTopWidthHeight[3]),
      // lower numbers near bottom
      leftTopWidthHeight[2],
      leftTopWidthHeight[3]
    );
    let left = mn[0];
    let right = mx[0];
    let leftTopMM = [left, mn[1]];
    let fovMM = [right - left, mx[1] - mn[1]];
    if (isRadiolgical) {
      leftTopMM = [mx[0], mn[1]];
      fovMM = [mn[0] - mx[0], mx[1] - mn[1]];
      left = -mx[0];
      right = -mn[0];
    }
    const scale6 = 2 * Math.max(Math.abs(mn[2]), Math.abs(mx[2]));
    const projectionMatrix = mat4_exports.create();
    let near = 0.01;
    let far = scale6 * 8;
    if (clipTolerance !== Infinity) {
      let r = isRadiolgical;
      if (elevation === 0 && (azimuth === 0 || azimuth === 180)) {
        r = !r;
      }
      let dx = scale6 * 1.8 - clipDepth;
      if (!r) {
        dx = scale6 * 1.8 + clipDepth;
      }
      near = dx - clipTolerance;
      far = dx + clipTolerance;
    }
    mat4_exports.ortho(projectionMatrix, left, right, mn[1], mx[1], near, far);
    const modelMatrix = mat4_exports.create();
    modelMatrix[0] = -1;
    const translateVec3 = vec3_exports.fromValues(0, 0, -scale6 * 1.8);
    mat4_exports.translate(modelMatrix, modelMatrix, translateVec3);
    mat4_exports.rotateX(modelMatrix, modelMatrix, deg2rad(270 - elevation));
    mat4_exports.rotateZ(modelMatrix, modelMatrix, deg2rad(azimuth - 180));
    const iModelMatrix = mat4_exports.create();
    mat4_exports.invert(iModelMatrix, modelMatrix);
    const normalMatrix = mat4_exports.create();
    mat4_exports.transpose(normalMatrix, iModelMatrix);
    const modelViewProjectionMatrix = mat4_exports.create();
    mat4_exports.multiply(modelViewProjectionMatrix, projectionMatrix, modelMatrix);
    return {
      modelViewProjectionMatrix,
      modelMatrix,
      normalMatrix,
      leftTopMM,
      fovMM
    };
  }
  // not included in public docs
  swizzleVec3MM(v3, axCorSag) {
    if (axCorSag === 1 /* CORONAL */) {
      v3 = swizzleVec3(v3, [0, 2, 1]);
    } else if (axCorSag === 2 /* SAGITTAL */) {
      v3 = swizzleVec3(v3, [1, 2, 0]);
    }
    return v3;
  }
  // not included in public docs
  screenFieldOfViewVox(axCorSag = 0) {
    const fov = vec3_exports.clone(this.volumeObject3D.fieldOfViewDeObliqueMM);
    return this.swizzleVec3MM(fov, axCorSag);
  }
  // not included in public docs
  // determine height/width of image in millimeters
  screenFieldOfViewMM(axCorSag = 0, forceSliceMM = false) {
    if (!forceSliceMM && !this.opts.isSliceMM) {
      return this.screenFieldOfViewVox(axCorSag);
    }
    const extentsMin = this.volumeObject3D.extentsMin;
    const extentsMax = this.volumeObject3D.extentsMax;
    let mnMM = vec3_exports.fromValues(extentsMin[0], extentsMin[1], extentsMin[2]);
    let mxMM = vec3_exports.fromValues(extentsMax[0], extentsMax[1], extentsMax[2]);
    mnMM = this.swizzleVec3MM(mnMM, axCorSag);
    mxMM = this.swizzleVec3MM(mxMM, axCorSag);
    const fovMM = vec3_exports.create();
    vec3_exports.subtract(fovMM, mxMM, mnMM);
    return fovMM;
  }
  // not included in public docs
  screenFieldOfViewExtendedVox(axCorSag = 0) {
    const extentsMinOrtho = this.volumes[0].extentsMinOrtho;
    const extentsMaxOrtho = this.volumes[0].extentsMaxOrtho;
    let mnMM = vec3_exports.fromValues(extentsMinOrtho[0], extentsMinOrtho[1], extentsMinOrtho[2]);
    let mxMM = vec3_exports.fromValues(extentsMaxOrtho[0], extentsMaxOrtho[1], extentsMaxOrtho[2]);
    const rotation = mat4_exports.create();
    mnMM = this.swizzleVec3MM(mnMM, axCorSag);
    mxMM = this.swizzleVec3MM(mxMM, axCorSag);
    const fovMM = vec3_exports.create();
    vec3_exports.subtract(fovMM, mxMM, mnMM);
    return { mnMM, mxMM, rotation, fovMM };
  }
  // not included in public docs
  screenFieldOfViewExtendedMM(axCorSag = 0) {
    if (!this.volumeObject3D) {
      throw new Error("volumeObject3D undefined");
    }
    const eMin = this.volumeObject3D.extentsMin;
    const eMax = this.volumeObject3D.extentsMax;
    let mnMM = vec3_exports.fromValues(eMin[0], eMin[1], eMin[2]);
    let mxMM = vec3_exports.fromValues(eMax[0], eMax[1], eMax[2]);
    const rotation = mat4_exports.create();
    mnMM = this.swizzleVec3MM(mnMM, axCorSag);
    mxMM = this.swizzleVec3MM(mxMM, axCorSag);
    const fovMM = vec3_exports.create();
    vec3_exports.subtract(fovMM, mxMM, mnMM);
    return { mnMM, mxMM, rotation, fovMM };
  }
  // not included in public docs
  // show text labels for L/R, A/P, I/S dimensions
  drawSliceOrientationText(leftTopWidthHeight, axCorSag, padLeftTop = [NaN, NaN]) {
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    let topText = "S";
    if (axCorSag === 0 /* AXIAL */) {
      topText = "A";
    }
    let leftText = this.opts.isRadiologicalConvention ? "R" : "L";
    if (axCorSag === 2 /* SAGITTAL */) {
      leftText = this.opts.sagittalNoseLeft ? "A" : "P";
    }
    if (this.opts.isCornerOrientationText) {
      this.drawTextRightBelow([leftTopWidthHeight[0], leftTopWidthHeight[1]], leftText + topText);
      return;
    }
    let drawBelow = true;
    let drawRight = true;
    if (!isNaN(padLeftTop[0])) {
      const ht = this.opts.textHeight * this.gl.canvas.height + 2;
      if (padLeftTop[1] > ht) {
        this.drawTextBelow(
          [leftTopWidthHeight[0] + leftTopWidthHeight[2] * 0.5, leftTopWidthHeight[1] + padLeftTop[1] - ht],
          topText
        );
        drawBelow = false;
      }
      const wid = this.textWidth(ht, leftText) + 2;
      if (padLeftTop[0] > wid) {
        this.drawTextRight(
          [leftTopWidthHeight[0] + padLeftTop[0] - wid, leftTopWidthHeight[1] + leftTopWidthHeight[3] * 0.5],
          leftText
        );
        drawRight = false;
      }
    }
    if (drawBelow) {
      this.drawTextBelow([leftTopWidthHeight[0] + leftTopWidthHeight[2] * 0.5, leftTopWidthHeight[1]], topText);
    }
    if (drawRight) {
      this.drawTextRight([leftTopWidthHeight[0], leftTopWidthHeight[1] + leftTopWidthHeight[3] * 0.5], leftText);
    }
  }
  // not included in public docs
  xyMM2xyzMM(axCorSag, sliceFrac) {
    let sliceDim = 2;
    if (axCorSag === 1 /* CORONAL */) {
      sliceDim = 1;
    }
    if (axCorSag === 2 /* SAGITTAL */) {
      sliceDim = 0;
    }
    let a = [0, 0, 0];
    let b = [1, 1, 0];
    let c = [1, 0, 1];
    a[sliceDim] = sliceFrac;
    b[sliceDim] = sliceFrac;
    c[sliceDim] = sliceFrac;
    a = this.frac2mm(a);
    b = this.frac2mm(b);
    c = this.frac2mm(c);
    a = this.swizzleVec3MM(vec3_exports.fromValues(a[0], a[1], a[2]), axCorSag);
    b = this.swizzleVec3MM(vec3_exports.fromValues(b[0], b[1], b[2]), axCorSag);
    c = this.swizzleVec3MM(vec3_exports.fromValues(c[0], c[1], c[2]), axCorSag);
    const denom = (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
    let yMult = (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);
    yMult /= denom;
    let xMult = (b[1] - a[1]) * (c[2] - a[2]) - (c[1] - a[1]) * (b[2] - a[2]);
    xMult /= denom;
    const AxyzMxy = [0, 0, 0, 0, 0];
    AxyzMxy[0] = a[0];
    AxyzMxy[1] = a[1];
    AxyzMxy[2] = a[2];
    AxyzMxy[3] = xMult;
    AxyzMxy[4] = yMult;
    return AxyzMxy;
  }
  // not included in public docs
  // draw 2D tile
  draw2DMain(leftTopWidthHeight, axCorSag, customMM = NaN) {
    let frac2mmTexture = this.volumes[0].frac2mm.slice();
    let screen = this.screenFieldOfViewExtendedMM(axCorSag);
    let mesh2ortho = mat4_exports.create();
    if (!this.opts.isSliceMM) {
      frac2mmTexture = this.volumes[0].frac2mmOrtho.slice();
      mesh2ortho = mat4_exports.clone(this.volumes[0].mm2ortho);
      screen = this.screenFieldOfViewExtendedVox(axCorSag);
    }
    let isRadiolgical = this.opts.isRadiologicalConvention && axCorSag < 2 /* SAGITTAL */;
    if (customMM === Infinity || customMM === -Infinity) {
      isRadiolgical = customMM !== Infinity;
      if (axCorSag === 1 /* CORONAL */) {
        isRadiolgical = !isRadiolgical;
      }
    } else if (this.opts.sagittalNoseLeft && axCorSag === 2 /* SAGITTAL */) {
      isRadiolgical = !isRadiolgical;
    }
    let elevation = 0;
    let azimuth = 0;
    if (axCorSag === 2 /* SAGITTAL */) {
      azimuth = isRadiolgical ? 90 : -90;
    } else if (axCorSag === 1 /* CORONAL */) {
      azimuth = isRadiolgical ? 180 : 0;
    } else {
      azimuth = isRadiolgical ? 180 : 0;
      elevation = isRadiolgical ? -90 : 90;
    }
    const gl = this.gl;
    let isStretchToScreen = false;
    if (leftTopWidthHeight[2] === 0 || leftTopWidthHeight[3] === 0) {
      isStretchToScreen = true;
      const pixPerMMw = gl.canvas.width / screen.fovMM[0];
      const pixPerMMh = gl.canvas.height / screen.fovMM[1];
      const pixPerMMmin = Math.min(pixPerMMw, pixPerMMh);
      const zoomW = pixPerMMw / pixPerMMmin;
      const zoomH = pixPerMMh / pixPerMMmin;
      screen.fovMM[0] *= zoomW;
      screen.fovMM[1] *= zoomH;
      let center = (screen.mnMM[0] + screen.mxMM[0]) * 0.5;
      screen.mnMM[0] = center - screen.fovMM[0] * 0.5;
      screen.mxMM[0] = center + screen.fovMM[0] * 0.5;
      center = (screen.mnMM[1] + screen.mxMM[1]) * 0.5;
      screen.mnMM[1] = center - screen.fovMM[1] * 0.5;
      screen.mxMM[1] = center + screen.fovMM[1] * 0.5;
      leftTopWidthHeight = [0, 0, gl.canvas.width, gl.canvas.height];
    }
    if (isNaN(customMM)) {
      const pan = this.scene.pan2Dxyzmm;
      const panXY = this.swizzleVec3MM(vec3_exports.fromValues(pan[0], pan[1], pan[2]), axCorSag);
      const zoom = this.scene.pan2Dxyzmm[3];
      screen.mnMM[0] -= panXY[0];
      screen.mxMM[0] -= panXY[0];
      screen.mnMM[1] -= panXY[1];
      screen.mxMM[1] -= panXY[1];
      screen.mnMM[0] /= zoom;
      screen.mxMM[0] /= zoom;
      screen.mnMM[1] /= zoom;
      screen.mxMM[1] /= zoom;
    }
    let sliceDim = 2;
    if (axCorSag === 1 /* CORONAL */) {
      sliceDim = 1;
    }
    if (axCorSag === 2 /* SAGITTAL */) {
      sliceDim = 0;
    }
    let sliceFrac = this.scene.crosshairPos[sliceDim];
    let mm = this.frac2mm(this.scene.crosshairPos);
    if (!isNaN(customMM) && customMM !== Infinity && customMM !== -Infinity) {
      mm = this.frac2mm([0.5, 0.5, 0.5]);
      mm[sliceDim] = customMM;
      const frac = this.mm2frac(mm);
      sliceFrac = frac[sliceDim];
    }
    const sliceMM = mm[sliceDim];
    gl.clear(gl.DEPTH_BUFFER_BIT);
    let obj = this.calculateMvpMatrix2D(
      leftTopWidthHeight,
      screen.mnMM,
      screen.mxMM,
      Infinity,
      0,
      azimuth,
      elevation,
      isRadiolgical
    );
    if (customMM === Infinity || customMM === -Infinity) {
      const ltwh = leftTopWidthHeight.slice();
      this.draw3D(
        leftTopWidthHeight,
        obj.modelViewProjectionMatrix,
        obj.modelMatrix,
        obj.normalMatrix,
        azimuth,
        elevation
      );
      const tile = this.screenSlices[this.screenSlices.length - 1];
      tile.leftTopWidthHeight = ltwh;
      tile.axCorSag = axCorSag;
      tile.sliceFrac = Infinity;
      tile.AxyzMxy = this.xyMM2xyzMM(axCorSag, sliceFrac);
      tile.leftTopMM = obj.leftTopMM;
      tile.fovMM = obj.fovMM;
      return;
    }
    gl.enable(gl.DEPTH_TEST);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.BLEND);
    gl.depthFunc(gl.GREATER);
    gl.disable(gl.CULL_FACE);
    let shader = this.sliceMMShader;
    if (this.opts.isV1SliceShader) {
      shader = this.sliceV1Shader;
    }
    if (!shader) {
      throw new Error("slice Shader undefined");
    }
    shader.use(this.gl);
    gl.uniform1f(shader.uniforms.overlayOutlineWidth, this.overlayOutlineWidth);
    gl.uniform1f(shader.uniforms.overlayAlphaShader, this.overlayAlphaShader);
    gl.uniform1i(shader.uniforms.isAlphaClipDark, this.isAlphaClipDark ? 1 : 0);
    gl.uniform1i(shader.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays);
    gl.uniform1f(shader.uniforms.drawOpacity, this.drawOpacity);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.uniform1f(shader.uniforms.opacity, this.volumes[0].opacity);
    gl.uniform1i(shader.uniforms.axCorSag, axCorSag);
    gl.uniform1f(shader.uniforms.slice, sliceFrac);
    gl.uniformMatrix4fv(
      shader.uniforms.frac2mm,
      false,
      frac2mmTexture
      // this.volumes[0].frac2mm
    );
    gl.uniformMatrix4fv(shader.uniforms.mvpMtx, false, obj.modelViewProjectionMatrix.slice());
    gl.bindVertexArray(this.genericVAO);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindVertexArray(this.unusedVAO);
    this.screenSlices.push({
      leftTopWidthHeight,
      axCorSag,
      sliceFrac,
      AxyzMxy: this.xyMM2xyzMM(axCorSag, sliceFrac),
      leftTopMM: obj.leftTopMM,
      screen2frac: [],
      fovMM: obj.fovMM
    });
    if (isNaN(customMM)) {
      this.drawCrosshairs3D(true, 1, obj.modelViewProjectionMatrix, true, this.opts.isSliceMM);
    }
    if (this.opts.meshThicknessOn2D > 0) {
      if (this.opts.meshThicknessOn2D !== Infinity) {
        obj = this.calculateMvpMatrix2D(
          leftTopWidthHeight,
          screen.mnMM,
          screen.mxMM,
          this.opts.meshThicknessOn2D,
          sliceMM,
          azimuth,
          elevation,
          isRadiolgical
        );
      }
      const mx = mat4_exports.clone(obj.modelViewProjectionMatrix);
      mat4_exports.multiply(mx, mx, mesh2ortho);
      this.drawMesh3D(
        true,
        1,
        mx,
        // obj.modelViewProjectionMatrix,
        obj.modelMatrix,
        obj.normalMatrix
      );
    }
    if (isNaN(customMM)) {
      this.drawCrosshairs3D(false, 0.15, obj.modelViewProjectionMatrix, true, this.opts.isSliceMM);
    }
    if (isStretchToScreen) {
      this.drawSliceOrientationText(leftTopWidthHeight, axCorSag);
    }
    this.readyForSync = true;
  }
  draw2D(leftTopWidthHeight, axCorSag, customMM = NaN, imageWidthHeight = [NaN, NaN]) {
    const padLeftTop = [NaN, NaN];
    if (imageWidthHeight[0] === Infinity) {
      const volScale = this.sliceScale().volScale;
      let scale6 = this.scaleSlice(volScale[0], volScale[1], [0, 0], [leftTopWidthHeight[2], leftTopWidthHeight[3]]);
      if (axCorSag === 1 /* CORONAL */) {
        scale6 = this.scaleSlice(volScale[0], volScale[2], [0, 0], [leftTopWidthHeight[2], leftTopWidthHeight[3]]);
      }
      if (axCorSag === 2 /* SAGITTAL */) {
        scale6 = this.scaleSlice(volScale[1], volScale[2], [0, 0], [leftTopWidthHeight[2], leftTopWidthHeight[3]]);
      }
      imageWidthHeight[0] = scale6[2];
      imageWidthHeight[1] = scale6[3];
    }
    if (isNaN(imageWidthHeight[0])) {
      this.draw2DMain(leftTopWidthHeight, axCorSag, customMM);
    } else {
      const ltwh = leftTopWidthHeight.slice();
      padLeftTop[0] = Math.floor(0.5 * (ltwh[2] - imageWidthHeight[0]));
      padLeftTop[1] = Math.floor(0.5 * (ltwh[3] - imageWidthHeight[1]));
      ltwh[0] += padLeftTop[0];
      ltwh[1] += padLeftTop[1];
      ltwh[2] = imageWidthHeight[0];
      ltwh[3] = imageWidthHeight[1];
      this.draw2DMain(ltwh, axCorSag, customMM);
    }
    if (customMM === Infinity || customMM === -Infinity || axCorSag === 4 /* RENDER */) {
      return;
    }
    if (leftTopWidthHeight[2] !== 0 && leftTopWidthHeight[3] !== 0) {
      this.drawSliceOrientationText(leftTopWidthHeight, axCorSag, padLeftTop);
    }
  }
  // not included in public docs
  // determine 3D model view projection matrix
  calculateMvpMatrix(_unused, leftTopWidthHeight = [0, 0, 0, 0], azimuth, elevation) {
    if (leftTopWidthHeight[2] === 0 || leftTopWidthHeight[3] === 0) {
      leftTopWidthHeight = [0, 0, this.gl.canvas.width, this.gl.canvas.height];
    }
    const whratio = leftTopWidthHeight[2] / leftTopWidthHeight[3];
    let scale6 = this.furthestFromPivot;
    const origin = this.pivot3D;
    const projectionMatrix = mat4_exports.create();
    scale6 = 0.8 * scale6 / this.scene.volScaleMultiplier;
    if (whratio < 1) {
      mat4_exports.ortho(projectionMatrix, -scale6, scale6, -scale6 / whratio, scale6 / whratio, scale6 * 0.01, scale6 * 8);
    } else {
      mat4_exports.ortho(projectionMatrix, -scale6 * whratio, scale6 * whratio, -scale6, scale6, scale6 * 0.01, scale6 * 8);
    }
    const modelMatrix = mat4_exports.create();
    modelMatrix[0] = -1;
    const translateVec3 = vec3_exports.fromValues(0, 0, -scale6 * 1.8);
    mat4_exports.translate(modelMatrix, modelMatrix, translateVec3);
    if (this.position) {
      mat4_exports.translate(modelMatrix, modelMatrix, this.position);
    }
    mat4_exports.rotateX(modelMatrix, modelMatrix, deg2rad(270 - elevation));
    mat4_exports.rotateZ(modelMatrix, modelMatrix, deg2rad(azimuth - 180));
    mat4_exports.translate(modelMatrix, modelMatrix, [-origin[0], -origin[1], -origin[2]]);
    const iModelMatrix = mat4_exports.create();
    mat4_exports.invert(iModelMatrix, modelMatrix);
    const normalMatrix = mat4_exports.create();
    mat4_exports.transpose(normalMatrix, iModelMatrix);
    const modelViewProjectionMatrix = mat4_exports.create();
    mat4_exports.multiply(modelViewProjectionMatrix, projectionMatrix, modelMatrix);
    return [modelViewProjectionMatrix, modelMatrix, normalMatrix];
  }
  // not included in public docs
  calculateModelMatrix(azimuth, elevation) {
    if (!this.back) {
      throw new Error("back undefined");
    }
    const modelMatrix = mat4_exports.create();
    modelMatrix[0] = -1;
    mat4_exports.rotateX(modelMatrix, modelMatrix, deg2rad(270 - elevation));
    mat4_exports.rotateZ(modelMatrix, modelMatrix, deg2rad(azimuth - 180));
    if (this.back.obliqueRAS) {
      const oblique = mat4_exports.clone(this.back.obliqueRAS);
      mat4_exports.multiply(modelMatrix, modelMatrix, oblique);
    }
    return modelMatrix;
  }
  // not included in public docs
  // calculate the near-far direction from the camera's perspective
  calculateRayDirection(azimuth, elevation) {
    const modelMatrix = this.calculateModelMatrix(azimuth, elevation);
    const projectionMatrix = mat4_exports.fromValues(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1);
    const mvpMatrix = mat4_exports.create();
    mat4_exports.multiply(mvpMatrix, projectionMatrix, modelMatrix);
    const inv = mat4_exports.create();
    mat4_exports.invert(inv, mvpMatrix);
    const rayDir4 = vec4_exports.fromValues(0, 0, -1, 1);
    vec4_exports.transformMat4(rayDir4, rayDir4, inv);
    const rayDir = vec3_exports.fromValues(rayDir4[0], rayDir4[1], rayDir4[2]);
    vec3_exports.normalize(rayDir, rayDir);
    const tiny = 5e-5;
    if (Math.abs(rayDir[0]) < tiny) {
      rayDir[0] = tiny;
    }
    if (Math.abs(rayDir[1]) < tiny) {
      rayDir[1] = tiny;
    }
    if (Math.abs(rayDir[2]) < tiny) {
      rayDir[2] = tiny;
    }
    return rayDir;
  }
  // not included in public docs
  sceneExtentsMinMax(isSliceMM = true) {
    let mn = vec3_exports.fromValues(0, 0, 0);
    let mx = vec3_exports.fromValues(0, 0, 0);
    if (this.volumes.length > 0) {
      if (!this.volumeObject3D) {
        throw new Error("volumeObject3D undefined");
      }
      mn = vec3_exports.fromValues(
        this.volumeObject3D.extentsMin[0],
        this.volumeObject3D.extentsMin[1],
        this.volumeObject3D.extentsMin[2]
      );
      mx = vec3_exports.fromValues(
        this.volumeObject3D.extentsMax[0],
        this.volumeObject3D.extentsMax[1],
        this.volumeObject3D.extentsMax[2]
      );
      if (!isSliceMM) {
        mn = vec3_exports.fromValues(
          this.volumes[0].extentsMinOrtho[0],
          this.volumes[0].extentsMinOrtho[1],
          this.volumes[0].extentsMinOrtho[2]
        );
        mx = vec3_exports.fromValues(
          this.volumes[0].extentsMaxOrtho[0],
          this.volumes[0].extentsMaxOrtho[1],
          this.volumes[0].extentsMaxOrtho[2]
        );
      }
    }
    if (this.meshes.length > 0) {
      if (this.volumes.length < 1) {
        const minExtents = this.meshes[0].extentsMin;
        const maxExtents = this.meshes[0].extentsMax;
        mn = vec3_exports.fromValues(minExtents[0], minExtents[1], minExtents[2]);
        mx = vec3_exports.fromValues(maxExtents[0], maxExtents[1], maxExtents[2]);
      }
      for (let i = 0; i < this.meshes.length; i++) {
        const minExtents = this.meshes[i].extentsMin;
        const maxExtents = this.meshes[i].extentsMax;
        const vmn = vec3_exports.fromValues(minExtents[0], minExtents[1], minExtents[2]);
        vec3_exports.min(mn, mn, vmn);
        const vmx = vec3_exports.fromValues(maxExtents[0], maxExtents[1], maxExtents[2]);
        vec3_exports.max(mx, mx, vmx);
      }
    }
    const range = vec3_exports.create();
    vec3_exports.subtract(range, mx, mn);
    return [mn, mx, range];
  }
  // not included in public docs
  setPivot3D() {
    const [mn, mx] = this.sceneExtentsMinMax();
    const pivot = vec3_exports.create();
    vec3_exports.add(pivot, mn, mx);
    vec3_exports.scale(pivot, pivot, 0.5);
    this.pivot3D = [pivot[0], pivot[1], pivot[2]];
    vec3_exports.subtract(pivot, mx, mn);
    this.extentsMin = mn;
    this.extentsMax = mx;
    this.furthestFromPivot = vec3_exports.length(pivot) * 0.5;
  }
  // not included in public docs
  getMaxVols() {
    if (this.volumes.length < 1) {
      return 0;
    }
    let maxVols = 0;
    for (let i = 0; i < this.volumes.length; i++) {
      maxVols = Math.max(maxVols, this.volumes[i].nFrame4D);
    }
    return maxVols;
  }
  // not included in public docs
  detectPartialllyLoaded4D() {
    if (this.volumes.length < 1) {
      return false;
    }
    for (let i = 0; i < this.volumes.length; i++) {
      if (this.volumes[i].nFrame4D < this.volumes[i].hdr.dims[4]) {
        return true;
      }
    }
    return false;
  }
  // not included in public docs
  // draw graph for 4D NVImage: time across horizontal, intensity is vertical
  drawGraph() {
    if (this.getMaxVols() < 2) {
      return;
    }
    const graph = this.graph;
    let axialTop = 0;
    if (this.graph.autoSizeMultiplanar && this.opts.sliceType === 3 /* MULTIPLANAR */) {
      for (let i = 0; i < this.screenSlices.length; i++) {
        const axCorSag = this.screenSlices[i].axCorSag;
        if (axCorSag === 0 /* AXIAL */) {
          axialTop = this.screenSlices[i].leftTopWidthHeight[1];
        }
        if (axCorSag !== 2 /* SAGITTAL */) {
          continue;
        }
        const ltwh = this.screenSlices[i].leftTopWidthHeight.slice();
        if (ltwh[1] === axialTop) {
          graph.LTWH[0] = ltwh[0] + ltwh[2];
          graph.LTWH[1] = ltwh[1];
        } else {
          graph.LTWH[0] = ltwh[0];
          graph.LTWH[1] = ltwh[1] + ltwh[3];
        }
        graph.LTWH[2] = ltwh[2];
        graph.LTWH[3] = ltwh[2];
      }
    }
    if (graph.opacity <= 0 || graph.LTWH[2] <= 5 || graph.LTWH[3] <= 5) {
      return;
    }
    if (Math.floor(graph.LTWH[0] + graph.LTWH[2]) > this.gl.canvas.width) {
      return;
    }
    if (Math.floor(graph.LTWH[1] + graph.LTWH[3]) > this.gl.canvas.height) {
      return;
    }
    graph.backColor = [0.15, 0.15, 0.15, graph.opacity];
    graph.lineColor = [1, 1, 1, 1];
    if (this.opts.backColor[0] + this.opts.backColor[1] + this.opts.backColor[2] > 1.5) {
      graph.backColor = [0.95, 0.95, 0.95, graph.opacity];
      graph.lineColor = [0, 0, 0, 1];
    }
    graph.textColor = graph.lineColor.slice();
    graph.lineThickness = 4;
    graph.lineAlpha = 1;
    graph.lines = [];
    const vols = [];
    if (graph.vols.length < 1) {
      if (this.volumes[0] != null) {
        vols.push(0);
      }
    } else {
      for (let i = 0; i < graph.vols.length; i++) {
        const j = graph.vols[i];
        if (this.volumes[j] == null) {
          continue;
        }
        const n = this.volumes[j].nFrame4D;
        if (n < 2) {
          continue;
        }
        vols.push(j);
      }
    }
    if (vols.length < 1) {
      return;
    }
    const maxVols = this.volumes[vols[0]].nFrame4D;
    this.graph.selectedColumn = this.volumes[vols[0]].frame4D;
    if (maxVols < 2) {
      log.debug("Unable to generate a graph: Selected volume is 3D not 4D");
      return;
    }
    for (let i = 0; i < vols.length; i++) {
      graph.lines[i] = [];
      const vox = this.frac2vox(this.scene.crosshairPos);
      const v = this.volumes[vols[i]];
      let n = v.nFrame4D;
      n = Math.min(n, maxVols);
      for (let j = 0; j < n; j++) {
        const val = v.getValue(vox[0], vox[1], vox[2], j);
        graph.lines[i].push(val);
      }
    }
    graph.lineRGB = [
      [1, 0, 0],
      [0, 0.7, 0],
      [0, 0, 1],
      [1, 1, 0],
      [1, 0, 1],
      [0, 1, 1],
      [1, 1, 1],
      [0, 0, 0]
    ];
    let mn = graph.lines[0][0];
    let mx = graph.lines[0][0];
    for (let j = 0; j < graph.lines.length; j++) {
      for (let i = 0; i < graph.lines[j].length; i++) {
        const v = graph.lines[j][i];
        mn = Math.min(v, mn);
        mx = Math.max(v, mx);
      }
    }
    const volMn = this.volumes[vols[0]].cal_min;
    const volMx = this.volumes[vols[0]].cal_max;
    if (graph.isRangeCalMinMax && volMn < volMx && isFinite(volMn) && isFinite(volMx)) {
      mn = volMn;
      mx = volMx;
    }
    if (graph.normalizeValues && mx > mn) {
      const range = mx - mn;
      for (let j = 0; j < graph.lines.length; j++) {
        for (let i = 0; i < graph.lines[j].length; i++) {
          const v = graph.lines[j][i];
          graph.lines[j][i] = (v - mn) / range;
        }
      }
      mn = 0;
      mx = 1;
    }
    if (mn >= mx) {
      mx = mn + 1;
    }
    this.drawRect(graph.LTWH, graph.backColor);
    const [spacing, ticMin, ticMax] = tickSpacing(mn, mx);
    const digits = Math.max(0, -1 * Math.floor(Math.log(spacing) / Math.log(10)));
    mn = Math.min(ticMin, mn);
    mx = Math.max(ticMax, mx);
    function humanize(x) {
      return x.toFixed(6).replace(/\.?0*$/, "");
    }
    const minWH = Math.min(graph.LTWH[2], graph.LTWH[3]);
    const fntScale = 0.07 * (minWH / (this.fontMets.size * this.uiData.dpr));
    let fntSize = this.opts.textHeight * this.gl.canvas.height * fntScale;
    if (fntSize < 16) {
      fntSize = 0;
    }
    let maxTextWid = 0;
    let lineH = ticMin;
    if (fntSize > 0) {
      while (lineH <= mx) {
        const str6 = lineH.toFixed(digits);
        const w = this.textWidth(fntSize, str6);
        maxTextWid = Math.max(w, maxTextWid);
        lineH += spacing;
      }
    }
    const margin = 0.05;
    const frameWid = Math.abs(graph.LTWH[2]);
    const frameHt = Math.abs(graph.LTWH[3]);
    const plotLTWH = [
      graph.LTWH[0] + margin * frameWid + maxTextWid,
      graph.LTWH[1] + margin * frameHt,
      graph.LTWH[2] - maxTextWid - 2 * margin * frameWid,
      graph.LTWH[3] - fntSize - 2 * margin * frameHt
    ];
    this.graph.LTWH = graph.LTWH;
    this.graph.plotLTWH = plotLTWH;
    this.drawRect(plotLTWH, this.opts.backColor);
    const rangeH = mx - mn;
    const scaleH = plotLTWH[3] / rangeH;
    const scaleW = plotLTWH[2] / (graph.lines[0].length - 1);
    const plotBottom = plotLTWH[1] + plotLTWH[3];
    lineH = ticMin + 0.5 * spacing;
    const thinColor = graph.lineColor.slice();
    thinColor[3] = 0.25 * graph.lineColor[3];
    while (lineH <= mx) {
      const y = plotBottom - (lineH - mn) * scaleH;
      this.drawLine([plotLTWH[0], y, plotLTWH[0] + plotLTWH[2], y], 0.5 * graph.lineThickness, thinColor);
      lineH += spacing;
    }
    lineH = ticMin;
    const halfThick = 0.5 * graph.lineThickness;
    while (lineH <= mx) {
      const y = plotBottom - (lineH - mn) * scaleH;
      this.drawLine(
        [plotLTWH[0] - halfThick, y, plotLTWH[0] + plotLTWH[2] + graph.lineThickness, y],
        graph.lineThickness,
        graph.lineColor
      );
      const str6 = lineH.toFixed(digits);
      if (fntSize > 0) {
        this.drawTextLeft([plotLTWH[0] - 6, y], str6, fntScale, graph.textColor);
      }
      lineH += spacing;
    }
    let stride = 1;
    while (graph.lines[0].length / stride > 20) {
      stride *= 5;
    }
    for (let i = 0; i < graph.lines[0].length; i += stride) {
      const x = i * scaleW + plotLTWH[0];
      let thick = graph.lineThickness;
      if (i % 2 === 1) {
        thick *= 0.5;
        this.drawLine([x, plotLTWH[1], x, plotLTWH[1] + plotLTWH[3]], thick, thinColor);
      } else {
        const str6 = humanize(i);
        if (fntSize > 0) {
          this.drawTextBelow([x, 2 + plotLTWH[1] + plotLTWH[3]], str6, fntScale, graph.textColor);
        }
        this.drawLine([x, plotLTWH[1], x, plotLTWH[1] + plotLTWH[3]], thick, graph.lineColor);
      }
    }
    for (let j = 0; j < graph.lines.length; j++) {
      let lineRGBA = [1, 0, 0, graph.lineAlpha];
      if (j < graph.lineRGB.length) {
        lineRGBA = [graph.lineRGB[j][0], graph.lineRGB[j][1], graph.lineRGB[j][2], graph.lineAlpha];
      }
      for (let i = 1; i < graph.lines[j].length; i++) {
        const x0 = (i - 1) * scaleW;
        const x1 = i * scaleW;
        const y0 = (graph.lines[j][i - 1] - mn) * scaleH;
        const y1 = (graph.lines[j][i] - mn) * scaleH;
        const LTWH = [
          plotLTWH[0] + x0,
          plotLTWH[1] + plotLTWH[3] - y0,
          plotLTWH[0] + x1,
          plotLTWH[1] + plotLTWH[3] - y1
        ];
        this.drawLine(LTWH, graph.lineThickness, lineRGBA);
      }
    }
    if (graph.selectedColumn >= 0 && graph.selectedColumn < graph.lines[0].length) {
      const x = graph.selectedColumn * scaleW + plotLTWH[0];
      this.drawLine([x, plotLTWH[1], x, plotLTWH[1] + plotLTWH[3]], graph.lineThickness, [
        graph.lineRGB[3][0],
        graph.lineRGB[3][1],
        graph.lineRGB[3][2],
        1
      ]);
    }
    if (this.detectPartialllyLoaded4D()) {
      this.drawTextBelow(
        [plotLTWH[0] + plotLTWH[2], plotLTWH[1] + plotLTWH[3] + fntSize * 0.5],
        "...",
        fntScale,
        graph.textColor
      );
    }
  }
  // not included in public docs
  depthPicker(leftTopWidthHeight, mvpMatrix) {
    if (!this.uiData.mouseDepthPicker) {
      return;
    }
    this.uiData.mouseDepthPicker = false;
    const gl = this.gl;
    const pixelX = this.mousePos[0] * leftTopWidthHeight[2] / leftTopWidthHeight[2];
    const pixelY = gl.canvas.height - this.mousePos[1] * leftTopWidthHeight[3] / leftTopWidthHeight[3] - 1;
    const rgbaPixel = new Uint8Array(4);
    gl.readPixels(
      pixelX,
      // x
      pixelY,
      // y
      1,
      // width
      1,
      // height
      gl.RGBA,
      // format
      gl.UNSIGNED_BYTE,
      // type
      rgbaPixel
    );
    this.selectedObjectId = rgbaPixel[3];
    if (this.selectedObjectId === this.VOLUME_ID) {
      this.scene.crosshairPos = new Float32Array(rgbaPixel.slice(0, 3)).map((x) => x / 255);
      return;
    }
    const depthZ = unpackFloatFromVec4i(rgbaPixel);
    if (depthZ > 1) {
      return;
    }
    const fracX = (this.mousePos[0] - leftTopWidthHeight[0]) / leftTopWidthHeight[2];
    const fracY = (gl.canvas.height - this.mousePos[1] - leftTopWidthHeight[1]) / leftTopWidthHeight[3];
    const mm = unProject(fracX, fracY, depthZ, mvpMatrix);
    const frac = this.mm2frac(mm, 0, true);
    if (frac[0] < 0 || frac[0] > 1 || frac[1] < 0 || frac[1] > 1 || frac[2] < 0 || frac[2] > 1) {
      return;
    }
    this.scene.crosshairPos = this.mm2frac(mm, 0, true);
  }
  // not included in public docs
  // display 3D volume rendering of NVImage
  drawImage3D(mvpMatrix, azimuth, elevation) {
    if (this.volumes.length === 0) {
      return;
    }
    const gl = this.gl;
    const rayDir = this.calculateRayDirection(azimuth, elevation);
    const object3D = this.volumeObject3D;
    if (object3D) {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.FRONT);
      let shader = this.renderShader;
      if (this.uiData.mouseDepthPicker) {
        shader = this.pickingImageShader;
      }
      shader.use(this.gl);
      gl.uniform1i(shader.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays);
      if (this.gradientTextureAmount > 0) {
        gl.activeTexture(TEXTURE6_GRADIENT);
        gl.bindTexture(gl.TEXTURE_3D, this.gradientTexture);
        const modelMatrix = this.calculateModelMatrix(azimuth, elevation);
        const iModelMatrix = mat4_exports.create();
        mat4_exports.invert(iModelMatrix, modelMatrix);
        const normalMatrix = mat4_exports.create();
        mat4_exports.transpose(normalMatrix, iModelMatrix);
        gl.uniformMatrix4fv(shader.uniforms.normMtx, false, normalMatrix);
      }
      if (this.drawBitmap && this.drawBitmap.length > 8) {
        gl.uniform2f(shader.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, this.drawOpacity);
      } else {
        gl.uniform2f(shader.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, 0);
      }
      gl.uniformMatrix4fv(shader.uniforms.mvpMtx, false, mvpMatrix);
      gl.uniformMatrix4fv(shader.uniforms.matRAS, false, this.back.matRAS);
      gl.uniform3fv(shader.uniforms.rayDir, rayDir);
      if (this.gradientTextureAmount < 0) {
        gl.uniform4fv(shader.uniforms.clipPlane, [
          this.scene.crosshairPos[0],
          this.scene.crosshairPos[1],
          this.scene.crosshairPos[2],
          30
        ]);
      } else {
        gl.uniform4fv(shader.uniforms.clipPlane, this.scene.clipPlane);
      }
      gl.uniform1f(shader.uniforms.drawOpacity, 1);
      gl.bindVertexArray(object3D.vao);
      gl.drawElements(object3D.mode, object3D.indexCount, gl.UNSIGNED_SHORT, 0);
      gl.bindVertexArray(this.unusedVAO);
    }
  }
  // not included in public docs
  // draw cube that shows L/R, A/P, I/S directions
  drawOrientationCube(leftTopWidthHeight, azimuth = 0, elevation = 0) {
    if (!this.opts.isOrientCube) {
      return;
    }
    const sz = 0.05 * Math.min(leftTopWidthHeight[2], leftTopWidthHeight[3]);
    if (sz < 5) {
      return;
    }
    const gl = this.gl;
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    this.orientCubeShader.use(this.gl);
    gl.bindVertexArray(this.orientCubeShaderVAO);
    const modelMatrix = mat4_exports.create();
    const projectionMatrix = mat4_exports.create();
    mat4_exports.ortho(projectionMatrix, 0, gl.canvas.width, 0, gl.canvas.height, -10 * sz, 10 * sz);
    let translateUpForColorbar = 0;
    if (leftTopWidthHeight[1] === 0) {
      translateUpForColorbar = gl.canvas.height - this.effectiveCanvasHeight();
    }
    mat4_exports.translate(modelMatrix, modelMatrix, [
      1.8 * sz + leftTopWidthHeight[0],
      translateUpForColorbar + 1.8 * sz + leftTopWidthHeight[1],
      0
    ]);
    mat4_exports.scale(modelMatrix, modelMatrix, [sz, sz, sz]);
    mat4_exports.rotateX(modelMatrix, modelMatrix, deg2rad(270 - elevation));
    mat4_exports.rotateZ(modelMatrix, modelMatrix, deg2rad(-azimuth));
    const modelViewProjectionMatrix = mat4_exports.create();
    mat4_exports.multiply(modelViewProjectionMatrix, projectionMatrix, modelMatrix);
    gl.uniformMatrix4fv(this.orientCubeShader.uniforms.u_matrix, false, modelViewProjectionMatrix);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 168);
    gl.bindVertexArray(this.unusedVAO);
    this.gl.disable(this.gl.CULL_FACE);
  }
  // not included in public docs
  // fills data returned with the onLocationChanvge() callback
  createOnLocationChange(axCorSag = NaN) {
    const [_mn, _mx, range] = this.sceneExtentsMinMax(true);
    const fov = Math.max(Math.max(range[0], range[1]), range[2]);
    function dynamicDecimals(flt2) {
      return Math.max(0, -Math.ceil(Math.log10(Math.abs(flt2))));
    }
    let deci = dynamicDecimals(fov * 1e-3);
    const mm = this.frac2mm(this.scene.crosshairPos, 0, true);
    function flt2str(flt2, decimals = 0) {
      return parseFloat(flt2.toFixed(decimals));
    }
    let str6 = flt2str(mm[0], deci) + "\xD7" + flt2str(mm[1], deci) + "\xD7" + flt2str(mm[2], deci);
    if (this.volumes.length > 0 && this.volumes[0].nFrame4D > 0) {
      str6 += "\xD7" + flt2str(this.volumes[0].frame4D);
    }
    if (this.volumes.length > 0) {
      let valStr = " = ";
      for (let i = 0; i < this.volumes.length; i++) {
        const vox = this.volumes[i].mm2vox(mm);
        let flt2 = this.volumes[i].getValue(vox[0], vox[1], vox[2], this.volumes[i].frame4D);
        deci = 3;
        if (this.volumes[i].colormapLabel !== null) {
          const v = Math.round(flt2);
          if (v >= 0 && v < this.volumes[i].colormapLabel.labels.length) {
            valStr += this.volumes[i].colormapLabel.labels[v];
          } else {
            valStr += "undefined(" + flt2str(flt2, deci) + ")";
          }
        } else {
          valStr += flt2str(flt2, deci);
        }
        if (this.volumes[i].imaginary) {
          flt2 = this.volumes[i].getValue(vox[0], vox[1], vox[2], this.volumes[i].frame4D, true);
          if (flt2 >= 0) {
            valStr += "+";
          }
          valStr += flt2str(flt2, deci);
        }
        valStr += "   ";
      }
      str6 += valStr;
      const dims = this.back.dimsRAS;
      const nv = dims[1] * dims[2] * dims[3];
      if (this.drawBitmap && this.drawBitmap.length === nv) {
        const vox = this.frac2vox(this.scene.crosshairPos);
        const vx = vox[0] + vox[1] * dims[1] + vox[2] * dims[1] * dims[2];
        str6 += " " + this.drawLut.labels[this.drawBitmap[vx]];
      }
    }
    const msg = {
      mm: this.frac2mm(this.scene.crosshairPos, 0, true),
      axCorSag,
      vox: this.frac2vox(this.scene.crosshairPos),
      frac: this.scene.crosshairPos,
      xy: [this.mousePos[0], this.mousePos[1]],
      values: this.volumes.map((v) => {
        const mm2 = this.frac2mm(this.scene.crosshairPos, 0, true);
        const vox = v.mm2vox(mm2);
        const val = v.getValue(vox[0], vox[1], vox[2], v.frame4D);
        return {
          name: v.name,
          value: val,
          id: v.id,
          mm: mm2,
          vox
        };
      }),
      string: str6
    };
    this.onLocationChange(msg);
  }
  /**
   * Add a 3D Label
   * @param text - text of the label
   * @param style - label style
   * @param point - 3D point on the model
   */
  addLabel(text, style, points, anchor, onClick) {
    const defaultStyle = {
      textColor: this.opts.legendTextColor,
      textScale: 1,
      textAlignment: "left" /* LEFT */,
      lineWidth: 0,
      lineColor: this.opts.legendTextColor,
      lineTerminator: "none" /* NONE */,
      bulletScale: 0,
      bulletColor: this.opts.legendTextColor
    };
    const labelStyle = style ? { ...defaultStyle, ...style } : { ...defaultStyle };
    const label = new NVLabel3D(text, { ...labelStyle }, points, anchor, onClick);
    this.document.labels.push(label);
    return label;
  }
  // not included in public docs
  calculateScreenPoint(point, mvpMatrix, leftTopWidthHeight) {
    const screenPoint = vec4_exports.create();
    vec4_exports.transformMat4(screenPoint, [...point, 1], mvpMatrix);
    if (screenPoint[3] !== 0) {
      screenPoint[0] = (screenPoint[0] / screenPoint[3] + 1) * 0.5 * leftTopWidthHeight[2];
      screenPoint[1] = (1 - screenPoint[1] / screenPoint[3]) * 0.5 * leftTopWidthHeight[3];
      screenPoint[2] /= screenPoint[3];
      screenPoint[0] += leftTopWidthHeight[0];
      screenPoint[1] += leftTopWidthHeight[1];
    }
    return screenPoint;
  }
  getLabelAtPoint(screenPoint) {
    const scale6 = 1;
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * scale6;
    const verticalMargin = this.opts.textHeight * this.gl.canvas.height * scale6;
    for (const label of this.document.labels) {
      if (label.anchor == null || label.anchor === 0 /* NONE */) {
        continue;
      }
      const labelSize = this.opts.textHeight * this.gl.canvas.height * label.style.textScale;
      const textHeight = this.textHeight(labelSize, label.text);
      const textWidth = this.textWidth(labelSize, label.text);
      if (label.anchor & 1 /* LEFT */) {
        if (screenPoint[0] > textWidth) {
          continue;
        }
      }
      if (label.anchor & 2 /* CENTER */) {
        if (screenPoint[0] < (this.gl.canvas.width - textWidth) / 2) {
          continue;
        }
        if (screenPoint[0] > (this.gl.canvas.width + textWidth) / 2) {
          continue;
        }
      }
      if (label.anchor & 4 /* RIGHT */) {
        if (screenPoint[0] < this.gl.canvas.width - textWidth) {
          continue;
        }
      }
      if (label.anchor & 8 /* TOP */) {
        if (screenPoint[1] < verticalMargin / 2) {
          continue;
        }
        if (screenPoint[1] > textHeight + verticalMargin / 2) {
          continue;
        }
      }
      if (label.anchor & 16 /* MIDDLE */) {
        if (screenPoint[1] < (this.gl.canvas.height - textHeight - verticalMargin) / 2) {
          continue;
        }
        if (screenPoint[1] > (this.gl.canvas.height + textHeight - verticalMargin / 2) / 2) {
          continue;
        }
      }
      if (label.anchor & 32 /* BOTTOM */) {
        if (screenPoint[1] < this.gl.canvas.height - textHeight - verticalMargin) {
          continue;
        }
        if (screenPoint[1] > this.gl.canvas.height - verticalMargin / 2) {
          continue;
        }
      }
      return label;
    }
    log.debug("screenPoint", screenPoint);
    const panelHeight = this.getLegendPanelHeight();
    const panelWidth = this.getLegendPanelWidth();
    const left = this.gl.canvas.width - panelWidth;
    let top = (this.canvas.height - panelHeight) / 2;
    log.debug("panelrect", left, top, left + panelWidth, top + panelHeight);
    if (screenPoint[0] < left || screenPoint[1] < top || screenPoint[0] > left + panelWidth || screenPoint[1] > top + panelHeight) {
      return null;
    }
    const labels = this.getConnectomeLabels();
    for (const label of labels) {
      const labelSize = this.opts.textHeight * this.gl.canvas.height * label.style.textScale;
      const textHeight = this.textHeight(labelSize, label.text);
      if (screenPoint[1] >= top && screenPoint[1] <= top + textHeight + size / 2) {
        return label;
      }
      top += textHeight;
      top += size / 2;
    }
    return null;
  }
  drawLabelLine(label, pos, mvpMatrix, leftTopWidthHeight, secondPass = false) {
    const points = Array.isArray(label.points) && Array.isArray(label.points[0]) ? label.points : [label.points];
    for (const point of points) {
      const screenPoint = this.calculateScreenPoint(point, mvpMatrix, leftTopWidthHeight);
      if (!secondPass) {
        this.draw3DLine(
          pos,
          [screenPoint[0], screenPoint[1], screenPoint[2]],
          label.style.lineWidth,
          label.style.lineColor
        );
      } else {
        this.drawDottedLine([...pos, screenPoint[0], screenPoint[1]], label.style.lineWidth, label.style.lineColor);
      }
    }
  }
  // not included in public docs
  draw3DLabel(label, pos, mvpMatrix, leftTopWidthHeight, bulletMargin, legendWidth, secondPass) {
    const text = label.text;
    const left = pos[0];
    const top = pos[1];
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * 1;
    const textHeight = this.textHeight(label.style.textScale, text) * size;
    if (label.style.lineWidth > 0 && Array.isArray(label.points)) {
      this.drawLabelLine(label, [left, top + textHeight], mvpMatrix, leftTopWidthHeight, secondPass);
    }
    if (label.style.bulletScale) {
      const bulletSize = label.style.bulletScale * textHeight;
      const diff = textHeight - bulletSize;
      const rectTop = top + diff / 2 + bulletSize / 2;
      const rectLeft = left + (bulletMargin - bulletSize) / 2;
      this.drawCircle([rectLeft, rectTop, bulletSize, bulletSize], label.style.bulletColor);
    }
    let textLeft = left;
    if (legendWidth) {
      if (label.style.textAlignment !== "left" /* LEFT */) {
        const textWidth = this.textWidth(label.style.textScale, label.text) * size;
        if (label.style.textAlignment === "right" /* RIGHT */) {
          textLeft = left + legendWidth - size * 1.5 - textWidth;
        } else {
          const remaining = legendWidth - (bulletMargin || size);
          textLeft += (remaining - textWidth) / 2;
        }
      } else {
        textLeft += bulletMargin;
      }
    }
    this.drawText([textLeft, top], text, label.style.textScale, label.style.textColor);
  }
  // not included in public docs
  draw3DLabels(mvpMatrix, leftTopWidthHeight, secondPass = false) {
    const labels = this.getConnectomeLabels();
    if (!this.opts.showLegend || labels.length === 0) {
      return;
    }
    if (!this.canvas) {
      throw new Error("canvas undefined");
    }
    const gl = this.gl;
    gl.disable(gl.CULL_FACE);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    const scale6 = 1;
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * scale6;
    const bulletMargin = this.getBulletMarginWidth();
    const panelHeight = this.getLegendPanelHeight();
    const panelWidth = this.getLegendPanelWidth();
    const left = gl.canvas.width - panelWidth;
    let top = (this.canvas.height - panelHeight) / 2;
    this.drawRect([gl.canvas.width - panelWidth, top, panelWidth - size, panelHeight], this.opts.legendBackgroundColor);
    const blend = gl.getParameter(gl.BLEND);
    const depthFunc = gl.getParameter(gl.DEPTH_FUNC);
    if (!secondPass) {
      gl.disable(gl.BLEND);
      gl.depthFunc(gl.GREATER);
    }
    for (const label of labels) {
      this.draw3DLabel(label, [left, top], mvpMatrix, leftTopWidthHeight, bulletMargin, panelWidth, secondPass);
      const labelSize = this.opts.textHeight * this.gl.canvas.height * label.style.textScale;
      const textHeight = this.textHeight(labelSize, label.text);
      top += textHeight;
      top += size / 2;
    }
    if (!secondPass) {
      gl.depthFunc(depthFunc);
      if (blend) {
        gl.enable(gl.BLEND);
      }
    }
  }
  drawAnchoredLabels() {
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * 1;
    const anchoredLabels = this.document.labels.filter((l) => l.anchor != null && l.anchor !== 0 /* NONE */);
    for (const label of anchoredLabels) {
      const text = label.text;
      const textHeight = this.textHeight(label.style.textScale, text) * size;
      const textWidth = this.textWidth(label.style.textScale, text) * size;
      let left;
      let top;
      const scale6 = 1;
      const verticalMargin = this.opts.textHeight * this.gl.canvas.height * scale6;
      const rectHeightDiff = verticalMargin;
      let rectWidthDiff = verticalMargin / 4;
      let rectHorizontalOffset = 0;
      let rectVerticalOffset = 0;
      if (label.anchor & 1 /* LEFT */) {
        left = 0;
      }
      if (label.anchor & 4 /* RIGHT */) {
        left = this.canvas.width - textWidth;
        rectHorizontalOffset -= verticalMargin / 4;
      }
      if (label.anchor & 2 /* CENTER */) {
        left = (this.canvas.width - textWidth) / 2;
        rectHorizontalOffset -= verticalMargin / 4;
        rectWidthDiff += verticalMargin / 4;
      }
      if (label.anchor & 8 /* TOP */) {
        top = 0;
      }
      if (label.anchor & 16 /* MIDDLE */) {
        top = (this.canvas.height - textHeight - verticalMargin) / 2;
        rectVerticalOffset -= verticalMargin / 4;
      }
      if (label.anchor & 32 /* BOTTOM */) {
        top = this.canvas.height - textHeight - verticalMargin;
        rectVerticalOffset -= verticalMargin / 4;
      }
      this.drawRect(
        [left + rectHorizontalOffset, top + rectVerticalOffset, textWidth + rectWidthDiff, textHeight + rectHeightDiff],
        label.style.backgroundColor
      );
      this.draw3DLabel(label, [left, top]);
    }
  }
  // not included in public docs
  draw3D(leftTopWidthHeight = [0, 0, 0, 0], mvpMatrix = null, modelMatrix = null, normalMatrix = null, azimuth = null, elevation = 0) {
    const isMosaic = azimuth !== null;
    this.setPivot3D();
    if (!isMosaic) {
      azimuth = this.scene.renderAzimuth;
      elevation = this.scene.renderElevation;
    }
    const gl = this.gl;
    if (mvpMatrix === null) {
      ;
      [mvpMatrix, modelMatrix, normalMatrix] = this.calculateMvpMatrix(null, leftTopWidthHeight, azimuth, elevation);
    }
    let relativeLTWH = [...leftTopWidthHeight];
    if (leftTopWidthHeight[2] === 0 || leftTopWidthHeight[3] === 0) {
      leftTopWidthHeight = [0, 0, gl.canvas.width, gl.canvas.height];
      relativeLTWH = [...leftTopWidthHeight];
      this.screenSlices.push({
        leftTopWidthHeight,
        axCorSag: 4 /* RENDER */,
        sliceFrac: 0,
        AxyzMxy: [],
        leftTopMM: [],
        fovMM: [isRadiological(modelMatrix), 0]
      });
    } else {
      this.screenSlices.push({
        leftTopWidthHeight: leftTopWidthHeight.slice(),
        axCorSag: 4 /* RENDER */,
        sliceFrac: 0,
        AxyzMxy: [],
        leftTopMM: [],
        fovMM: [isRadiological(modelMatrix), 0]
      });
      leftTopWidthHeight[1] = gl.canvas.height - leftTopWidthHeight[3] - leftTopWidthHeight[1];
    }
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.ALWAYS);
    gl.depthMask(true);
    gl.clearDepth(0);
    this.draw3DLabels(mvpMatrix, relativeLTWH, false);
    gl.viewport(leftTopWidthHeight[0], leftTopWidthHeight[1], leftTopWidthHeight[2], leftTopWidthHeight[3]);
    if (this.volumes.length > 0) {
      this.updateInterpolation(0, true);
      this.updateInterpolation(1, true);
      this.drawImage3D(mvpMatrix, azimuth, elevation);
    }
    this.updateInterpolation(0);
    this.updateInterpolation(1);
    if (!isMosaic) {
      this.drawCrosshairs3D(true, 1, mvpMatrix);
    }
    this.drawMesh3D(true, 1, mvpMatrix, modelMatrix, normalMatrix);
    if (this.uiData.mouseDepthPicker) {
      this.depthPicker(leftTopWidthHeight, mvpMatrix);
      this.createOnLocationChange();
      this.draw3D(leftTopWidthHeight, mvpMatrix, modelMatrix, normalMatrix, azimuth, elevation);
      return;
    }
    if (this.opts.meshXRay > 0) {
      this.drawMesh3D(false, this.opts.meshXRay, mvpMatrix, modelMatrix, normalMatrix);
    }
    this.draw3DLabels(mvpMatrix, relativeLTWH, false);
    gl.viewport(leftTopWidthHeight[0], leftTopWidthHeight[1], leftTopWidthHeight[2], leftTopWidthHeight[3]);
    if (!isMosaic) {
      this.drawCrosshairs3D(false, 0.15, mvpMatrix);
    }
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    this.drawOrientationCube(leftTopWidthHeight, azimuth, elevation);
    const posString = "azimuth: " + this.scene.renderAzimuth.toFixed(0) + " elevation: " + this.scene.renderElevation.toFixed(0);
    this.readyForSync = true;
    this.sync();
    this.draw3DLabels(mvpMatrix, relativeLTWH, true);
    return posString;
  }
  // not included in public docs
  // create 3D rendering of NVMesh on canvas
  drawMesh3D(isDepthTest = true, alpha = 1, m, modelMtx, normMtx) {
    if (this.meshes.length < 1) {
      return;
    }
    const gl = this.gl;
    if (!m) {
      ;
      [m, modelMtx, normMtx] = this.calculateMvpMatrix(
        this.volumeObject3D,
        void 0,
        this.scene.renderAzimuth,
        this.scene.renderElevation
      );
    }
    gl.enable(gl.DEPTH_TEST);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.BLEND);
    gl.depthFunc(gl.GREATER);
    gl.disable(gl.CULL_FACE);
    if (isDepthTest) {
      gl.disable(gl.BLEND);
      gl.depthFunc(gl.GREATER);
    } else {
      gl.enable(gl.BLEND);
      gl.depthFunc(gl.ALWAYS);
      gl.enable(gl.CULL_FACE);
    }
    gl.cullFace(gl.BACK);
    let shader = this.meshShaders[0].shader;
    let hasFibers = false;
    for (let i = 0; i < this.meshes.length; i++) {
      if (this.meshes[i].visible === false) {
        continue;
      }
      shader = this.meshShaders[this.meshes[i].meshShaderIndex].shader;
      if (this.uiData.mouseDepthPicker) {
        shader = this.pickingMeshShader;
      }
      shader.use(this.gl);
      gl.uniformMatrix4fv(shader.uniforms.mvpMtx, false, m);
      gl.uniformMatrix4fv(shader.uniforms.normMtx, false, normMtx);
      gl.uniform1f(shader.uniforms.opacity, alpha);
      if (this.meshes[i].indexCount < 3) {
        continue;
      }
      if (this.meshes[i].offsetPt0 && (this.meshes[i].fiberSides < 3 || this.meshes[i].fiberRadius <= 0)) {
        hasFibers = true;
        continue;
      }
      if (shader.isMatcap) {
        gl.activeTexture(TEXTURE5_MATCAP);
        gl.bindTexture(gl.TEXTURE_2D, this.matCapTexture);
      }
      gl.bindVertexArray(this.meshes[i].vao);
      gl.drawElements(gl.TRIANGLES, this.meshes[i].indexCount, gl.UNSIGNED_INT, 0);
      gl.bindVertexArray(this.unusedVAO);
    }
    if (!hasFibers) {
      gl.enable(gl.BLEND);
      gl.depthFunc(gl.ALWAYS);
      return;
    }
    shader = this.fiberShader;
    shader.use(this.gl);
    gl.uniformMatrix4fv(shader.uniforms.mvpMtx, false, m);
    gl.uniform1f(shader.uniforms.opacity, alpha);
    for (let i = 0; i < this.meshes.length; i++) {
      if (this.meshes[i].indexCount < 3) {
        continue;
      }
      if (!this.meshes[i].offsetPt0) {
        continue;
      }
      if (this.meshes[i].fiberSides >= 3 && this.meshes[i].fiberRadius > 0) {
        continue;
      }
      gl.bindVertexArray(this.meshes[i].vaoFiber);
      gl.drawElements(gl.LINE_STRIP, this.meshes[i].indexCount, gl.UNSIGNED_INT, 0);
      gl.bindVertexArray(this.unusedVAO);
    }
    gl.enable(gl.BLEND);
    gl.depthFunc(gl.ALWAYS);
    this.readyForSync = true;
  }
  // not included in public docs
  drawCrosshairs3D(isDepthTest = true, alpha = 1, mvpMtx = null, is2DView = false, isSliceMM = true) {
    if (!this.opts.show3Dcrosshair && !is2DView) {
      return;
    }
    if (this.opts.crosshairWidth <= 0 && is2DView) {
      return;
    }
    const gl = this.gl;
    const mm = this.frac2mm(this.scene.crosshairPos, 0, isSliceMM);
    let radius = 1;
    const [mn, mx, range] = this.sceneExtentsMinMax(isSliceMM);
    if (this.volumes.length > 0) {
      if (!this.back) {
        throw new Error("back undefined");
      }
      radius = 0.5 * Math.min(Math.min(this.back.pixDims[1], this.back.pixDims[2]), this.back.pixDims[3]);
    } else if (range[0] < 50 || range[0] > 1e3) {
      radius = range[0] * 0.02;
    }
    radius *= this.opts.crosshairWidth;
    if (this.opts?.crosshairWidthUnit === "percent") {
      radius = range[0] * this.opts.crosshairWidth * 0.5 * 0.01;
    }
    if (this.opts?.crosshairWidthUnit === "mm") {
      radius = this.opts.crosshairWidth * 0.5;
    }
    if (this.crosshairs3D === null || this.crosshairs3D.mm[0] !== mm[0] || this.crosshairs3D.mm[1] !== mm[1] || this.crosshairs3D.mm[2] !== mm[2]) {
      if (this.crosshairs3D !== null) {
        gl.deleteBuffer(this.crosshairs3D.indexBuffer);
        gl.deleteBuffer(this.crosshairs3D.vertexBuffer);
      }
      this.crosshairs3D = NiivueObject3D.generateCrosshairs(this.gl, 1, mm, mn, mx, radius, 20, this.opts.crosshairGap);
      this.crosshairs3D.mm = mm;
    }
    if (!this.surfaceShader) {
      throw new Error("surfaceShader undefined");
    }
    const crosshairsShader = this.surfaceShader;
    crosshairsShader.use(this.gl);
    if (mvpMtx == null) {
      ;
      [mvpMtx] = this.calculateMvpMatrix(
        this.crosshairs3D,
        void 0,
        this.scene.renderAzimuth,
        this.scene.renderElevation
      );
    }
    gl.uniformMatrix4fv(crosshairsShader.uniforms.mvpMtx, false, mvpMtx);
    gl.disable(gl.CULL_FACE);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.crosshairs3D.indexBuffer);
    gl.enable(gl.DEPTH_TEST);
    const color = [...this.opts.crosshairColor];
    if (isDepthTest) {
      gl.disable(gl.BLEND);
      gl.depthFunc(gl.GREATER);
    } else {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthFunc(gl.ALWAYS);
    }
    color[3] = alpha;
    gl.uniform4fv(crosshairsShader.uniforms.surfaceColor, color);
    gl.bindVertexArray(this.crosshairs3D.vao);
    gl.drawElements(
      gl.TRIANGLES,
      this.crosshairs3D.indexCount,
      gl.UNSIGNED_INT,
      // gl.UNSIGNED_SHORT,
      0
    );
    gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  mm2frac(mm, volIdx = 0, isForceSliceMM = false) {
    if (this.volumes.length < 1) {
      const frac = vec3_exports.fromValues(0.1, 0.5, 0.5);
      const [mn, _mx, range] = this.sceneExtentsMinMax();
      frac[0] = (mm[0] - mn[0]) / range[0];
      frac[1] = (mm[1] - mn[1]) / range[1];
      frac[2] = (mm[2] - mn[2]) / range[2];
      if (!isFinite(frac)) {
        if (!isFinite(frac[0])) {
          frac[0] = 0.5;
        }
        if (!isFinite(frac[1])) {
          frac[1] = 0.5;
        }
        if (!isFinite(frac[2])) {
          frac[2] = 0.5;
        }
        if (this.meshes.length < 1) {
          log.error("mm2frac() not finite: objects not (yet) loaded.");
        }
      }
      return frac;
    }
    return this.volumes[volIdx].convertMM2Frac(mm, isForceSliceMM || this.opts.isSliceMM);
  }
  // not included in public docs
  vox2frac(vox, volIdx = 0) {
    return this.volumes[volIdx].convertVox2Frac(vox);
  }
  // not included in public docs
  frac2vox(frac, volIdx = 0) {
    if (this.volumes.length <= volIdx) {
      return [0, 0, 0];
    }
    return this.volumes[volIdx].convertFrac2Vox(frac);
  }
  /**
   * move crosshair a fixed number of voxels (not mm)
   * @param x - translate left (-) or right (+)
   * @param y - translate posterior (-) or +anterior (+)
   * @param z - translate inferior (-) or superior (+)
   * @example niivue.moveCrosshairInVox(1, 0, 0)
   * @see {@link https://niivue.github.io/niivue/features/draw2.html | live demo usage}
   */
  moveCrosshairInVox(x, y, z) {
    const vox = this.frac2vox(this.scene.crosshairPos);
    vox[0] += x;
    vox[1] += y;
    vox[2] += z;
    vox[0] = clamp(vox[0], 0, this.volumes[0].dimsRAS[1] - 1);
    vox[1] = clamp(vox[1], 0, this.volumes[0].dimsRAS[2] - 1);
    vox[2] = clamp(vox[2], 0, this.volumes[0].dimsRAS[3] - 1);
    this.scene.crosshairPos = this.vox2frac(vox);
    this.createOnLocationChange();
    this.drawScene();
  }
  // not included in public docs
  frac2mm(frac, volIdx = 0, isForceSliceMM = false) {
    const pos = vec4_exports.fromValues(frac[0], frac[1], frac[2], 1);
    if (this.volumes.length > 0) {
      return this.volumes[volIdx].convertFrac2MM(frac, isForceSliceMM || this.opts.isSliceMM);
    } else {
      const [mn, mx] = this.sceneExtentsMinMax();
      const lerp4 = (x, y, a) => x * (1 - a) + y * a;
      pos[0] = lerp4(mn[0], mx[0], frac[0]);
      pos[1] = lerp4(mn[1], mx[1], frac[1]);
      pos[2] = lerp4(mn[2], mx[2], frac[2]);
    }
    return pos;
  }
  // not included in public docs
  screenXY2TextureFrac(x, y, i, restrict0to1 = true) {
    const texFrac = vec3_exports.fromValues(-1, -1, -1);
    const axCorSag = this.screenSlices[i].axCorSag;
    if (axCorSag > 2 /* SAGITTAL */) {
      return texFrac;
    }
    const ltwh = this.screenSlices[i].leftTopWidthHeight.slice();
    let isMirror = false;
    if (ltwh[2] < 0) {
      isMirror = true;
      ltwh[0] += ltwh[2];
      ltwh[2] = -ltwh[2];
    }
    let fracX = (x - ltwh[0]) / ltwh[2];
    if (isMirror) {
      fracX = 1 - fracX;
    }
    const fracY = 1 - (y - ltwh[1]) / ltwh[3];
    if (fracX < 0 || fracX > 1 || fracY < 0 || fracY > 1) {
      return texFrac;
    }
    if (this.screenSlices[i].AxyzMxy.length < 4) {
      return texFrac;
    }
    let xyzMM = vec3_exports.fromValues(0, 0, 0);
    xyzMM[0] = this.screenSlices[i].leftTopMM[0] + fracX * this.screenSlices[i].fovMM[0];
    xyzMM[1] = this.screenSlices[i].leftTopMM[1] + fracY * this.screenSlices[i].fovMM[1];
    const v = this.screenSlices[i].AxyzMxy;
    xyzMM[2] = v[2] + v[4] * (xyzMM[1] - v[1]) - v[3] * (xyzMM[0] - v[0]);
    if (axCorSag === 1 /* CORONAL */) {
      xyzMM = swizzleVec3(xyzMM, [0, 2, 1]);
    }
    if (axCorSag === 2 /* SAGITTAL */) {
      xyzMM = swizzleVec3(xyzMM, [2, 0, 1]);
    }
    const xyz = this.mm2frac(xyzMM);
    if (restrict0to1) {
      if (xyz[0] < 0 || xyz[0] > 1 || xyz[1] < 0 || xyz[1] > 1 || xyz[2] < 0 || xyz[2] > 1) {
        return texFrac;
      }
    }
    return xyz;
  }
  // not included in public docs
  canvasPos2frac(canvasPos) {
    for (let i = 0; i < this.screenSlices.length; i++) {
      const texFrac = this.screenXY2TextureFrac(canvasPos[0], canvasPos[1], i);
      if (texFrac[0] >= 0) {
        return texFrac;
      }
    }
    return [-1, -1, -1];
  }
  // not included in public docs
  // note: we also have a "sliceScale" method, which could be confusing
  scaleSlice(w, h, padPixelsWH = [0, 0], canvasWH = [0, 0]) {
    const canvasW = canvasWH[0] === 0 ? this.effectiveCanvasWidth() - padPixelsWH[0] : canvasWH[0] - padPixelsWH[0];
    const canvasH = canvasWH[1] === 0 ? this.effectiveCanvasHeight() - padPixelsWH[1] : canvasWH[1] - padPixelsWH[1];
    let scalePix = canvasW / w;
    if (h * scalePix > canvasH) {
      scalePix = canvasH / h;
    }
    const wPix = w * scalePix;
    const hPix = h * scalePix;
    const leftTopWidthHeight = [(canvasW - wPix) * 0.5, (canvasH - hPix) * 0.5, wPix, hPix, scalePix];
    return leftTopWidthHeight;
  }
  // not included in public docs
  // display 2D image to defer loading of (slow) 3D data
  drawThumbnail() {
    if (!this.bmpShader) {
      throw new Error("bmpShader undefined");
    }
    this.bmpShader.use(this.gl);
    this.gl.uniform2f(this.bmpShader.uniforms.canvasWidthHeight, this.gl.canvas.width, this.gl.canvas.height);
    let h = this.gl.canvas.height;
    let w = this.gl.canvas.height * this.bmpTextureWH;
    if (w > this.gl.canvas.width) {
      h = this.gl.canvas.width / this.bmpTextureWH;
      w = this.gl.canvas.width;
    }
    const left = (this.gl.canvas.width - w) / 2;
    const top = (this.gl.canvas.height - h) / 2;
    this.gl.uniform4f(this.bmpShader.uniforms.leftTopWidthHeight, left, top, w, h);
    this.gl.bindVertexArray(this.genericVAO);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  // draw line (can be diagonal)
  // unless Alpha is > 0, default color is opts.crosshairColor
  drawLine(startXYendXY, thickness = 1, lineColor = [1, 0, 0, -1]) {
    this.gl.bindVertexArray(this.genericVAO);
    if (!this.lineShader) {
      throw new Error("lineShader undefined");
    }
    this.lineShader.use(this.gl);
    if (lineColor[3] < 0) {
      lineColor = this.opts.crosshairColor;
    }
    this.gl.uniform4fv(this.lineShader.uniforms.lineColor, lineColor);
    this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.uniform1f(this.lineShader.uniforms.thickness, thickness);
    this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, startXYendXY);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  // draw line (can be diagonal)
  // unless Alpha is > 0, default color is opts.crosshairColor
  draw3DLine(startXY, endXYZ, thickness = 1, lineColor = [1, 0, 0, -1]) {
    this.gl.bindVertexArray(this.genericVAO);
    if (!this.line3DShader) {
      throw new Error("line3DShader undefined");
    }
    this.line3DShader.use(this.gl);
    if (lineColor[3] < 0) {
      lineColor = this.opts.crosshairColor;
    }
    this.gl.uniform4fv(this.line3DShader.uniforms.lineColor, lineColor);
    this.gl.uniform2fv(this.line3DShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.uniform1f(this.line3DShader.uniforms.thickness, thickness);
    this.gl.uniform2fv(this.line3DShader.uniforms.startXY, startXY);
    this.gl.uniform3fv(this.line3DShader.uniforms.endXYZ, endXYZ);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.bindVertexArray(this.unusedVAO);
  }
  drawDottedLine(startXYendXY, thickness = 1, lineColor = [1, 0, 0, -1]) {
    this.gl.bindVertexArray(this.genericVAO);
    if (!this.lineShader) {
      throw new Error("lineShader undefined");
    }
    this.lineShader.use(this.gl);
    const dottedLineColor = lineColor[3] < 0 ? [...this.opts.crosshairColor] : [...lineColor];
    dottedLineColor[3] = 0.3;
    const segment = vec2_exports.fromValues(startXYendXY[2] - startXYendXY[0], startXYendXY[3] - startXYendXY[1]);
    const totalLength = vec2_exports.length(segment);
    vec2_exports.normalize(segment, segment);
    const scale6 = 1;
    const size = this.opts.textHeight * Math.min(this.gl.canvas.height, this.gl.canvas.width) * scale6;
    vec2_exports.scale(segment, segment, size / 2);
    const segmentLength = vec2_exports.length(segment);
    let segmentCount = Math.floor(totalLength / segmentLength);
    if (totalLength % segmentLength) {
      segmentCount++;
    }
    const currentSegmentXY = [startXYendXY[0], startXYendXY[1]];
    this.gl.uniform4fv(this.lineShader.uniforms.lineColor, dottedLineColor);
    this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]);
    this.gl.uniform1f(this.lineShader.uniforms.thickness, thickness);
    for (let i = 0; i < segmentCount - 1; i++) {
      if (i % 2) {
        currentSegmentXY[0] += segment[0];
        currentSegmentXY[1] += segment[1];
        continue;
      }
      const segmentStartXYendXY = [
        currentSegmentXY[0],
        currentSegmentXY[1],
        currentSegmentXY[0] + segment[0],
        currentSegmentXY[1] + segment[1]
      ];
      this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, segmentStartXYendXY);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      currentSegmentXY[0] += segment[0];
      currentSegmentXY[1] += segment[1];
    }
    this.gl.bindVertexArray(this.unusedVAO);
  }
  // not included in public docs
  drawGraphLine(LTRB, color = [1, 0, 0, 0.5], thickness = 2) {
    this.drawLine(LTRB, thickness, color);
  }
  // not included in public docs
  drawCrossLinesMM(sliceIndex, axCorSag, axiMM, corMM, sagMM) {
    if (sliceIndex < 0 || this.screenSlices.length <= sliceIndex) {
      return;
    }
    const tile = this.screenSlices[sliceIndex];
    let sliceFrac = tile.sliceFrac;
    const isRender = sliceFrac === Infinity;
    if (isRender) {
      log.warn("Rendering approximate cross lines in world view mode");
    }
    if (sliceFrac === Infinity) {
      sliceFrac = 0.5;
    }
    let linesH = corMM.slice();
    let linesV = sagMM.slice();
    const thick = Math.max(1, this.opts.crosshairWidth);
    if (axCorSag === 1 /* CORONAL */) {
      linesH = axiMM.slice();
    }
    if (axCorSag === 2 /* SAGITTAL */) {
      linesH = axiMM.slice();
      linesV = corMM.slice();
    }
    function mm2screen(mm) {
      const screenXY = vec2_exports.fromValues(0, 0);
      screenXY[0] = tile.leftTopWidthHeight[0] + (mm[0] - tile.leftTopMM[0]) / tile.fovMM[0] * tile.leftTopWidthHeight[2];
      screenXY[1] = tile.leftTopWidthHeight[1] + tile.leftTopWidthHeight[3] - (mm[1] - tile.leftTopMM[1]) / tile.fovMM[1] * tile.leftTopWidthHeight[3];
      return screenXY;
    }
    if (linesH.length > 0 && axCorSag === 0) {
      const fracZ = sliceFrac;
      const dimV = 1;
      for (let i = 0; i < linesH.length; i++) {
        const mmV = this.frac2mm([0.5, 0.5, 0.5]);
        mmV[dimV] = linesH[i];
        let fracY = this.mm2frac(mmV);
        fracY = fracY[dimV];
        let left = this.frac2mm([0, fracY, fracZ]);
        left = swizzleVec3(left, [0, 1, 2]);
        let right = this.frac2mm([1, fracY, fracZ]);
        right = swizzleVec3(right, [0, 1, 2]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
    if (linesH.length > 0 && axCorSag === 1) {
      const fracH = sliceFrac;
      const dimV = 2;
      for (let i = 0; i < linesH.length; i++) {
        const mmV = this.frac2mm([0.5, 0.5, 0.5]);
        mmV[dimV] = linesH[i];
        let fracV = this.mm2frac(mmV);
        fracV = fracV[dimV];
        let left = this.frac2mm([0, fracH, fracV]);
        left = swizzleVec3(left, [0, 2, 1]);
        let right = this.frac2mm([1, fracH, fracV]);
        right = swizzleVec3(right, [0, 2, 1]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
    if (linesH.length > 0 && axCorSag === 2) {
      const fracX = sliceFrac;
      const dimV = 2;
      for (let i = 0; i < linesH.length; i++) {
        const mmV = this.frac2mm([0.5, 0.5, 0.5]);
        mmV[dimV] = linesH[i];
        let fracZ = this.mm2frac(mmV);
        fracZ = fracZ[dimV];
        let left = this.frac2mm([fracX, 0, fracZ]);
        left = swizzleVec3(left, [1, 2, 0]);
        let right = this.frac2mm([fracX, 1, fracZ]);
        right = swizzleVec3(right, [1, 2, 0]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
    if (linesV.length > 0 && axCorSag === 0) {
      const fracZ = sliceFrac;
      const dimH = 0;
      for (let i = 0; i < linesV.length; i++) {
        const mm = this.frac2mm([0.5, 0.5, 0.5]);
        mm[dimH] = linesV[i];
        let frac = this.mm2frac(mm);
        frac = frac[dimH];
        let left = this.frac2mm([frac, 0, fracZ]);
        left = swizzleVec3(left, [0, 1, 2]);
        let right = this.frac2mm([frac, 1, fracZ]);
        right = swizzleVec3(right, [0, 1, 2]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
    if (linesV.length > 0 && axCorSag === 1) {
      const fracY = sliceFrac;
      const dimH = 0;
      for (let i = 0; i < linesV.length; i++) {
        const mm = this.frac2mm([0.5, 0.5, 0.5]);
        mm[dimH] = linesV[i];
        let frac = this.mm2frac(mm);
        frac = frac[dimH];
        let left = this.frac2mm([frac, fracY, 0]);
        left = swizzleVec3(left, [0, 2, 1]);
        let right = this.frac2mm([frac, fracY, 1]);
        right = swizzleVec3(right, [0, 2, 1]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
    if (linesV.length > 0 && axCorSag === 2) {
      const fracX = sliceFrac;
      const dimH = 1;
      for (let i = 0; i < linesV.length; i++) {
        const mm = this.frac2mm([0.5, 0.5, 0.5]);
        mm[dimH] = linesV[i];
        let frac = this.mm2frac(mm);
        frac = frac[dimH];
        let left = this.frac2mm([fracX, frac, 0]);
        left = swizzleVec3(left, [1, 2, 0]);
        let right = this.frac2mm([fracX, frac, 1]);
        right = swizzleVec3(right, [1, 2, 0]);
        left = mm2screen(left);
        right = mm2screen(right);
        this.drawLine([left[0], left[1], right[0], right[1]], thick);
      }
    }
  }
  // not included in public docs
  drawCrossLines(sliceIndex, axCorSag, axiMM, corMM, sagMM) {
    if (sliceIndex < 0 || this.screenSlices.length <= sliceIndex) {
      return;
    }
    if (this.opts.isSliceMM) {
      return this.drawCrossLinesMM(sliceIndex, axCorSag, axiMM, corMM, sagMM);
    }
    if (this.screenSlices[sliceIndex].sliceFrac === Infinity) {
      return this.drawCrossLinesMM(sliceIndex, axCorSag, axiMM, corMM, sagMM);
    }
    const tile = this.screenSlices[sliceIndex];
    let linesH = corMM.slice();
    let linesV = sagMM.slice();
    if (axCorSag === 1 /* CORONAL */) {
      linesH = axiMM.slice();
    }
    if (axCorSag === 2 /* SAGITTAL */) {
      linesH = axiMM.slice();
      linesV = corMM.slice();
    }
    if (linesH.length > 0) {
      const LTWH = tile.leftTopWidthHeight.slice();
      let sliceDim = 2;
      if (axCorSag === 0 /* AXIAL */) {
        sliceDim = 1;
      }
      const mm = this.frac2mm([0.5, 0.5, 0.5]);
      for (let i = 0; i < linesH.length; i++) {
        mm[sliceDim] = linesH[i];
        const frac = this.mm2frac(mm);
        this.drawRect([LTWH[0], LTWH[1] + LTWH[3] - frac[sliceDim] * LTWH[3], LTWH[2], 1]);
      }
    }
    if (linesV.length > 0) {
      const LTWH = tile.leftTopWidthHeight.slice();
      const isRadiolgical = tile.fovMM[0] < 0;
      let sliceDim = 0;
      if (axCorSag === 2 /* SAGITTAL */) {
        sliceDim = 1;
      }
      const mm = this.frac2mm([0.5, 0.5, 0.5]);
      for (let i = 0; i < linesV.length; i++) {
        mm[sliceDim] = linesV[i];
        const frac = this.mm2frac(mm);
        if (isRadiolgical) {
          this.drawRect([LTWH[0] + (LTWH[2] - frac[sliceDim] * LTWH[2]), LTWH[1], 1, LTWH[3]]);
        } else {
          this.drawRect([LTWH[0] + frac[sliceDim] * LTWH[2], LTWH[1], 1, LTWH[3]]);
        }
      }
    }
  }
  /**
   * display a lightbox or montage view
   * @param mosaicStr - specifies orientation (A,C,S) and location of slices.
   * @example niivue.setSliceMosaicString("A -10 0 20");
   * @see {@link https://niivue.github.io/niivue/features/mosaics.html | live demo usage}
   */
  drawMosaic(mosaicStr) {
    if (this.volumes.length === 0) {
      log.debug("Unable to draw mosaic until voxel-based image is loaded");
      return;
    }
    this.screenSlices = [];
    const fovRenderMM = this.screenFieldOfViewMM(0 /* AXIAL */, true);
    const fovSliceMM = this.screenFieldOfViewMM(0 /* AXIAL */);
    mosaicStr = mosaicStr.replaceAll(";", " ;").trim();
    const axiMM = [];
    const corMM = [];
    const sagMM = [];
    const items = mosaicStr.split(/\s+/);
    let scale6 = 1;
    const labelSize = this.opts.textHeight;
    let marginLeft = 0;
    let marginTop = 0;
    for (let pass = 0; pass < 2; pass++) {
      let isRender = false;
      let isCrossLines = false;
      isRender = false;
      let rowHt = 0;
      let left = 0;
      let top = 0;
      let mxRowWid = 0;
      let isLabel = false;
      let axCorSag = 0 /* AXIAL */;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.includes("X")) {
          isCrossLines = true;
          continue;
        }
        if (item.includes("L")) {
          isLabel = !item.includes("-");
          continue;
        }
        if (item.includes("V") || item.includes("H")) {
          i++;
          continue;
        }
        if (item.includes("A")) {
          axCorSag = 0 /* AXIAL */;
        }
        if (item.includes("C")) {
          axCorSag = 1 /* CORONAL */;
        }
        if (item.includes("S")) {
          axCorSag = 2 /* SAGITTAL */;
        }
        if (item.includes("R")) {
          isRender = true;
        }
        if (item.includes(";")) {
          top += rowHt;
          mxRowWid = Math.max(mxRowWid, left);
          rowHt = 0;
          left = 0;
        }
        const sliceMM = parseFloat(item);
        if (isNaN(sliceMM)) {
          continue;
        }
        let w = 0;
        let h = 0;
        let fov = fovSliceMM;
        if (isRender) {
          fov = fovRenderMM;
        }
        if (axCorSag === 2 /* SAGITTAL */) {
          w = fov[1];
        } else {
          w = fov[0];
        }
        if (axCorSag === 0 /* AXIAL */) {
          h = fov[1];
        } else {
          h = fov[2];
        }
        if (pass === 0) {
          if (!isRender) {
            if (axCorSag === 0 /* AXIAL */) {
              axiMM.push(sliceMM);
            }
            if (axCorSag === 1 /* CORONAL */) {
              corMM.push(sliceMM);
            }
            if (axCorSag === 2 /* SAGITTAL */) {
              sagMM.push(sliceMM);
            }
          }
        } else {
          const ltwh = [marginLeft + scale6 * left, marginTop + scale6 * top, scale6 * w, scale6 * h];
          this.opts.textHeight = isLabel ? labelSize : 0;
          if (isRender) {
            let inf = sliceMM < 0 ? -Infinity : Infinity;
            if (Object.is(sliceMM, -0)) {
              inf = -Infinity;
            }
            this.draw2D(ltwh, axCorSag, inf);
          } else {
            this.draw2D(ltwh, axCorSag, sliceMM);
          }
          if (isCrossLines) {
            this.drawCrossLines(this.screenSlices.length - 1, axCorSag, axiMM, corMM, sagMM);
          }
          isRender = false;
          isCrossLines = false;
        }
        left += w;
        rowHt = Math.max(rowHt, h);
      }
      top += rowHt;
      mxRowWid = Math.max(mxRowWid, left);
      if (mxRowWid <= 0 || top <= 0) {
        break;
      }
      const scaleW = this.gl.canvas.width / mxRowWid;
      const scaleH = this.effectiveCanvasHeight() / top;
      scale6 = Math.min(scaleW, scaleH);
      if (this.opts.centerMosaic) {
        marginLeft = Math.floor(0.5 * (this.gl.canvas.width - mxRowWid * scale6));
        marginTop = Math.floor(0.5 * (this.effectiveCanvasHeight() - top * scale6));
      }
    }
    this.opts.textHeight = labelSize;
  }
  // not included in public docs
  drawSceneCore() {
    if (!this.initialized) {
      return;
    }
    this.colorbarHeight = 0;
    this.gl.clearColor(this.opts.backColor[0], this.opts.backColor[1], this.opts.backColor[2], this.opts.backColor[3]);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    if (this.bmpTexture && this.thumbnailVisible) {
      this.drawThumbnail();
      return;
    }
    let posString = "";
    if (this.volumes.length === 0 || typeof this.volumes[0].dims === "undefined") {
      if (this.meshes.length > 0) {
        this.screenSlices = [];
        this.draw3D();
        if (this.opts.isColorbar) {
          this.drawColorbar();
        }
        return;
      }
      this.drawLoadingText(this.opts.loadingText);
      return;
    }
    if (this.back === null) {
      return;
    }
    if (this.uiData.isDragging && this.scene.clipPlaneDepthAziElev[0] < 1.8 && this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0) {
      const x = this.uiData.dragStart[0] - this.uiData.dragEnd[0];
      const y = this.uiData.dragStart[1] - this.uiData.dragEnd[1];
      const depthAziElev = this.uiData.dragClipPlaneStartDepthAziElev.slice();
      depthAziElev[1] -= x;
      depthAziElev[1] = depthAziElev[1] % 360;
      depthAziElev[2] += y;
      if (depthAziElev[1] !== this.scene.clipPlaneDepthAziElev[1] || depthAziElev[2] !== this.scene.clipPlaneDepthAziElev[2]) {
        this.scene.clipPlaneDepthAziElev = depthAziElev;
        return this.setClipPlane(this.scene.clipPlaneDepthAziElev);
      }
    }
    if (this.sliceMosaicString.length < 1 && this.opts.sliceType === 4 /* RENDER */) {
      if (this.opts.isColorbar) {
        this.reserveColorbarPanel();
      }
      this.screenSlices = [];
      this.draw3D();
      if (this.opts.isColorbar) {
        this.drawColorbar();
      }
      return;
    }
    if (this.opts.isColorbar) {
      this.reserveColorbarPanel();
    }
    const maxVols = this.getMaxVols();
    const isDrawGraph = this.opts.sliceType === 3 /* MULTIPLANAR */ && maxVols > 1 && this.graph.autoSizeMultiplanar && this.graph.opacity > 0;
    if (this.sliceMosaicString.length > 0) {
      this.drawMosaic(this.sliceMosaicString);
    } else {
      const heroImageWH = [0, 0];
      let isHeroImage = false;
      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      this.screenSlices = [];
      if (this.opts.sliceType === 0 /* AXIAL */) {
        this.draw2D([0, 0, 0, 0], 0);
      } else if (this.opts.sliceType === 1 /* CORONAL */) {
        this.draw2D([0, 0, 0, 0], 1);
      } else if (this.opts.sliceType === 2 /* SAGITTAL */) {
        this.draw2D([0, 0, 0, 0], 2);
      } else {
        let padPixelsWH = function(cols, rows) {
          return [(cols - 1) * pad + cols * innerPad, (rows - 1) * pad + rows * innerPad];
        };
        let isShowRender = false;
        if (this.opts.multiplanarForceRender) {
          isShowRender = true;
          if (this.opts.multiplanarForceRender) {
            this.opts.multiplanarShowRender = 1 /* ALWAYS */;
          } else {
            this.opts.multiplanarShowRender = 2 /* AUTO */;
          }
          delete this.opts.multiplanarForceRender;
        } else {
          if (this.opts.multiplanarShowRender === 1 /* ALWAYS */) {
            isShowRender = true;
          }
        }
        const isDrawPenDown = isFinite(this.drawPenLocation[0]) && this.opts.drawingEnabled;
        const { volScale } = this.sliceScale();
        const actualScale = volScale.slice();
        if (this.opts.multiplanarEqualSize) {
          volScale[0] = 1;
          volScale[1] = 1;
          volScale[2] = 1;
        }
        if (typeof this.opts.multiplanarPadPixels !== "number") {
          log.debug("multiplanarPadPixels must be numeric");
        }
        const pad = parseFloat(`${this.opts.multiplanarPadPixels}`);
        let innerPad = this.opts.tileMargin;
        if (innerPad < 0) {
          innerPad = 2 * (2 + Math.ceil(Math.max(this.opts.textHeight, 0.01) * Math.min(this.gl.canvas.height, this.gl.canvas.width)));
        }
        let canvasWH = [this.effectiveCanvasWidth(), this.effectiveCanvasHeight()];
        if (this.opts.heroImageFraction > 0 && this.opts.heroImageFraction < 1) {
          isShowRender = false;
          isHeroImage = true;
          if (canvasWH[0] > canvasWH[1] && this.opts.multiplanarLayout !== 3 /* ROW */) {
            heroImageWH[0] = canvasWH[0] * this.opts.heroImageFraction;
          } else {
            heroImageWH[1] = canvasWH[1] * this.opts.heroImageFraction;
          }
          canvasWH = [canvasWH[0] - heroImageWH[0], canvasWH[1] - heroImageWH[1]];
        }
        const ltwh2x2 = this.scaleSlice(
          volScale[0] + volScale[1],
          volScale[1] + volScale[2],
          padPixelsWH(2, 2),
          canvasWH
        );
        const mx = Math.max(Math.max(volScale[1], volScale[2]), volScale[0]);
        const ltwh3x1 = this.scaleSlice(
          volScale[0] + volScale[0] + volScale[1],
          Math.max(volScale[1], volScale[2]),
          padPixelsWH(3, 1),
          canvasWH
        );
        const ltwh4x1 = this.scaleSlice(
          volScale[0] + volScale[0] + volScale[1] + mx,
          Math.max(volScale[1], volScale[2]),
          padPixelsWH(4, 1),
          canvasWH
        );
        const ltwh1x3 = this.scaleSlice(mx, volScale[1] + volScale[2] + volScale[2], padPixelsWH(1, 3), canvasWH);
        const ltwh1x4 = this.scaleSlice(mx, volScale[1] + volScale[2] + volScale[2] + mx, padPixelsWH(1, 4), canvasWH);
        let isDraw3D = !isDrawPenDown && (maxVols < 2 || !isDrawGraph);
        let isDrawColumn = false;
        let isDrawGrid = false;
        let isDrawRow = false;
        if (this.opts.multiplanarLayout === 1 /* COLUMN */) {
          isDrawColumn = true;
        } else if (this.opts.multiplanarLayout === 2 /* GRID */) {
          isDrawGrid = true;
        } else if (this.opts.multiplanarLayout === 3 /* ROW */) {
          isDrawRow = true;
        } else {
          if (ltwh1x3[4] > ltwh3x1[4] && ltwh1x3[4] > ltwh2x2[4]) {
            isDrawColumn = true;
          } else if (ltwh3x1[4] > ltwh2x2[4]) {
            isDrawRow = true;
          } else {
            isDrawGrid = true;
          }
        }
        let ltwh = ltwh2x2;
        if (isDrawColumn) {
          ltwh = ltwh1x3;
          if (!isHeroImage && (isShowRender || this.opts.multiplanarShowRender === 2 /* AUTO */ && ltwh1x4[4] >= ltwh1x3[4])) {
            ltwh = ltwh1x4;
          } else {
            isDraw3D = false;
          }
        } else if (isDrawRow) {
          ltwh = ltwh3x1;
          if (!isHeroImage && (isShowRender || this.opts.multiplanarShowRender === 2 /* AUTO */ && ltwh4x1[4] >= ltwh3x1[4])) {
            ltwh = ltwh4x1;
          } else {
            isDraw3D = false;
          }
        }
        if (isHeroImage) {
          const heroW = heroImageWH[0] === 0 ? this.effectiveCanvasWidth() : heroImageWH[0];
          const heroH = heroImageWH[1] === 0 ? this.effectiveCanvasHeight() : heroImageWH[1];
          if (this.opts?.heroSliceType === 0 /* AXIAL */ || this.opts?.heroSliceType === 1 /* CORONAL */ || this.opts?.heroSliceType === 2 /* SAGITTAL */) {
            this.draw2D([0, 0, heroW, heroH], this.opts.heroSliceType, NaN, [Infinity, Infinity]);
          } else {
            const ltwh2 = ltwh.slice();
            const canvasW = this.effectiveCanvasWidth();
            if (heroW === canvasW) {
              ltwh2[0] = 0;
            }
            this.draw3D([ltwh2[0], 0, heroW, heroH]);
          }
          ltwh[0] += heroImageWH[0];
          ltwh[1] += heroImageWH[1];
          isDraw3D = false;
        }
        const sX = volScale[0] * ltwh[4] + innerPad;
        const sY = volScale[1] * ltwh[4] + innerPad;
        const sZ = volScale[2] * ltwh[4] + innerPad;
        const actualX = actualScale[0] * ltwh[4];
        const actualY = actualScale[1] * ltwh[4];
        const actualZ = actualScale[2] * ltwh[4];
        if (isDrawColumn) {
          this.draw2D([ltwh[0], ltwh[1], sX, sY], 0, NaN, [actualX, actualY]);
          this.draw2D([ltwh[0], ltwh[1] + sY + pad, sX, sZ], 1, NaN, [actualX, actualZ]);
          this.draw2D([ltwh[0], ltwh[1] + sY + pad + sZ + pad, sY, sZ], 2, NaN, [actualY, actualZ]);
          if (isDraw3D) {
            const sMx = mx * ltwh[4];
            this.draw3D([ltwh[0], ltwh[1] + sY + sZ + sZ + pad * 3, sMx, sMx]);
          }
        } else if (isDrawRow) {
          this.draw2D([ltwh[0], ltwh[1], sX, sY], 0, NaN, [actualX, actualY]);
          this.draw2D([ltwh[0] + sX + pad, ltwh[1], sX, sZ], 1, NaN, [actualX, actualZ]);
          this.draw2D([ltwh[0] + sX + sX + pad * 2, ltwh[1], sY, sZ], 2, NaN, [actualY, actualZ]);
          if (isDraw3D) {
            const sMx = mx * ltwh[4];
            this.draw3D([ltwh[0] + sX + sX + sY + pad * 3, ltwh[1], sMx, sMx]);
          }
        } else if (isDrawGrid) {
          if (!isShowRender) {
            isDraw3D = false;
          }
          if (this.opts.multiplanarShowRender === 2 /* AUTO */) {
            isDraw3D = true;
          }
          if (isHeroImage) {
            isDraw3D = false;
          }
          this.draw2D([ltwh[0], ltwh[1] + sZ + pad, sX, sY], 0, NaN, [actualX, actualY]);
          this.draw2D([ltwh[0], ltwh[1], sX, sZ], 1, NaN, [actualX, actualZ]);
          this.draw2D([ltwh[0] + sX + pad, ltwh[1], sY, sZ], 2, NaN, [actualY, actualZ]);
          if (isDraw3D) {
            this.draw3D([ltwh[0] + sX + pad, ltwh[1] + sZ + pad, sY, sY]);
          }
        }
      }
    }
    if (this.opts.isRuler) {
      this.drawRuler();
    }
    if (this.opts.isColorbar) {
      this.drawColorbar();
    }
    if (isDrawGraph) {
      this.drawGraph();
    }
    if (this.uiData.isDragging) {
      if (this.uiData.mouseButtonCenterDown) {
        this.dragForCenterButton([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.opts.dragMode === 4 /* slicer3D */) {
        this.dragForSlicer3D([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.opts.dragMode === 3 /* pan */) {
        this.dragForPanZoom([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0) {
        return;
      }
      if (this.opts.dragMode === 2 /* measurement */) {
        this.drawMeasurementTool([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      const width = Math.abs(this.uiData.dragStart[0] - this.uiData.dragEnd[0]);
      const height = Math.abs(this.uiData.dragStart[1] - this.uiData.dragEnd[1]);
      this.drawSelectionBox([
        Math.min(this.uiData.dragStart[0], this.uiData.dragEnd[0]),
        Math.min(this.uiData.dragStart[1], this.uiData.dragEnd[1]),
        width,
        height
      ]);
      return;
    }
    if (this.opts.clickToSegment) {
      const x = this.mousePos[0];
      const y = this.mousePos[1];
      if (this.inRenderTile(x, y) >= 0) {
        return;
      }
      const tileIdx = this.tileIndex(x, y);
      if (tileIdx > -1) {
        const fovMM = this.screenSlices[tileIdx].fovMM;
        const ltwh = this.screenSlices[tileIdx].leftTopWidthHeight;
        const pixPerMM = ltwh[2] / fovMM[0];
        const color = this.opts.crosshairColor;
        const segmentCursorColor = [color[0], color[1], color[2], 0.4];
        const radius = this.opts.clickToSegmentRadius * pixPerMM;
        this.drawCircle([x - radius, y - radius, radius * 2, radius * 2], segmentCursorColor, 1);
      }
    }
    const pos = this.frac2mm([this.scene.crosshairPos[0], this.scene.crosshairPos[1], this.scene.crosshairPos[2]]);
    posString = pos[0].toFixed(2) + "\xD7" + pos[1].toFixed(2) + "\xD7" + pos[2].toFixed(2);
    this.readyForSync = true;
    this.sync();
    this.drawAnchoredLabels();
    return posString;
  }
  // not included in public docs
  // called to refresh canvas
  drawScene() {
    if (this.isBusy) {
      this.needsRefresh = true;
      return;
    }
    this.isBusy = false;
    this.needsRefresh = false;
    let posString = this.drawSceneCore();
    if (this._gl !== null) {
      this.gl.finish();
    }
    if (this.needsRefresh) {
      posString = this.drawScene();
    }
    return posString;
  }
  get gl() {
    if (!this._gl) {
      throw new Error("unable to get WebGL context. Maybe the browser doesn't support WebGL2.");
    }
    return this._gl;
  }
  set gl(gl) {
    this._gl = gl;
  }
};
export {
  COLORMAP_TYPE,
  DEFAULT_OPTIONS,
  DRAG_MODE,
  DRAG_MODE_PRIMARY,
  DRAG_MODE_SECONDARY,
  INITIAL_SCENE_DATA,
  LabelAnchorPoint,
  LabelLineTerminator,
  LabelTextAlignment,
  MULTIPLANAR_TYPE,
  NVDocument,
  NVImage,
  NVImageFromUrlOptions,
  NVLabel3D,
  NVLabel3DStyle,
  NVMesh3 as NVMesh,
  NVMeshFromUrlOptions,
  NVMeshLayerDefaults,
  NVMeshLoaders,
  NVMeshUtilities,
  NVUtilities,
  Niivue,
  SHOW_RENDER,
  SLICE_TYPE,
  cmapper,
  ColorTables as colortables
};
//# sourceMappingURL=index.js.map